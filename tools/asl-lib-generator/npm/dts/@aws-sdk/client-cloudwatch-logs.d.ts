// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   @aws-sdk/types
//   @aws-sdk/config-resolver
//   @aws-sdk/middleware-host-header
//   @aws-sdk/middleware-retry
//   @aws-sdk/middleware-signing
//   @aws-sdk/middleware-user-agent
//   @aws-sdk/protocol-http
//   @aws-sdk/smithy-client

declare module '@aws-sdk/client-cloudwatch-logs' {
    import { HttpHandlerOptions as __HttpHandlerOptions } from "@aws-sdk/types";
    import { CloudWatchLogsClient } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/CloudWatchLogsClient";
    import { AssociateKmsKeyCommandInput, AssociateKmsKeyCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/AssociateKmsKeyCommand";
    import { CancelExportTaskCommandInput, CancelExportTaskCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/CancelExportTaskCommand";
    import { CreateExportTaskCommandInput, CreateExportTaskCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/CreateExportTaskCommand";
    import { CreateLogGroupCommandInput, CreateLogGroupCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/CreateLogGroupCommand";
    import { CreateLogStreamCommandInput, CreateLogStreamCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/CreateLogStreamCommand";
    import { DeleteDestinationCommandInput, DeleteDestinationCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DeleteDestinationCommand";
    import { DeleteLogGroupCommandInput, DeleteLogGroupCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DeleteLogGroupCommand";
    import { DeleteLogStreamCommandInput, DeleteLogStreamCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DeleteLogStreamCommand";
    import { DeleteMetricFilterCommandInput, DeleteMetricFilterCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DeleteMetricFilterCommand";
    import { DeleteQueryDefinitionCommandInput, DeleteQueryDefinitionCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DeleteQueryDefinitionCommand";
    import { DeleteResourcePolicyCommandInput, DeleteResourcePolicyCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DeleteResourcePolicyCommand";
    import { DeleteRetentionPolicyCommandInput, DeleteRetentionPolicyCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DeleteRetentionPolicyCommand";
    import { DeleteSubscriptionFilterCommandInput, DeleteSubscriptionFilterCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DeleteSubscriptionFilterCommand";
    import { DescribeDestinationsCommandInput, DescribeDestinationsCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DescribeDestinationsCommand";
    import { DescribeExportTasksCommandInput, DescribeExportTasksCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DescribeExportTasksCommand";
    import { DescribeLogGroupsCommandInput, DescribeLogGroupsCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DescribeLogGroupsCommand";
    import { DescribeLogStreamsCommandInput, DescribeLogStreamsCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DescribeLogStreamsCommand";
    import { DescribeMetricFiltersCommandInput, DescribeMetricFiltersCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DescribeMetricFiltersCommand";
    import { DescribeQueriesCommandInput, DescribeQueriesCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DescribeQueriesCommand";
    import { DescribeQueryDefinitionsCommandInput, DescribeQueryDefinitionsCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DescribeQueryDefinitionsCommand";
    import { DescribeResourcePoliciesCommandInput, DescribeResourcePoliciesCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DescribeResourcePoliciesCommand";
    import { DescribeSubscriptionFiltersCommandInput, DescribeSubscriptionFiltersCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DescribeSubscriptionFiltersCommand";
    import { DisassociateKmsKeyCommandInput, DisassociateKmsKeyCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DisassociateKmsKeyCommand";
    import { FilterLogEventsCommandInput, FilterLogEventsCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/FilterLogEventsCommand";
    import { GetLogEventsCommandInput, GetLogEventsCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/GetLogEventsCommand";
    import { GetLogGroupFieldsCommandInput, GetLogGroupFieldsCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/GetLogGroupFieldsCommand";
    import { GetLogRecordCommandInput, GetLogRecordCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/GetLogRecordCommand";
    import { GetQueryResultsCommandInput, GetQueryResultsCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/GetQueryResultsCommand";
    import { ListTagsLogGroupCommandInput, ListTagsLogGroupCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/ListTagsLogGroupCommand";
    import { PutDestinationCommandInput, PutDestinationCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/PutDestinationCommand";
    import { PutDestinationPolicyCommandInput, PutDestinationPolicyCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/PutDestinationPolicyCommand";
    import { PutLogEventsCommandInput, PutLogEventsCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/PutLogEventsCommand";
    import { PutMetricFilterCommandInput, PutMetricFilterCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/PutMetricFilterCommand";
    import { PutQueryDefinitionCommandInput, PutQueryDefinitionCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/PutQueryDefinitionCommand";
    import { PutResourcePolicyCommandInput, PutResourcePolicyCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/PutResourcePolicyCommand";
    import { PutRetentionPolicyCommandInput, PutRetentionPolicyCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/PutRetentionPolicyCommand";
    import { PutSubscriptionFilterCommandInput, PutSubscriptionFilterCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/PutSubscriptionFilterCommand";
    import { StartQueryCommandInput, StartQueryCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/StartQueryCommand";
    import { StopQueryCommandInput, StopQueryCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/StopQueryCommand";
    import { TagLogGroupCommandInput, TagLogGroupCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/TagLogGroupCommand";
    import { TestMetricFilterCommandInput, TestMetricFilterCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/TestMetricFilterCommand";
    import { UntagLogGroupCommandInput, UntagLogGroupCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/UntagLogGroupCommand";
    /**
        * <p>You can use Amazon CloudWatch Logs to monitor, store, and access your log files from
        *       EC2 instances, CloudTrail, and other sources. You can then retrieve the associated
        *       log data from CloudWatch Logs using the CloudWatch console, CloudWatch Logs commands in the
        *       Amazon Web Services CLI, CloudWatch Logs API, or CloudWatch Logs SDK.</p>
        *          <p>You can use CloudWatch Logs to:</p>
        *          <ul>
        *             <li>
        *                <p>
        *                   <b>Monitor logs from EC2 instances in real-time</b>: You
        *           can use CloudWatch Logs to monitor applications and systems using log data. For example,
        *           CloudWatch Logs can track the number of errors that occur in your application logs and
        *           send you a notification whenever the rate of errors exceeds a threshold that you specify.
        *           CloudWatch Logs uses your log data for monitoring so no code changes are required. For
        *           example, you can monitor application logs for specific literal terms (such as
        *           "NullReferenceException") or count the number of occurrences of a literal term at a
        *           particular position in log data (such as "404" status codes in an Apache access log). When
        *           the term you are searching for is found, CloudWatch Logs reports the data to a CloudWatch
        *           metric that you specify.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <b>Monitor CloudTrail logged events</b>: You can
        *           create alarms in CloudWatch and receive notifications of particular API activity as
        *           captured by CloudTrail. You can use the notification to perform troubleshooting.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <b>Archive log data</b>: You can use CloudWatch Logs to
        *           store your log data in highly durable storage. You can change the log retention setting so
        *           that any log events older than this setting are automatically deleted. The CloudWatch Logs
        *           agent makes it easy to quickly send both rotated and non-rotated log data off of a host
        *           and into the log service. You can then access the raw log data when you need it.</p>
        *             </li>
        *          </ul>
        */
    export class CloudWatchLogs extends CloudWatchLogsClient {
            /**
                * <p>Associates the specified Key Management Service customer master key (CMK) with the specified log group.</p>
                *          <p>Associating an KMS CMK with a log group overrides any existing associations between the log group and a CMK.
                *       After a CMK is associated with a log group, all newly ingested data for the log group is encrypted using the CMK.
                *       This association is stored as long as the data encrypted with the CMK is still within CloudWatch Logs.
                *       This enables CloudWatch Logs to decrypt this data whenever it is requested.</p>
                *          <important>
                *             <p>CloudWatch Logs supports only symmetric CMKs. Do not use an associate an asymmetric CMK
                *         with your log group. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html">Using Symmetric and Asymmetric
                *           Keys</a>.</p>
                *          </important>
                *          <p>It can take up to 5 minutes for this operation to take effect.</p>
                *          <p>If you attempt to associate a CMK with a log group but the CMK does not exist or the
                *       CMK is disabled, you receive an <code>InvalidParameterException</code> error. </p>
                */
            associateKmsKey(args: AssociateKmsKeyCommandInput, options?: __HttpHandlerOptions): Promise<AssociateKmsKeyCommandOutput>;
            associateKmsKey(args: AssociateKmsKeyCommandInput, cb: (err: any, data?: AssociateKmsKeyCommandOutput) => void): void;
            associateKmsKey(args: AssociateKmsKeyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: AssociateKmsKeyCommandOutput) => void): void;
            /**
                * <p>Cancels the specified export task.</p>
                *          <p>The task must be in the <code>PENDING</code> or <code>RUNNING</code> state.</p>
                */
            cancelExportTask(args: CancelExportTaskCommandInput, options?: __HttpHandlerOptions): Promise<CancelExportTaskCommandOutput>;
            cancelExportTask(args: CancelExportTaskCommandInput, cb: (err: any, data?: CancelExportTaskCommandOutput) => void): void;
            cancelExportTask(args: CancelExportTaskCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CancelExportTaskCommandOutput) => void): void;
            /**
                * <p>Creates an export task, which allows you to efficiently export data from a
                *       log group to an Amazon S3 bucket. When you perform a <code>CreateExportTask</code>
                *       operation, you must use credentials that have permission to write to the S3 bucket
                *       that you specify as the destination.</p>
                *          <important>
                *             <p>Exporting log data to Amazon S3 buckets that are encrypted by KMS is not
                *       supported. Exporting
                *       log data to Amazon S3 buckets that have S3 Object Lock enabled with a retention period is not supported.</p>
                *             <p>Exporting to S3 buckets that are encrypted with AES-256 is supported. </p>
                *          </important>
                *          <p>This is an asynchronous call. If all the required information is provided, this
                *       operation initiates an export task and responds with the ID of the task. After the task has started,
                *       you can use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DescribeExportTasks.html">DescribeExportTasks</a> to get the status of the export task. Each account can
                *       only have one active (<code>RUNNING</code> or <code>PENDING</code>) export task at a time.
                *       To cancel an export task, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_CancelExportTask.html">CancelExportTask</a>.</p>
                *          <p>You can export logs from multiple log groups or multiple time ranges to the same S3
                *       bucket. To separate out log data for each export task, you can specify a prefix to be used as
                *       the Amazon S3 key prefix for all exported objects.</p>
                *
                *          <note>
                *             <p>Time-based sorting on chunks of log data inside an exported file is not guaranteed. You can sort the
                *       exported log fild data by using Linux utilities.</p>
                *          </note>
                */
            createExportTask(args: CreateExportTaskCommandInput, options?: __HttpHandlerOptions): Promise<CreateExportTaskCommandOutput>;
            createExportTask(args: CreateExportTaskCommandInput, cb: (err: any, data?: CreateExportTaskCommandOutput) => void): void;
            createExportTask(args: CreateExportTaskCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateExportTaskCommandOutput) => void): void;
            /**
                * <p>Creates a log group with the specified name. You can create up to 20,000 log groups per account.</p>
                *          <p>You must use the following guidelines when naming a log group:</p>
                *          <ul>
                *             <li>
                *                <p>Log group names must be unique within a region for an Amazon Web Services account.</p>
                *             </li>
                *             <li>
                *                <p>Log group names can be between 1 and 512 characters long.</p>
                *             </li>
                *             <li>
                *                <p>Log group names consist of the following characters: a-z, A-Z, 0-9, '_' (underscore), '-' (hyphen),
                *           '/' (forward slash), '.' (period), and '#' (number sign)</p>
                *             </li>
                *          </ul>
                *          <p>When you create a log group, by default the log events in the log group never expire. To set
                *     a retention policy so that events expire and are deleted after a specified time, use
                *       <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutRetentionPolicy.html">PutRetentionPolicy</a>.</p>
                *          <p>If you associate a Key Management Service customer master key (CMK) with the log group, ingested data is encrypted using the CMK.
                *       This association is stored as long as the data encrypted with the CMK is still within CloudWatch Logs.
                *       This enables CloudWatch Logs to decrypt this data whenever it is requested.</p>
                *          <p>If you attempt to associate a CMK with the log group but the CMK does not exist or the
                *       CMK is disabled, you receive an <code>InvalidParameterException</code> error. </p>
                *          <important>
                *             <p>CloudWatch Logs supports only symmetric CMKs. Do not associate an asymmetric CMK with
                *         your log group. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html">Using Symmetric and Asymmetric
                *           Keys</a>.</p>
                *          </important>
                */
            createLogGroup(args: CreateLogGroupCommandInput, options?: __HttpHandlerOptions): Promise<CreateLogGroupCommandOutput>;
            createLogGroup(args: CreateLogGroupCommandInput, cb: (err: any, data?: CreateLogGroupCommandOutput) => void): void;
            createLogGroup(args: CreateLogGroupCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateLogGroupCommandOutput) => void): void;
            /**
                * <p>Creates a log stream for the specified log group. A log stream is a sequence of log events
                *       that originate from a single source, such as an application instance or a resource that is
                *       being monitored.</p>
                *          <p>There is no limit on the number of log streams that you can create for a log group. There is a limit
                *     of 50 TPS on <code>CreateLogStream</code> operations, after which transactions are throttled.</p>
                *          <p>You must use the following guidelines when naming a log stream:</p>
                *          <ul>
                *             <li>
                *                <p>Log stream names must be unique within the log group.</p>
                *             </li>
                *             <li>
                *                <p>Log stream names can be between 1 and 512 characters long.</p>
                *             </li>
                *             <li>
                *                <p>The ':' (colon) and '*' (asterisk) characters are not allowed.</p>
                *             </li>
                *          </ul>
                */
            createLogStream(args: CreateLogStreamCommandInput, options?: __HttpHandlerOptions): Promise<CreateLogStreamCommandOutput>;
            createLogStream(args: CreateLogStreamCommandInput, cb: (err: any, data?: CreateLogStreamCommandOutput) => void): void;
            createLogStream(args: CreateLogStreamCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateLogStreamCommandOutput) => void): void;
            /**
                * <p>Deletes the specified destination, and eventually disables all the
                *       subscription filters that publish to it. This operation does not delete the
                *       physical resource encapsulated by the destination.</p>
                */
            deleteDestination(args: DeleteDestinationCommandInput, options?: __HttpHandlerOptions): Promise<DeleteDestinationCommandOutput>;
            deleteDestination(args: DeleteDestinationCommandInput, cb: (err: any, data?: DeleteDestinationCommandOutput) => void): void;
            deleteDestination(args: DeleteDestinationCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteDestinationCommandOutput) => void): void;
            /**
                * <p>Deletes the specified log group and permanently deletes all the archived
                *       log events associated with the log group.</p>
                */
            deleteLogGroup(args: DeleteLogGroupCommandInput, options?: __HttpHandlerOptions): Promise<DeleteLogGroupCommandOutput>;
            deleteLogGroup(args: DeleteLogGroupCommandInput, cb: (err: any, data?: DeleteLogGroupCommandOutput) => void): void;
            deleteLogGroup(args: DeleteLogGroupCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteLogGroupCommandOutput) => void): void;
            /**
                * <p>Deletes the specified log stream and permanently deletes all the archived log events associated
                *       with the log stream.</p>
                */
            deleteLogStream(args: DeleteLogStreamCommandInput, options?: __HttpHandlerOptions): Promise<DeleteLogStreamCommandOutput>;
            deleteLogStream(args: DeleteLogStreamCommandInput, cb: (err: any, data?: DeleteLogStreamCommandOutput) => void): void;
            deleteLogStream(args: DeleteLogStreamCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteLogStreamCommandOutput) => void): void;
            /**
                * <p>Deletes the specified metric filter.</p>
                */
            deleteMetricFilter(args: DeleteMetricFilterCommandInput, options?: __HttpHandlerOptions): Promise<DeleteMetricFilterCommandOutput>;
            deleteMetricFilter(args: DeleteMetricFilterCommandInput, cb: (err: any, data?: DeleteMetricFilterCommandOutput) => void): void;
            deleteMetricFilter(args: DeleteMetricFilterCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteMetricFilterCommandOutput) => void): void;
            /**
                * <p>Deletes a saved CloudWatch Logs Insights query definition.
                *       A query definition contains details about a saved CloudWatch Logs Insights query.</p>
                *          <p>Each <code>DeleteQueryDefinition</code> operation can delete one query definition.</p>
                *          <p>You must have the <code>logs:DeleteQueryDefinition</code> permission to be able to perform
                *       this operation.</p>
                */
            deleteQueryDefinition(args: DeleteQueryDefinitionCommandInput, options?: __HttpHandlerOptions): Promise<DeleteQueryDefinitionCommandOutput>;
            deleteQueryDefinition(args: DeleteQueryDefinitionCommandInput, cb: (err: any, data?: DeleteQueryDefinitionCommandOutput) => void): void;
            deleteQueryDefinition(args: DeleteQueryDefinitionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteQueryDefinitionCommandOutput) => void): void;
            /**
                * <p>Deletes a resource policy from this account. This revokes
                *     the access of the identities in that policy to put log events to this account.</p>
                */
            deleteResourcePolicy(args: DeleteResourcePolicyCommandInput, options?: __HttpHandlerOptions): Promise<DeleteResourcePolicyCommandOutput>;
            deleteResourcePolicy(args: DeleteResourcePolicyCommandInput, cb: (err: any, data?: DeleteResourcePolicyCommandOutput) => void): void;
            deleteResourcePolicy(args: DeleteResourcePolicyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteResourcePolicyCommandOutput) => void): void;
            /**
                * <p>Deletes the specified retention policy.</p>
                *          <p>Log events do not expire if they belong to log groups without a retention policy.</p>
                */
            deleteRetentionPolicy(args: DeleteRetentionPolicyCommandInput, options?: __HttpHandlerOptions): Promise<DeleteRetentionPolicyCommandOutput>;
            deleteRetentionPolicy(args: DeleteRetentionPolicyCommandInput, cb: (err: any, data?: DeleteRetentionPolicyCommandOutput) => void): void;
            deleteRetentionPolicy(args: DeleteRetentionPolicyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteRetentionPolicyCommandOutput) => void): void;
            /**
                * <p>Deletes the specified subscription filter.</p>
                */
            deleteSubscriptionFilter(args: DeleteSubscriptionFilterCommandInput, options?: __HttpHandlerOptions): Promise<DeleteSubscriptionFilterCommandOutput>;
            deleteSubscriptionFilter(args: DeleteSubscriptionFilterCommandInput, cb: (err: any, data?: DeleteSubscriptionFilterCommandOutput) => void): void;
            deleteSubscriptionFilter(args: DeleteSubscriptionFilterCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteSubscriptionFilterCommandOutput) => void): void;
            /**
                * <p>Lists all your destinations. The results are ASCII-sorted by destination name.</p>
                */
            describeDestinations(args: DescribeDestinationsCommandInput, options?: __HttpHandlerOptions): Promise<DescribeDestinationsCommandOutput>;
            describeDestinations(args: DescribeDestinationsCommandInput, cb: (err: any, data?: DescribeDestinationsCommandOutput) => void): void;
            describeDestinations(args: DescribeDestinationsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeDestinationsCommandOutput) => void): void;
            /**
                * <p>Lists the specified export tasks. You can list all your export tasks or filter
                *       the results based on task ID or task status.</p>
                */
            describeExportTasks(args: DescribeExportTasksCommandInput, options?: __HttpHandlerOptions): Promise<DescribeExportTasksCommandOutput>;
            describeExportTasks(args: DescribeExportTasksCommandInput, cb: (err: any, data?: DescribeExportTasksCommandOutput) => void): void;
            describeExportTasks(args: DescribeExportTasksCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeExportTasksCommandOutput) => void): void;
            /**
                * <p>Lists the specified log groups. You can list all your log groups or filter the results by prefix.
                *       The results are ASCII-sorted by log group name.</p>
                *          <p>CloudWatch Logs doesnâ€™t support IAM policies that control access to the <code>DescribeLogGroups</code> action by using the
                *       <code>aws:ResourceTag/<i>key-name</i>
                *             </code> condition key. Other CloudWatch Logs actions
                *       do support the use of the <code>aws:ResourceTag/<i>key-name</i>
                *             </code> condition key to control access.
                *       For more information about using tags to control access, see
                *       <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_tags.html">Controlling access to Amazon Web Services resources using tags</a>.</p>
                */
            describeLogGroups(args: DescribeLogGroupsCommandInput, options?: __HttpHandlerOptions): Promise<DescribeLogGroupsCommandOutput>;
            describeLogGroups(args: DescribeLogGroupsCommandInput, cb: (err: any, data?: DescribeLogGroupsCommandOutput) => void): void;
            describeLogGroups(args: DescribeLogGroupsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeLogGroupsCommandOutput) => void): void;
            /**
                * <p>Lists the log streams for the specified log group.
                *       You can list all the log streams or filter the results by prefix.
                *       You can also control how the results are ordered.</p>
                *          <p>This operation has a limit of five transactions per second, after which transactions are throttled.</p>
                */
            describeLogStreams(args: DescribeLogStreamsCommandInput, options?: __HttpHandlerOptions): Promise<DescribeLogStreamsCommandOutput>;
            describeLogStreams(args: DescribeLogStreamsCommandInput, cb: (err: any, data?: DescribeLogStreamsCommandOutput) => void): void;
            describeLogStreams(args: DescribeLogStreamsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeLogStreamsCommandOutput) => void): void;
            /**
                * <p>Lists the specified metric filters. You can list all of the metric filters or filter
                *       the results by log name, prefix, metric name, or metric namespace. The results are
                *       ASCII-sorted by filter name.</p>
                */
            describeMetricFilters(args: DescribeMetricFiltersCommandInput, options?: __HttpHandlerOptions): Promise<DescribeMetricFiltersCommandOutput>;
            describeMetricFilters(args: DescribeMetricFiltersCommandInput, cb: (err: any, data?: DescribeMetricFiltersCommandOutput) => void): void;
            describeMetricFilters(args: DescribeMetricFiltersCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeMetricFiltersCommandOutput) => void): void;
            /**
                * <p>Returns a list of CloudWatch Logs Insights queries that are scheduled, executing, or have
                *       been executed recently in this account. You can request all queries or limit it to queries of
                *       a specific log group or queries with a certain status.</p>
                */
            describeQueries(args: DescribeQueriesCommandInput, options?: __HttpHandlerOptions): Promise<DescribeQueriesCommandOutput>;
            describeQueries(args: DescribeQueriesCommandInput, cb: (err: any, data?: DescribeQueriesCommandOutput) => void): void;
            describeQueries(args: DescribeQueriesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeQueriesCommandOutput) => void): void;
            /**
                * <p>This operation returns a paginated list of your saved CloudWatch Logs Insights query definitions.</p>
                *          <p>You can use the <code>queryDefinitionNamePrefix</code> parameter to limit the results to only the
                *       query definitions that have names that start with a certain string.</p>
                */
            describeQueryDefinitions(args: DescribeQueryDefinitionsCommandInput, options?: __HttpHandlerOptions): Promise<DescribeQueryDefinitionsCommandOutput>;
            describeQueryDefinitions(args: DescribeQueryDefinitionsCommandInput, cb: (err: any, data?: DescribeQueryDefinitionsCommandOutput) => void): void;
            describeQueryDefinitions(args: DescribeQueryDefinitionsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeQueryDefinitionsCommandOutput) => void): void;
            /**
                * <p>Lists the resource policies in this account.</p>
                */
            describeResourcePolicies(args: DescribeResourcePoliciesCommandInput, options?: __HttpHandlerOptions): Promise<DescribeResourcePoliciesCommandOutput>;
            describeResourcePolicies(args: DescribeResourcePoliciesCommandInput, cb: (err: any, data?: DescribeResourcePoliciesCommandOutput) => void): void;
            describeResourcePolicies(args: DescribeResourcePoliciesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeResourcePoliciesCommandOutput) => void): void;
            /**
                * <p>Lists the subscription filters for the specified log group. You can list all the subscription filters or filter the results by prefix.
                *       The results are ASCII-sorted by filter name.</p>
                */
            describeSubscriptionFilters(args: DescribeSubscriptionFiltersCommandInput, options?: __HttpHandlerOptions): Promise<DescribeSubscriptionFiltersCommandOutput>;
            describeSubscriptionFilters(args: DescribeSubscriptionFiltersCommandInput, cb: (err: any, data?: DescribeSubscriptionFiltersCommandOutput) => void): void;
            describeSubscriptionFilters(args: DescribeSubscriptionFiltersCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeSubscriptionFiltersCommandOutput) => void): void;
            /**
                * <p>Disassociates the associated Key Management Service customer master key (CMK) from the specified log group.</p>
                *          <p>After the KMS CMK is disassociated from the log group, CloudWatch Logs stops encrypting newly ingested data for the log group.
                *       All previously ingested data remains encrypted, and CloudWatch Logs requires permissions for the CMK whenever the encrypted data is requested.</p>
                *          <p>Note that it can take up to 5 minutes for this operation to take effect.</p>
                */
            disassociateKmsKey(args: DisassociateKmsKeyCommandInput, options?: __HttpHandlerOptions): Promise<DisassociateKmsKeyCommandOutput>;
            disassociateKmsKey(args: DisassociateKmsKeyCommandInput, cb: (err: any, data?: DisassociateKmsKeyCommandOutput) => void): void;
            disassociateKmsKey(args: DisassociateKmsKeyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DisassociateKmsKeyCommandOutput) => void): void;
            /**
                * <p>Lists log events from the specified log group. You can list all the log events or filter the results
                *       using a filter pattern, a time range, and the name of the log stream.</p>
                *          <p>By default, this operation returns as many log events as can fit in 1 MB (up to 10,000
                *       log events) or all the events found within the time range that you specify. If the results
                *       include a token, then there are more log events available, and you can get additional results
                *       by specifying the token in a subsequent call. This operation can return empty results
                *     while there are more log events available through the token.</p>
                *          <p>The returned log events are sorted by event timestamp, the timestamp when the event was ingested
                *     by CloudWatch Logs, and the ID of the <code>PutLogEvents</code> request.</p>
                */
            filterLogEvents(args: FilterLogEventsCommandInput, options?: __HttpHandlerOptions): Promise<FilterLogEventsCommandOutput>;
            filterLogEvents(args: FilterLogEventsCommandInput, cb: (err: any, data?: FilterLogEventsCommandOutput) => void): void;
            filterLogEvents(args: FilterLogEventsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: FilterLogEventsCommandOutput) => void): void;
            /**
                * <p>Lists log events from the specified log stream. You can list all of the log events or
                *       filter using a time range.</p>
                *
                *          <p>By default, this operation returns as many log events as can fit in a response size of 1MB (up to 10,000 log events).
                *       You can get additional log events by specifying one of the tokens in a subsequent call.
                *       This operation can return empty results while there are more log events available through the token.</p>
                */
            getLogEvents(args: GetLogEventsCommandInput, options?: __HttpHandlerOptions): Promise<GetLogEventsCommandOutput>;
            getLogEvents(args: GetLogEventsCommandInput, cb: (err: any, data?: GetLogEventsCommandOutput) => void): void;
            getLogEvents(args: GetLogEventsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetLogEventsCommandOutput) => void): void;
            /**
                * <p>Returns a list of the fields that are included in log events in the specified log group, along with the percentage of log events
                *     that contain each field. The search is limited to a time period that you specify.</p>
                *          <p>In the results, fields that start with @ are fields generated by CloudWatch Logs. For
                *       example, <code>@timestamp</code> is the timestamp of each log event. For more information about the fields that are
                *       generated by CloudWatch logs, see
                *       <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CWL_AnalyzeLogData-discoverable-fields.html">Supported Logs and Discovered Fields</a>.</p>
                *          <p>The response results are sorted by the frequency percentage, starting
                *     with the highest percentage.</p>
                */
            getLogGroupFields(args: GetLogGroupFieldsCommandInput, options?: __HttpHandlerOptions): Promise<GetLogGroupFieldsCommandOutput>;
            getLogGroupFields(args: GetLogGroupFieldsCommandInput, cb: (err: any, data?: GetLogGroupFieldsCommandOutput) => void): void;
            getLogGroupFields(args: GetLogGroupFieldsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetLogGroupFieldsCommandOutput) => void): void;
            /**
                * <p>Retrieves all of the fields and values of a single log event. All fields are retrieved,
                *       even if the original query that produced the <code>logRecordPointer</code> retrieved only a
                *       subset of fields. Fields are returned as field name/field value pairs.</p>
                *          <p>The full unparsed log event is returned within <code>@message</code>.</p>
                */
            getLogRecord(args: GetLogRecordCommandInput, options?: __HttpHandlerOptions): Promise<GetLogRecordCommandOutput>;
            getLogRecord(args: GetLogRecordCommandInput, cb: (err: any, data?: GetLogRecordCommandOutput) => void): void;
            getLogRecord(args: GetLogRecordCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetLogRecordCommandOutput) => void): void;
            /**
                * <p>Returns the results from the specified query.</p>
                *          <p>Only the fields requested in the query are returned, along with a <code>@ptr</code>
                *       field, which is the identifier for the log record. You can use the value of <code>@ptr</code>
                *       in a <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_GetLogRecord.html">GetLogRecord</a>
                *       operation to get the full log record.</p>
                *          <p>
                *             <code>GetQueryResults</code>
                *       does not start a query execution. To run a query, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_StartQuery.html">StartQuery</a>.</p>
                *          <p>If the value of the <code>Status</code> field in the output is <code>Running</code>, this operation
                *       returns only partial results. If you see a value of <code>Scheduled</code> or <code>Running</code> for the status,
                *       you can retry the operation later to see the final results. </p>
                */
            getQueryResults(args: GetQueryResultsCommandInput, options?: __HttpHandlerOptions): Promise<GetQueryResultsCommandOutput>;
            getQueryResults(args: GetQueryResultsCommandInput, cb: (err: any, data?: GetQueryResultsCommandOutput) => void): void;
            getQueryResults(args: GetQueryResultsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetQueryResultsCommandOutput) => void): void;
            /**
                * <p>Lists the tags for the specified log group.</p>
                */
            listTagsLogGroup(args: ListTagsLogGroupCommandInput, options?: __HttpHandlerOptions): Promise<ListTagsLogGroupCommandOutput>;
            listTagsLogGroup(args: ListTagsLogGroupCommandInput, cb: (err: any, data?: ListTagsLogGroupCommandOutput) => void): void;
            listTagsLogGroup(args: ListTagsLogGroupCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListTagsLogGroupCommandOutput) => void): void;
            /**
                * <p>Creates or updates a destination. This operation is used only to create destinations for cross-account subscriptions.</p>
                *          <p>A destination encapsulates a physical resource (such
                *       as an Amazon Kinesis stream) and enables you to subscribe to a real-time stream of log events
                *       for a different account, ingested using <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutLogEvents.html">PutLogEvents</a>.</p>
                *          <p>Through an access policy, a destination controls what is written to it.
                *       By default, <code>PutDestination</code> does not set any access policy with the destination,
                *       which means a cross-account user cannot call <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutSubscriptionFilter.html">PutSubscriptionFilter</a> against
                *       this destination. To enable this, the destination owner must call <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutDestinationPolicy.html">PutDestinationPolicy</a> after <code>PutDestination</code>.</p>
                *          <p>To perform a <code>PutDestination</code> operation, you must also have the
                *     <code>iam:PassRole</code> permission.</p>
                */
            putDestination(args: PutDestinationCommandInput, options?: __HttpHandlerOptions): Promise<PutDestinationCommandOutput>;
            putDestination(args: PutDestinationCommandInput, cb: (err: any, data?: PutDestinationCommandOutput) => void): void;
            putDestination(args: PutDestinationCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: PutDestinationCommandOutput) => void): void;
            /**
                * <p>Creates or updates an access policy associated with an existing
                *       destination. An access policy is an <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/policies_overview.html">IAM policy document</a> that is used
                *       to authorize claims to register a subscription filter against a given destination.</p>
                *          <p>If multiple Amazon Web Services accounts are sending logs to this destination, each sender account must be
                *     listed separately in the policy. The policy does not support specifying <code>*</code>
                *     as the Principal or the use of the <code>aws:PrincipalOrgId</code> global key.</p>
                */
            putDestinationPolicy(args: PutDestinationPolicyCommandInput, options?: __HttpHandlerOptions): Promise<PutDestinationPolicyCommandOutput>;
            putDestinationPolicy(args: PutDestinationPolicyCommandInput, cb: (err: any, data?: PutDestinationPolicyCommandOutput) => void): void;
            putDestinationPolicy(args: PutDestinationPolicyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: PutDestinationPolicyCommandOutput) => void): void;
            /**
                * <p>Uploads a batch of log events to the specified log stream.</p>
                *          <p>You must include the sequence token obtained from the response of the previous call. An
                *       upload in a newly created log stream does not require a sequence token. You can also get the
                *       sequence token in the <code>expectedSequenceToken</code> field from
                *         <code>InvalidSequenceTokenException</code>. If you call <code>PutLogEvents</code> twice
                *       within a narrow time period using the same value for <code>sequenceToken</code>, both calls
                *       might be successful or one might be rejected.</p>
                *          <p>The batch of events must satisfy the following constraints:</p>
                *          <ul>
                *             <li>
                *                <p>The maximum batch size is 1,048,576 bytes. This size is calculated as the sum of
                *           all event messages in UTF-8, plus 26 bytes for each log event.</p>
                *             </li>
                *             <li>
                *                <p>None of the log events in the batch can be more than 2 hours in the future.</p>
                *             </li>
                *             <li>
                *                <p>None of the log events in the batch can be older than 14 days or older than the retention
                *           period of the log group.</p>
                *             </li>
                *             <li>
                *                <p>The log events in the batch must be in chronological order by their timestamp. The
                *           timestamp is the time the event occurred, expressed as the number of milliseconds after
                *           Jan 1, 1970 00:00:00 UTC. (In Amazon Web Services Tools for PowerShell and the Amazon Web Services SDK for .NET, the
                *           timestamp is specified in .NET format: yyyy-mm-ddThh:mm:ss. For example,
                *           2017-09-15T13:45:30.) </p>
                *             </li>
                *             <li>
                *                <p>A batch of log events in a single request cannot span more than 24 hours. Otherwise, the operation fails.</p>
                *             </li>
                *             <li>
                *                <p>The maximum number of log events in a batch is 10,000.</p>
                *             </li>
                *             <li>
                *                <p>There is a quota of 5 requests per second per log stream. Additional requests are throttled. This quota can't be changed.</p>
                *             </li>
                *          </ul>
                *          <p>If a call to <code>PutLogEvents</code> returns "UnrecognizedClientException" the most likely cause is an invalid Amazon Web Services access key ID or secret key. </p>
                */
            putLogEvents(args: PutLogEventsCommandInput, options?: __HttpHandlerOptions): Promise<PutLogEventsCommandOutput>;
            putLogEvents(args: PutLogEventsCommandInput, cb: (err: any, data?: PutLogEventsCommandOutput) => void): void;
            putLogEvents(args: PutLogEventsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: PutLogEventsCommandOutput) => void): void;
            /**
                * <p>Creates or updates a metric filter and associates it with the specified log group.
                *       Metric filters allow you to configure rules to extract metric data from log events ingested
                *       through <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutLogEvents.html">PutLogEvents</a>.</p>
                *          <p>The maximum number of metric filters that can be associated with a log group is
                *       100.</p>
                *          <p>When you create a metric filter, you can also optionally assign a unit and dimensions
                *     to the metric that is created.</p>
                *          <important>
                *             <p>Metrics extracted from log events are charged as custom metrics.
                *       To prevent unexpected high charges, do not specify high-cardinality fields such as
                *       <code>IPAddress</code> or <code>requestID</code> as dimensions. Each different value
                *       found for
                *       a dimension is treated as a separate metric and accrues charges as a separate custom metric.
                *     </p>
                *             <p>To help prevent accidental high charges, Amazon disables a metric filter
                *         if it generates 1000 different name/value pairs for the dimensions that you
                *         have specified within a certain amount of time.</p>
                *             <p>You can also set up a billing alarm to alert you if your charges are higher than
                *         expected. For more information,
                *         see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/monitor_estimated_charges_with_cloudwatch.html">
                *           Creating a Billing Alarm to Monitor Your Estimated Amazon Web Services Charges</a>.
                *       </p>
                *          </important>
                */
            putMetricFilter(args: PutMetricFilterCommandInput, options?: __HttpHandlerOptions): Promise<PutMetricFilterCommandOutput>;
            putMetricFilter(args: PutMetricFilterCommandInput, cb: (err: any, data?: PutMetricFilterCommandOutput) => void): void;
            putMetricFilter(args: PutMetricFilterCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: PutMetricFilterCommandOutput) => void): void;
            /**
                * <p>Creates or updates a query definition for CloudWatch Logs Insights. For
                *       more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/AnalyzingLogData.html">Analyzing Log Data with CloudWatch Logs Insights</a>.</p>
                *
                *          <p>To update a query definition, specify its
                *         <code>queryDefinitionId</code> in your request. The values of <code>name</code>, <code>queryString</code>,
                *       and <code>logGroupNames</code> are changed to the values that you specify in your update
                *       operation. No current values are retained from the current query definition. For example, if
                *       you update a current query definition that includes log groups, and you don't specify the
                *         <code>logGroupNames</code> parameter in your update operation, the query definition changes
                *       to contain no log groups.</p>
                *          <p>You must have the <code>logs:PutQueryDefinition</code> permission to be able to perform
                *     this operation.</p>
                */
            putQueryDefinition(args: PutQueryDefinitionCommandInput, options?: __HttpHandlerOptions): Promise<PutQueryDefinitionCommandOutput>;
            putQueryDefinition(args: PutQueryDefinitionCommandInput, cb: (err: any, data?: PutQueryDefinitionCommandOutput) => void): void;
            putQueryDefinition(args: PutQueryDefinitionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: PutQueryDefinitionCommandOutput) => void): void;
            /**
                * <p>Creates or updates a resource policy allowing other Amazon Web Services services to put log events to
                *       this account, such as Amazon Route 53. An account can have up to 10 resource policies per Amazon Web Services
                *       Region.</p>
                */
            putResourcePolicy(args: PutResourcePolicyCommandInput, options?: __HttpHandlerOptions): Promise<PutResourcePolicyCommandOutput>;
            putResourcePolicy(args: PutResourcePolicyCommandInput, cb: (err: any, data?: PutResourcePolicyCommandOutput) => void): void;
            putResourcePolicy(args: PutResourcePolicyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: PutResourcePolicyCommandOutput) => void): void;
            /**
                * <p>Sets the retention of the specified log group. A retention policy allows you to
                *       configure the number of days for which to retain log events in the specified log
                *       group.</p>
                */
            putRetentionPolicy(args: PutRetentionPolicyCommandInput, options?: __HttpHandlerOptions): Promise<PutRetentionPolicyCommandOutput>;
            putRetentionPolicy(args: PutRetentionPolicyCommandInput, cb: (err: any, data?: PutRetentionPolicyCommandOutput) => void): void;
            putRetentionPolicy(args: PutRetentionPolicyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: PutRetentionPolicyCommandOutput) => void): void;
            /**
                * <p>Creates or updates a subscription filter and associates it with the specified log
                *       group. Subscription filters allow you to subscribe to a real-time stream of log events
                *       ingested through <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutLogEvents.html">PutLogEvents</a> and have them delivered to a specific
                *       destination. When log events are sent to the
                *       receiving service, they are Base64 encoded
                *       and compressed with the gzip format.</p>
                *          <p>The following destinations are supported for subscription filters:</p>
                *          <ul>
                *             <li>
                *                <p>An Amazon Kinesis stream belonging to the same account as the subscription filter,
                *           for same-account delivery.</p>
                *             </li>
                *             <li>
                *                <p>A logical destination that belongs to a different account, for cross-account delivery.</p>
                *             </li>
                *             <li>
                *                <p>An Amazon Kinesis Firehose delivery stream that belongs to the same account as the
                *           subscription filter, for same-account delivery.</p>
                *             </li>
                *             <li>
                *                <p>An Lambda function that belongs to the same account as the subscription filter,
                *           for same-account delivery.</p>
                *             </li>
                *          </ul>
                *          <p>Each log group can have up to two subscription filters associated with it. If you are
                *       updating an existing filter, you must specify the correct name in <code>filterName</code>.
                *       </p>
                *          <p>To perform a <code>PutSubscriptionFilter</code> operation, you must also have the
                *       <code>iam:PassRole</code> permission.</p>
                */
            putSubscriptionFilter(args: PutSubscriptionFilterCommandInput, options?: __HttpHandlerOptions): Promise<PutSubscriptionFilterCommandOutput>;
            putSubscriptionFilter(args: PutSubscriptionFilterCommandInput, cb: (err: any, data?: PutSubscriptionFilterCommandOutput) => void): void;
            putSubscriptionFilter(args: PutSubscriptionFilterCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: PutSubscriptionFilterCommandOutput) => void): void;
            /**
                * <p>Schedules a query of a log group using CloudWatch Logs Insights. You specify the log group
                *       and time range to query and the query string to use.</p>
                *          <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CWL_QuerySyntax.html">CloudWatch Logs Insights Query Syntax</a>.</p>
                *
                *          <p>Queries time out after 15 minutes of execution. If your queries are timing out, reduce the
                *       time range being searched or partition your query into a number of queries.</p>
                */
            startQuery(args: StartQueryCommandInput, options?: __HttpHandlerOptions): Promise<StartQueryCommandOutput>;
            startQuery(args: StartQueryCommandInput, cb: (err: any, data?: StartQueryCommandOutput) => void): void;
            startQuery(args: StartQueryCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: StartQueryCommandOutput) => void): void;
            /**
                * <p>Stops a CloudWatch Logs Insights query that is in progress. If the query has already ended, the operation
                *     returns an error indicating that the specified query is not running.</p>
                */
            stopQuery(args: StopQueryCommandInput, options?: __HttpHandlerOptions): Promise<StopQueryCommandOutput>;
            stopQuery(args: StopQueryCommandInput, cb: (err: any, data?: StopQueryCommandOutput) => void): void;
            stopQuery(args: StopQueryCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: StopQueryCommandOutput) => void): void;
            /**
                * <p>Adds or updates the specified tags for the specified log group.</p>
                *          <p>To list the tags for a log group, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_ListTagsLogGroup.html">ListTagsLogGroup</a>.
                *       To remove tags, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_UntagLogGroup.html">UntagLogGroup</a>.</p>
                *          <p>For more information about tags, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html#log-group-tagging">Tag Log Groups in Amazon CloudWatch Logs</a>
                *       in the <i>Amazon CloudWatch Logs User Guide</i>.</p>
                *          <p>CloudWatch Logs doesnâ€™t support IAM policies that prevent users from assigning specified tags to
                *       log groups using the <code>aws:Resource/<i>key-name</i>
                *             </code> or <code>aws:TagKeys</code> condition keys.
                *       For more information about using tags to control access, see
                *       <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_tags.html">Controlling access to Amazon Web Services resources using tags</a>.</p>
                */
            tagLogGroup(args: TagLogGroupCommandInput, options?: __HttpHandlerOptions): Promise<TagLogGroupCommandOutput>;
            tagLogGroup(args: TagLogGroupCommandInput, cb: (err: any, data?: TagLogGroupCommandOutput) => void): void;
            tagLogGroup(args: TagLogGroupCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: TagLogGroupCommandOutput) => void): void;
            /**
                * <p>Tests the filter pattern of a metric filter against a sample of log event messages. You
                *       can use this operation to validate the correctness of a metric filter pattern.</p>
                */
            testMetricFilter(args: TestMetricFilterCommandInput, options?: __HttpHandlerOptions): Promise<TestMetricFilterCommandOutput>;
            testMetricFilter(args: TestMetricFilterCommandInput, cb: (err: any, data?: TestMetricFilterCommandOutput) => void): void;
            testMetricFilter(args: TestMetricFilterCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: TestMetricFilterCommandOutput) => void): void;
            /**
                * <p>Removes the specified tags from the specified log group.</p>
                *          <p>To list the tags for a log group, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_ListTagsLogGroup.html">ListTagsLogGroup</a>.
                *       To add tags, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_TagLogGroup.html">TagLogGroup</a>.</p>
                *          <p>CloudWatch Logs doesnâ€™t support IAM policies that prevent users from assigning specified tags to
                *       log groups using the <code>aws:Resource/<i>key-name</i>
                *             </code> or <code>aws:TagKeys</code> condition keys.
                *      </p>
                */
            untagLogGroup(args: UntagLogGroupCommandInput, options?: __HttpHandlerOptions): Promise<UntagLogGroupCommandOutput>;
            untagLogGroup(args: UntagLogGroupCommandInput, cb: (err: any, data?: UntagLogGroupCommandOutput) => void): void;
            untagLogGroup(args: UntagLogGroupCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UntagLogGroupCommandOutput) => void): void;
    }
}

declare module '@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/CloudWatchLogsClient' {
    import { EndpointsInputConfig, EndpointsResolvedConfig, RegionInputConfig, RegionResolvedConfig } from "@aws-sdk/config-resolver";
    import { HostHeaderInputConfig, HostHeaderResolvedConfig } from "@aws-sdk/middleware-host-header";
    import { RetryInputConfig, RetryResolvedConfig } from "@aws-sdk/middleware-retry";
    import { AwsAuthInputConfig, AwsAuthResolvedConfig } from "@aws-sdk/middleware-signing";
    import { UserAgentInputConfig, UserAgentResolvedConfig } from "@aws-sdk/middleware-user-agent";
    import { HttpHandler as __HttpHandler } from "@aws-sdk/protocol-http";
    import { Client as __Client, DefaultsMode, SmithyConfiguration as __SmithyConfiguration, SmithyResolvedConfiguration as __SmithyResolvedConfiguration } from "@aws-sdk/smithy-client";
    import { BodyLengthCalculator as __BodyLengthCalculator, Credentials as __Credentials, Decoder as __Decoder, Encoder as __Encoder, HashConstructor as __HashConstructor, HttpHandlerOptions as __HttpHandlerOptions, Logger as __Logger, Provider as __Provider, Provider, RegionInfoProvider, StreamCollector as __StreamCollector, UrlParser as __UrlParser, UserAgent as __UserAgent } from "@aws-sdk/types";
    import { AssociateKmsKeyCommandInput, AssociateKmsKeyCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/AssociateKmsKeyCommand";
    import { CancelExportTaskCommandInput, CancelExportTaskCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/CancelExportTaskCommand";
    import { CreateExportTaskCommandInput, CreateExportTaskCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/CreateExportTaskCommand";
    import { CreateLogGroupCommandInput, CreateLogGroupCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/CreateLogGroupCommand";
    import { CreateLogStreamCommandInput, CreateLogStreamCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/CreateLogStreamCommand";
    import { DeleteDestinationCommandInput, DeleteDestinationCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DeleteDestinationCommand";
    import { DeleteLogGroupCommandInput, DeleteLogGroupCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DeleteLogGroupCommand";
    import { DeleteLogStreamCommandInput, DeleteLogStreamCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DeleteLogStreamCommand";
    import { DeleteMetricFilterCommandInput, DeleteMetricFilterCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DeleteMetricFilterCommand";
    import { DeleteQueryDefinitionCommandInput, DeleteQueryDefinitionCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DeleteQueryDefinitionCommand";
    import { DeleteResourcePolicyCommandInput, DeleteResourcePolicyCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DeleteResourcePolicyCommand";
    import { DeleteRetentionPolicyCommandInput, DeleteRetentionPolicyCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DeleteRetentionPolicyCommand";
    import { DeleteSubscriptionFilterCommandInput, DeleteSubscriptionFilterCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DeleteSubscriptionFilterCommand";
    import { DescribeDestinationsCommandInput, DescribeDestinationsCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DescribeDestinationsCommand";
    import { DescribeExportTasksCommandInput, DescribeExportTasksCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DescribeExportTasksCommand";
    import { DescribeLogGroupsCommandInput, DescribeLogGroupsCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DescribeLogGroupsCommand";
    import { DescribeLogStreamsCommandInput, DescribeLogStreamsCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DescribeLogStreamsCommand";
    import { DescribeMetricFiltersCommandInput, DescribeMetricFiltersCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DescribeMetricFiltersCommand";
    import { DescribeQueriesCommandInput, DescribeQueriesCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DescribeQueriesCommand";
    import { DescribeQueryDefinitionsCommandInput, DescribeQueryDefinitionsCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DescribeQueryDefinitionsCommand";
    import { DescribeResourcePoliciesCommandInput, DescribeResourcePoliciesCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DescribeResourcePoliciesCommand";
    import { DescribeSubscriptionFiltersCommandInput, DescribeSubscriptionFiltersCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DescribeSubscriptionFiltersCommand";
    import { DisassociateKmsKeyCommandInput, DisassociateKmsKeyCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DisassociateKmsKeyCommand";
    import { FilterLogEventsCommandInput, FilterLogEventsCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/FilterLogEventsCommand";
    import { GetLogEventsCommandInput, GetLogEventsCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/GetLogEventsCommand";
    import { GetLogGroupFieldsCommandInput, GetLogGroupFieldsCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/GetLogGroupFieldsCommand";
    import { GetLogRecordCommandInput, GetLogRecordCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/GetLogRecordCommand";
    import { GetQueryResultsCommandInput, GetQueryResultsCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/GetQueryResultsCommand";
    import { ListTagsLogGroupCommandInput, ListTagsLogGroupCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/ListTagsLogGroupCommand";
    import { PutDestinationCommandInput, PutDestinationCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/PutDestinationCommand";
    import { PutDestinationPolicyCommandInput, PutDestinationPolicyCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/PutDestinationPolicyCommand";
    import { PutLogEventsCommandInput, PutLogEventsCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/PutLogEventsCommand";
    import { PutMetricFilterCommandInput, PutMetricFilterCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/PutMetricFilterCommand";
    import { PutQueryDefinitionCommandInput, PutQueryDefinitionCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/PutQueryDefinitionCommand";
    import { PutResourcePolicyCommandInput, PutResourcePolicyCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/PutResourcePolicyCommand";
    import { PutRetentionPolicyCommandInput, PutRetentionPolicyCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/PutRetentionPolicyCommand";
    import { PutSubscriptionFilterCommandInput, PutSubscriptionFilterCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/PutSubscriptionFilterCommand";
    import { StartQueryCommandInput, StartQueryCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/StartQueryCommand";
    import { StopQueryCommandInput, StopQueryCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/StopQueryCommand";
    import { TagLogGroupCommandInput, TagLogGroupCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/TagLogGroupCommand";
    import { TestMetricFilterCommandInput, TestMetricFilterCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/TestMetricFilterCommand";
    import { UntagLogGroupCommandInput, UntagLogGroupCommandOutput } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/UntagLogGroupCommand";
    export type ServiceInputTypes = AssociateKmsKeyCommandInput | CancelExportTaskCommandInput | CreateExportTaskCommandInput | CreateLogGroupCommandInput | CreateLogStreamCommandInput | DeleteDestinationCommandInput | DeleteLogGroupCommandInput | DeleteLogStreamCommandInput | DeleteMetricFilterCommandInput | DeleteQueryDefinitionCommandInput | DeleteResourcePolicyCommandInput | DeleteRetentionPolicyCommandInput | DeleteSubscriptionFilterCommandInput | DescribeDestinationsCommandInput | DescribeExportTasksCommandInput | DescribeLogGroupsCommandInput | DescribeLogStreamsCommandInput | DescribeMetricFiltersCommandInput | DescribeQueriesCommandInput | DescribeQueryDefinitionsCommandInput | DescribeResourcePoliciesCommandInput | DescribeSubscriptionFiltersCommandInput | DisassociateKmsKeyCommandInput | FilterLogEventsCommandInput | GetLogEventsCommandInput | GetLogGroupFieldsCommandInput | GetLogRecordCommandInput | GetQueryResultsCommandInput | ListTagsLogGroupCommandInput | PutDestinationCommandInput | PutDestinationPolicyCommandInput | PutLogEventsCommandInput | PutMetricFilterCommandInput | PutQueryDefinitionCommandInput | PutResourcePolicyCommandInput | PutRetentionPolicyCommandInput | PutSubscriptionFilterCommandInput | StartQueryCommandInput | StopQueryCommandInput | TagLogGroupCommandInput | TestMetricFilterCommandInput | UntagLogGroupCommandInput;
    export type ServiceOutputTypes = AssociateKmsKeyCommandOutput | CancelExportTaskCommandOutput | CreateExportTaskCommandOutput | CreateLogGroupCommandOutput | CreateLogStreamCommandOutput | DeleteDestinationCommandOutput | DeleteLogGroupCommandOutput | DeleteLogStreamCommandOutput | DeleteMetricFilterCommandOutput | DeleteQueryDefinitionCommandOutput | DeleteResourcePolicyCommandOutput | DeleteRetentionPolicyCommandOutput | DeleteSubscriptionFilterCommandOutput | DescribeDestinationsCommandOutput | DescribeExportTasksCommandOutput | DescribeLogGroupsCommandOutput | DescribeLogStreamsCommandOutput | DescribeMetricFiltersCommandOutput | DescribeQueriesCommandOutput | DescribeQueryDefinitionsCommandOutput | DescribeResourcePoliciesCommandOutput | DescribeSubscriptionFiltersCommandOutput | DisassociateKmsKeyCommandOutput | FilterLogEventsCommandOutput | GetLogEventsCommandOutput | GetLogGroupFieldsCommandOutput | GetLogRecordCommandOutput | GetQueryResultsCommandOutput | ListTagsLogGroupCommandOutput | PutDestinationCommandOutput | PutDestinationPolicyCommandOutput | PutLogEventsCommandOutput | PutMetricFilterCommandOutput | PutQueryDefinitionCommandOutput | PutResourcePolicyCommandOutput | PutRetentionPolicyCommandOutput | PutSubscriptionFilterCommandOutput | StartQueryCommandOutput | StopQueryCommandOutput | TagLogGroupCommandOutput | TestMetricFilterCommandOutput | UntagLogGroupCommandOutput;
    export interface ClientDefaults extends Partial<__SmithyResolvedConfiguration<__HttpHandlerOptions>> {
            /**
                * The HTTP handler to use. Fetch in browser and Https in Nodejs.
                */
            requestHandler?: __HttpHandler;
            /**
                * A constructor for a class implementing the {@link __Hash} interface
                * that computes the SHA-256 HMAC or checksum of a string or binary buffer.
                * @internal
                */
            sha256?: __HashConstructor;
            /**
                * The function that will be used to convert strings into HTTP endpoints.
                * @internal
                */
            urlParser?: __UrlParser;
            /**
                * A function that can calculate the length of a request body.
                * @internal
                */
            bodyLengthChecker?: __BodyLengthCalculator;
            /**
                * A function that converts a stream into an array of bytes.
                * @internal
                */
            streamCollector?: __StreamCollector;
            /**
                * The function that will be used to convert a base64-encoded string to a byte array.
                * @internal
                */
            base64Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a base64-encoded string.
                * @internal
                */
            base64Encoder?: __Encoder;
            /**
                * The function that will be used to convert a UTF8-encoded string to a byte array.
                * @internal
                */
            utf8Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a UTF-8 encoded string.
                * @internal
                */
            utf8Encoder?: __Encoder;
            /**
                * The runtime environment.
                * @internal
                */
            runtime?: string;
            /**
                * Disable dyanamically changing the endpoint of the client based on the hostPrefix
                * trait of an operation.
                */
            disableHostPrefix?: boolean;
            /**
                * Value for how many times a request will be made at most in case of retry.
                */
            maxAttempts?: number | __Provider<number>;
            /**
                * Specifies which retry algorithm to use.
                */
            retryMode?: string | __Provider<string>;
            /**
                * Optional logger for logging debug/info/warn/error.
                */
            logger?: __Logger;
            /**
                * Enables IPv6/IPv4 dualstack endpoint.
                */
            useDualstackEndpoint?: boolean | __Provider<boolean>;
            /**
                * Enables FIPS compatible endpoints.
                */
            useFipsEndpoint?: boolean | __Provider<boolean>;
            /**
                * Unique service identifier.
                * @internal
                */
            serviceId?: string;
            /**
                * The AWS region to which this client will send requests
                */
            region?: string | __Provider<string>;
            /**
                * Default credentials provider; Not available in browser runtime.
                * @internal
                */
            credentialDefaultProvider?: (input: any) => __Provider<__Credentials>;
            /**
                * Fetch related hostname, signing name or signing region with given region.
                * @internal
                */
            regionInfoProvider?: RegionInfoProvider;
            /**
                * The provider populating default tracking information to be sent with `user-agent`, `x-amz-user-agent` header
                * @internal
                */
            defaultUserAgentProvider?: Provider<__UserAgent>;
            /**
                * The {@link DefaultsMode} that will be used to determine how certain default configuration options are resolved in the SDK.
                */
            defaultsMode?: DefaultsMode | Provider<DefaultsMode>;
    }
    type CloudWatchLogsClientConfigType = Partial<__SmithyConfiguration<__HttpHandlerOptions>> & ClientDefaults & RegionInputConfig & EndpointsInputConfig & RetryInputConfig & HostHeaderInputConfig & AwsAuthInputConfig & UserAgentInputConfig;
    /**
        * The configuration interface of CloudWatchLogsClient class constructor that set the region, credentials and other options.
        */
    export interface CloudWatchLogsClientConfig extends CloudWatchLogsClientConfigType {
    }
    type CloudWatchLogsClientResolvedConfigType = __SmithyResolvedConfiguration<__HttpHandlerOptions> & Required<ClientDefaults> & RegionResolvedConfig & EndpointsResolvedConfig & RetryResolvedConfig & HostHeaderResolvedConfig & AwsAuthResolvedConfig & UserAgentResolvedConfig;
    /**
        * The resolved configuration interface of CloudWatchLogsClient class. This is resolved and normalized from the {@link CloudWatchLogsClientConfig | constructor configuration interface}.
        */
    export interface CloudWatchLogsClientResolvedConfig extends CloudWatchLogsClientResolvedConfigType {
    }
    /**
        * <p>You can use Amazon CloudWatch Logs to monitor, store, and access your log files from
        *       EC2 instances, CloudTrail, and other sources. You can then retrieve the associated
        *       log data from CloudWatch Logs using the CloudWatch console, CloudWatch Logs commands in the
        *       Amazon Web Services CLI, CloudWatch Logs API, or CloudWatch Logs SDK.</p>
        *          <p>You can use CloudWatch Logs to:</p>
        *          <ul>
        *             <li>
        *                <p>
        *                   <b>Monitor logs from EC2 instances in real-time</b>: You
        *           can use CloudWatch Logs to monitor applications and systems using log data. For example,
        *           CloudWatch Logs can track the number of errors that occur in your application logs and
        *           send you a notification whenever the rate of errors exceeds a threshold that you specify.
        *           CloudWatch Logs uses your log data for monitoring so no code changes are required. For
        *           example, you can monitor application logs for specific literal terms (such as
        *           "NullReferenceException") or count the number of occurrences of a literal term at a
        *           particular position in log data (such as "404" status codes in an Apache access log). When
        *           the term you are searching for is found, CloudWatch Logs reports the data to a CloudWatch
        *           metric that you specify.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <b>Monitor CloudTrail logged events</b>: You can
        *           create alarms in CloudWatch and receive notifications of particular API activity as
        *           captured by CloudTrail. You can use the notification to perform troubleshooting.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <b>Archive log data</b>: You can use CloudWatch Logs to
        *           store your log data in highly durable storage. You can change the log retention setting so
        *           that any log events older than this setting are automatically deleted. The CloudWatch Logs
        *           agent makes it easy to quickly send both rotated and non-rotated log data off of a host
        *           and into the log service. You can then access the raw log data when you need it.</p>
        *             </li>
        *          </ul>
        */
    export class CloudWatchLogsClient extends __Client<__HttpHandlerOptions, ServiceInputTypes, ServiceOutputTypes, CloudWatchLogsClientResolvedConfig> {
            /**
                * The resolved configuration of CloudWatchLogsClient class. This is resolved and normalized from the {@link CloudWatchLogsClientConfig | constructor configuration interface}.
                */
            readonly config: CloudWatchLogsClientResolvedConfig;
            constructor(configuration: CloudWatchLogsClientConfig);
            /**
                * Destroy underlying resources, like sockets. It's usually not necessary to do this.
                * However in Node.js, it's best to explicitly shut down the client's agent when it is no longer needed.
                * Otherwise, sockets might stay open for quite a long time before the server terminates them.
                */
            destroy(): void;
    }
    export {};
}

declare module '@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/AssociateKmsKeyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudWatchLogsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/CloudWatchLogsClient";
    import { AssociateKmsKeyRequest } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/models/models_0";
    export interface AssociateKmsKeyCommandInput extends AssociateKmsKeyRequest {
    }
    export interface AssociateKmsKeyCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Associates the specified Key Management Service customer master key (CMK) with the specified log group.</p>
        *          <p>Associating an KMS CMK with a log group overrides any existing associations between the log group and a CMK.
        *       After a CMK is associated with a log group, all newly ingested data for the log group is encrypted using the CMK.
        *       This association is stored as long as the data encrypted with the CMK is still within CloudWatch Logs.
        *       This enables CloudWatch Logs to decrypt this data whenever it is requested.</p>
        *          <important>
        *             <p>CloudWatch Logs supports only symmetric CMKs. Do not use an associate an asymmetric CMK
        *         with your log group. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html">Using Symmetric and Asymmetric
        *           Keys</a>.</p>
        *          </important>
        *          <p>It can take up to 5 minutes for this operation to take effect.</p>
        *          <p>If you attempt to associate a CMK with a log group but the CMK does not exist or the
        *       CMK is disabled, you receive an <code>InvalidParameterException</code> error. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudWatchLogsClient, AssociateKmsKeyCommand } from "@aws-sdk/client-cloudwatch-logs"; // ES Modules import
        * // const { CloudWatchLogsClient, AssociateKmsKeyCommand } = require("@aws-sdk/client-cloudwatch-logs"); // CommonJS import
        * const client = new CloudWatchLogsClient(config);
        * const command = new AssociateKmsKeyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link AssociateKmsKeyCommandInput} for command's `input` shape.
        * @see {@link AssociateKmsKeyCommandOutput} for command's `response` shape.
        * @see {@link CloudWatchLogsClientResolvedConfig | config} for CloudWatchLogsClient's `config` shape.
        *
        */
    export class AssociateKmsKeyCommand extends $Command<AssociateKmsKeyCommandInput, AssociateKmsKeyCommandOutput, CloudWatchLogsClientResolvedConfig> {
            readonly input: AssociateKmsKeyCommandInput;
            constructor(input: AssociateKmsKeyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudWatchLogsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<AssociateKmsKeyCommandInput, AssociateKmsKeyCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/CancelExportTaskCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudWatchLogsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/CloudWatchLogsClient";
    import { CancelExportTaskRequest } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/models/models_0";
    export interface CancelExportTaskCommandInput extends CancelExportTaskRequest {
    }
    export interface CancelExportTaskCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Cancels the specified export task.</p>
        *          <p>The task must be in the <code>PENDING</code> or <code>RUNNING</code> state.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudWatchLogsClient, CancelExportTaskCommand } from "@aws-sdk/client-cloudwatch-logs"; // ES Modules import
        * // const { CloudWatchLogsClient, CancelExportTaskCommand } = require("@aws-sdk/client-cloudwatch-logs"); // CommonJS import
        * const client = new CloudWatchLogsClient(config);
        * const command = new CancelExportTaskCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CancelExportTaskCommandInput} for command's `input` shape.
        * @see {@link CancelExportTaskCommandOutput} for command's `response` shape.
        * @see {@link CloudWatchLogsClientResolvedConfig | config} for CloudWatchLogsClient's `config` shape.
        *
        */
    export class CancelExportTaskCommand extends $Command<CancelExportTaskCommandInput, CancelExportTaskCommandOutput, CloudWatchLogsClientResolvedConfig> {
            readonly input: CancelExportTaskCommandInput;
            constructor(input: CancelExportTaskCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudWatchLogsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CancelExportTaskCommandInput, CancelExportTaskCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/CreateExportTaskCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudWatchLogsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/CloudWatchLogsClient";
    import { CreateExportTaskRequest, CreateExportTaskResponse } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/models/models_0";
    export interface CreateExportTaskCommandInput extends CreateExportTaskRequest {
    }
    export interface CreateExportTaskCommandOutput extends CreateExportTaskResponse, __MetadataBearer {
    }
    /**
        * <p>Creates an export task, which allows you to efficiently export data from a
        *       log group to an Amazon S3 bucket. When you perform a <code>CreateExportTask</code>
        *       operation, you must use credentials that have permission to write to the S3 bucket
        *       that you specify as the destination.</p>
        *          <important>
        *             <p>Exporting log data to Amazon S3 buckets that are encrypted by KMS is not
        *       supported. Exporting
        *       log data to Amazon S3 buckets that have S3 Object Lock enabled with a retention period is not supported.</p>
        *             <p>Exporting to S3 buckets that are encrypted with AES-256 is supported. </p>
        *          </important>
        *          <p>This is an asynchronous call. If all the required information is provided, this
        *       operation initiates an export task and responds with the ID of the task. After the task has started,
        *       you can use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DescribeExportTasks.html">DescribeExportTasks</a> to get the status of the export task. Each account can
        *       only have one active (<code>RUNNING</code> or <code>PENDING</code>) export task at a time.
        *       To cancel an export task, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_CancelExportTask.html">CancelExportTask</a>.</p>
        *          <p>You can export logs from multiple log groups or multiple time ranges to the same S3
        *       bucket. To separate out log data for each export task, you can specify a prefix to be used as
        *       the Amazon S3 key prefix for all exported objects.</p>
        *
        *          <note>
        *             <p>Time-based sorting on chunks of log data inside an exported file is not guaranteed. You can sort the
        *       exported log fild data by using Linux utilities.</p>
        *          </note>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudWatchLogsClient, CreateExportTaskCommand } from "@aws-sdk/client-cloudwatch-logs"; // ES Modules import
        * // const { CloudWatchLogsClient, CreateExportTaskCommand } = require("@aws-sdk/client-cloudwatch-logs"); // CommonJS import
        * const client = new CloudWatchLogsClient(config);
        * const command = new CreateExportTaskCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateExportTaskCommandInput} for command's `input` shape.
        * @see {@link CreateExportTaskCommandOutput} for command's `response` shape.
        * @see {@link CloudWatchLogsClientResolvedConfig | config} for CloudWatchLogsClient's `config` shape.
        *
        */
    export class CreateExportTaskCommand extends $Command<CreateExportTaskCommandInput, CreateExportTaskCommandOutput, CloudWatchLogsClientResolvedConfig> {
            readonly input: CreateExportTaskCommandInput;
            constructor(input: CreateExportTaskCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudWatchLogsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateExportTaskCommandInput, CreateExportTaskCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/CreateLogGroupCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudWatchLogsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/CloudWatchLogsClient";
    import { CreateLogGroupRequest } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/models/models_0";
    export interface CreateLogGroupCommandInput extends CreateLogGroupRequest {
    }
    export interface CreateLogGroupCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Creates a log group with the specified name. You can create up to 20,000 log groups per account.</p>
        *          <p>You must use the following guidelines when naming a log group:</p>
        *          <ul>
        *             <li>
        *                <p>Log group names must be unique within a region for an Amazon Web Services account.</p>
        *             </li>
        *             <li>
        *                <p>Log group names can be between 1 and 512 characters long.</p>
        *             </li>
        *             <li>
        *                <p>Log group names consist of the following characters: a-z, A-Z, 0-9, '_' (underscore), '-' (hyphen),
        *           '/' (forward slash), '.' (period), and '#' (number sign)</p>
        *             </li>
        *          </ul>
        *          <p>When you create a log group, by default the log events in the log group never expire. To set
        *     a retention policy so that events expire and are deleted after a specified time, use
        *       <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutRetentionPolicy.html">PutRetentionPolicy</a>.</p>
        *          <p>If you associate a Key Management Service customer master key (CMK) with the log group, ingested data is encrypted using the CMK.
        *       This association is stored as long as the data encrypted with the CMK is still within CloudWatch Logs.
        *       This enables CloudWatch Logs to decrypt this data whenever it is requested.</p>
        *          <p>If you attempt to associate a CMK with the log group but the CMK does not exist or the
        *       CMK is disabled, you receive an <code>InvalidParameterException</code> error. </p>
        *          <important>
        *             <p>CloudWatch Logs supports only symmetric CMKs. Do not associate an asymmetric CMK with
        *         your log group. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html">Using Symmetric and Asymmetric
        *           Keys</a>.</p>
        *          </important>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudWatchLogsClient, CreateLogGroupCommand } from "@aws-sdk/client-cloudwatch-logs"; // ES Modules import
        * // const { CloudWatchLogsClient, CreateLogGroupCommand } = require("@aws-sdk/client-cloudwatch-logs"); // CommonJS import
        * const client = new CloudWatchLogsClient(config);
        * const command = new CreateLogGroupCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateLogGroupCommandInput} for command's `input` shape.
        * @see {@link CreateLogGroupCommandOutput} for command's `response` shape.
        * @see {@link CloudWatchLogsClientResolvedConfig | config} for CloudWatchLogsClient's `config` shape.
        *
        */
    export class CreateLogGroupCommand extends $Command<CreateLogGroupCommandInput, CreateLogGroupCommandOutput, CloudWatchLogsClientResolvedConfig> {
            readonly input: CreateLogGroupCommandInput;
            constructor(input: CreateLogGroupCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudWatchLogsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateLogGroupCommandInput, CreateLogGroupCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/CreateLogStreamCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudWatchLogsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/CloudWatchLogsClient";
    import { CreateLogStreamRequest } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/models/models_0";
    export interface CreateLogStreamCommandInput extends CreateLogStreamRequest {
    }
    export interface CreateLogStreamCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Creates a log stream for the specified log group. A log stream is a sequence of log events
        *       that originate from a single source, such as an application instance or a resource that is
        *       being monitored.</p>
        *          <p>There is no limit on the number of log streams that you can create for a log group. There is a limit
        *     of 50 TPS on <code>CreateLogStream</code> operations, after which transactions are throttled.</p>
        *          <p>You must use the following guidelines when naming a log stream:</p>
        *          <ul>
        *             <li>
        *                <p>Log stream names must be unique within the log group.</p>
        *             </li>
        *             <li>
        *                <p>Log stream names can be between 1 and 512 characters long.</p>
        *             </li>
        *             <li>
        *                <p>The ':' (colon) and '*' (asterisk) characters are not allowed.</p>
        *             </li>
        *          </ul>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudWatchLogsClient, CreateLogStreamCommand } from "@aws-sdk/client-cloudwatch-logs"; // ES Modules import
        * // const { CloudWatchLogsClient, CreateLogStreamCommand } = require("@aws-sdk/client-cloudwatch-logs"); // CommonJS import
        * const client = new CloudWatchLogsClient(config);
        * const command = new CreateLogStreamCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateLogStreamCommandInput} for command's `input` shape.
        * @see {@link CreateLogStreamCommandOutput} for command's `response` shape.
        * @see {@link CloudWatchLogsClientResolvedConfig | config} for CloudWatchLogsClient's `config` shape.
        *
        */
    export class CreateLogStreamCommand extends $Command<CreateLogStreamCommandInput, CreateLogStreamCommandOutput, CloudWatchLogsClientResolvedConfig> {
            readonly input: CreateLogStreamCommandInput;
            constructor(input: CreateLogStreamCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudWatchLogsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateLogStreamCommandInput, CreateLogStreamCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DeleteDestinationCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudWatchLogsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/CloudWatchLogsClient";
    import { DeleteDestinationRequest } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/models/models_0";
    export interface DeleteDestinationCommandInput extends DeleteDestinationRequest {
    }
    export interface DeleteDestinationCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Deletes the specified destination, and eventually disables all the
        *       subscription filters that publish to it. This operation does not delete the
        *       physical resource encapsulated by the destination.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudWatchLogsClient, DeleteDestinationCommand } from "@aws-sdk/client-cloudwatch-logs"; // ES Modules import
        * // const { CloudWatchLogsClient, DeleteDestinationCommand } = require("@aws-sdk/client-cloudwatch-logs"); // CommonJS import
        * const client = new CloudWatchLogsClient(config);
        * const command = new DeleteDestinationCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteDestinationCommandInput} for command's `input` shape.
        * @see {@link DeleteDestinationCommandOutput} for command's `response` shape.
        * @see {@link CloudWatchLogsClientResolvedConfig | config} for CloudWatchLogsClient's `config` shape.
        *
        */
    export class DeleteDestinationCommand extends $Command<DeleteDestinationCommandInput, DeleteDestinationCommandOutput, CloudWatchLogsClientResolvedConfig> {
            readonly input: DeleteDestinationCommandInput;
            constructor(input: DeleteDestinationCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudWatchLogsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteDestinationCommandInput, DeleteDestinationCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DeleteLogGroupCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudWatchLogsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/CloudWatchLogsClient";
    import { DeleteLogGroupRequest } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/models/models_0";
    export interface DeleteLogGroupCommandInput extends DeleteLogGroupRequest {
    }
    export interface DeleteLogGroupCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Deletes the specified log group and permanently deletes all the archived
        *       log events associated with the log group.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudWatchLogsClient, DeleteLogGroupCommand } from "@aws-sdk/client-cloudwatch-logs"; // ES Modules import
        * // const { CloudWatchLogsClient, DeleteLogGroupCommand } = require("@aws-sdk/client-cloudwatch-logs"); // CommonJS import
        * const client = new CloudWatchLogsClient(config);
        * const command = new DeleteLogGroupCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteLogGroupCommandInput} for command's `input` shape.
        * @see {@link DeleteLogGroupCommandOutput} for command's `response` shape.
        * @see {@link CloudWatchLogsClientResolvedConfig | config} for CloudWatchLogsClient's `config` shape.
        *
        */
    export class DeleteLogGroupCommand extends $Command<DeleteLogGroupCommandInput, DeleteLogGroupCommandOutput, CloudWatchLogsClientResolvedConfig> {
            readonly input: DeleteLogGroupCommandInput;
            constructor(input: DeleteLogGroupCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudWatchLogsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteLogGroupCommandInput, DeleteLogGroupCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DeleteLogStreamCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudWatchLogsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/CloudWatchLogsClient";
    import { DeleteLogStreamRequest } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/models/models_0";
    export interface DeleteLogStreamCommandInput extends DeleteLogStreamRequest {
    }
    export interface DeleteLogStreamCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Deletes the specified log stream and permanently deletes all the archived log events associated
        *       with the log stream.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudWatchLogsClient, DeleteLogStreamCommand } from "@aws-sdk/client-cloudwatch-logs"; // ES Modules import
        * // const { CloudWatchLogsClient, DeleteLogStreamCommand } = require("@aws-sdk/client-cloudwatch-logs"); // CommonJS import
        * const client = new CloudWatchLogsClient(config);
        * const command = new DeleteLogStreamCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteLogStreamCommandInput} for command's `input` shape.
        * @see {@link DeleteLogStreamCommandOutput} for command's `response` shape.
        * @see {@link CloudWatchLogsClientResolvedConfig | config} for CloudWatchLogsClient's `config` shape.
        *
        */
    export class DeleteLogStreamCommand extends $Command<DeleteLogStreamCommandInput, DeleteLogStreamCommandOutput, CloudWatchLogsClientResolvedConfig> {
            readonly input: DeleteLogStreamCommandInput;
            constructor(input: DeleteLogStreamCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudWatchLogsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteLogStreamCommandInput, DeleteLogStreamCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DeleteMetricFilterCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudWatchLogsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/CloudWatchLogsClient";
    import { DeleteMetricFilterRequest } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/models/models_0";
    export interface DeleteMetricFilterCommandInput extends DeleteMetricFilterRequest {
    }
    export interface DeleteMetricFilterCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Deletes the specified metric filter.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudWatchLogsClient, DeleteMetricFilterCommand } from "@aws-sdk/client-cloudwatch-logs"; // ES Modules import
        * // const { CloudWatchLogsClient, DeleteMetricFilterCommand } = require("@aws-sdk/client-cloudwatch-logs"); // CommonJS import
        * const client = new CloudWatchLogsClient(config);
        * const command = new DeleteMetricFilterCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteMetricFilterCommandInput} for command's `input` shape.
        * @see {@link DeleteMetricFilterCommandOutput} for command's `response` shape.
        * @see {@link CloudWatchLogsClientResolvedConfig | config} for CloudWatchLogsClient's `config` shape.
        *
        */
    export class DeleteMetricFilterCommand extends $Command<DeleteMetricFilterCommandInput, DeleteMetricFilterCommandOutput, CloudWatchLogsClientResolvedConfig> {
            readonly input: DeleteMetricFilterCommandInput;
            constructor(input: DeleteMetricFilterCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudWatchLogsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteMetricFilterCommandInput, DeleteMetricFilterCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DeleteQueryDefinitionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudWatchLogsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/CloudWatchLogsClient";
    import { DeleteQueryDefinitionRequest, DeleteQueryDefinitionResponse } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/models/models_0";
    export interface DeleteQueryDefinitionCommandInput extends DeleteQueryDefinitionRequest {
    }
    export interface DeleteQueryDefinitionCommandOutput extends DeleteQueryDefinitionResponse, __MetadataBearer {
    }
    /**
        * <p>Deletes a saved CloudWatch Logs Insights query definition.
        *       A query definition contains details about a saved CloudWatch Logs Insights query.</p>
        *          <p>Each <code>DeleteQueryDefinition</code> operation can delete one query definition.</p>
        *          <p>You must have the <code>logs:DeleteQueryDefinition</code> permission to be able to perform
        *       this operation.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudWatchLogsClient, DeleteQueryDefinitionCommand } from "@aws-sdk/client-cloudwatch-logs"; // ES Modules import
        * // const { CloudWatchLogsClient, DeleteQueryDefinitionCommand } = require("@aws-sdk/client-cloudwatch-logs"); // CommonJS import
        * const client = new CloudWatchLogsClient(config);
        * const command = new DeleteQueryDefinitionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteQueryDefinitionCommandInput} for command's `input` shape.
        * @see {@link DeleteQueryDefinitionCommandOutput} for command's `response` shape.
        * @see {@link CloudWatchLogsClientResolvedConfig | config} for CloudWatchLogsClient's `config` shape.
        *
        */
    export class DeleteQueryDefinitionCommand extends $Command<DeleteQueryDefinitionCommandInput, DeleteQueryDefinitionCommandOutput, CloudWatchLogsClientResolvedConfig> {
            readonly input: DeleteQueryDefinitionCommandInput;
            constructor(input: DeleteQueryDefinitionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudWatchLogsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteQueryDefinitionCommandInput, DeleteQueryDefinitionCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DeleteResourcePolicyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudWatchLogsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/CloudWatchLogsClient";
    import { DeleteResourcePolicyRequest } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/models/models_0";
    export interface DeleteResourcePolicyCommandInput extends DeleteResourcePolicyRequest {
    }
    export interface DeleteResourcePolicyCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Deletes a resource policy from this account. This revokes
        *     the access of the identities in that policy to put log events to this account.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudWatchLogsClient, DeleteResourcePolicyCommand } from "@aws-sdk/client-cloudwatch-logs"; // ES Modules import
        * // const { CloudWatchLogsClient, DeleteResourcePolicyCommand } = require("@aws-sdk/client-cloudwatch-logs"); // CommonJS import
        * const client = new CloudWatchLogsClient(config);
        * const command = new DeleteResourcePolicyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteResourcePolicyCommandInput} for command's `input` shape.
        * @see {@link DeleteResourcePolicyCommandOutput} for command's `response` shape.
        * @see {@link CloudWatchLogsClientResolvedConfig | config} for CloudWatchLogsClient's `config` shape.
        *
        */
    export class DeleteResourcePolicyCommand extends $Command<DeleteResourcePolicyCommandInput, DeleteResourcePolicyCommandOutput, CloudWatchLogsClientResolvedConfig> {
            readonly input: DeleteResourcePolicyCommandInput;
            constructor(input: DeleteResourcePolicyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudWatchLogsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteResourcePolicyCommandInput, DeleteResourcePolicyCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DeleteRetentionPolicyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudWatchLogsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/CloudWatchLogsClient";
    import { DeleteRetentionPolicyRequest } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/models/models_0";
    export interface DeleteRetentionPolicyCommandInput extends DeleteRetentionPolicyRequest {
    }
    export interface DeleteRetentionPolicyCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Deletes the specified retention policy.</p>
        *          <p>Log events do not expire if they belong to log groups without a retention policy.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudWatchLogsClient, DeleteRetentionPolicyCommand } from "@aws-sdk/client-cloudwatch-logs"; // ES Modules import
        * // const { CloudWatchLogsClient, DeleteRetentionPolicyCommand } = require("@aws-sdk/client-cloudwatch-logs"); // CommonJS import
        * const client = new CloudWatchLogsClient(config);
        * const command = new DeleteRetentionPolicyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteRetentionPolicyCommandInput} for command's `input` shape.
        * @see {@link DeleteRetentionPolicyCommandOutput} for command's `response` shape.
        * @see {@link CloudWatchLogsClientResolvedConfig | config} for CloudWatchLogsClient's `config` shape.
        *
        */
    export class DeleteRetentionPolicyCommand extends $Command<DeleteRetentionPolicyCommandInput, DeleteRetentionPolicyCommandOutput, CloudWatchLogsClientResolvedConfig> {
            readonly input: DeleteRetentionPolicyCommandInput;
            constructor(input: DeleteRetentionPolicyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudWatchLogsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteRetentionPolicyCommandInput, DeleteRetentionPolicyCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DeleteSubscriptionFilterCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudWatchLogsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/CloudWatchLogsClient";
    import { DeleteSubscriptionFilterRequest } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/models/models_0";
    export interface DeleteSubscriptionFilterCommandInput extends DeleteSubscriptionFilterRequest {
    }
    export interface DeleteSubscriptionFilterCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Deletes the specified subscription filter.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudWatchLogsClient, DeleteSubscriptionFilterCommand } from "@aws-sdk/client-cloudwatch-logs"; // ES Modules import
        * // const { CloudWatchLogsClient, DeleteSubscriptionFilterCommand } = require("@aws-sdk/client-cloudwatch-logs"); // CommonJS import
        * const client = new CloudWatchLogsClient(config);
        * const command = new DeleteSubscriptionFilterCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteSubscriptionFilterCommandInput} for command's `input` shape.
        * @see {@link DeleteSubscriptionFilterCommandOutput} for command's `response` shape.
        * @see {@link CloudWatchLogsClientResolvedConfig | config} for CloudWatchLogsClient's `config` shape.
        *
        */
    export class DeleteSubscriptionFilterCommand extends $Command<DeleteSubscriptionFilterCommandInput, DeleteSubscriptionFilterCommandOutput, CloudWatchLogsClientResolvedConfig> {
            readonly input: DeleteSubscriptionFilterCommandInput;
            constructor(input: DeleteSubscriptionFilterCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudWatchLogsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteSubscriptionFilterCommandInput, DeleteSubscriptionFilterCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DescribeDestinationsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudWatchLogsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/CloudWatchLogsClient";
    import { DescribeDestinationsRequest, DescribeDestinationsResponse } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/models/models_0";
    export interface DescribeDestinationsCommandInput extends DescribeDestinationsRequest {
    }
    export interface DescribeDestinationsCommandOutput extends DescribeDestinationsResponse, __MetadataBearer {
    }
    /**
        * <p>Lists all your destinations. The results are ASCII-sorted by destination name.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudWatchLogsClient, DescribeDestinationsCommand } from "@aws-sdk/client-cloudwatch-logs"; // ES Modules import
        * // const { CloudWatchLogsClient, DescribeDestinationsCommand } = require("@aws-sdk/client-cloudwatch-logs"); // CommonJS import
        * const client = new CloudWatchLogsClient(config);
        * const command = new DescribeDestinationsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeDestinationsCommandInput} for command's `input` shape.
        * @see {@link DescribeDestinationsCommandOutput} for command's `response` shape.
        * @see {@link CloudWatchLogsClientResolvedConfig | config} for CloudWatchLogsClient's `config` shape.
        *
        */
    export class DescribeDestinationsCommand extends $Command<DescribeDestinationsCommandInput, DescribeDestinationsCommandOutput, CloudWatchLogsClientResolvedConfig> {
            readonly input: DescribeDestinationsCommandInput;
            constructor(input: DescribeDestinationsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudWatchLogsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeDestinationsCommandInput, DescribeDestinationsCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DescribeExportTasksCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudWatchLogsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/CloudWatchLogsClient";
    import { DescribeExportTasksRequest, DescribeExportTasksResponse } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/models/models_0";
    export interface DescribeExportTasksCommandInput extends DescribeExportTasksRequest {
    }
    export interface DescribeExportTasksCommandOutput extends DescribeExportTasksResponse, __MetadataBearer {
    }
    /**
        * <p>Lists the specified export tasks. You can list all your export tasks or filter
        *       the results based on task ID or task status.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudWatchLogsClient, DescribeExportTasksCommand } from "@aws-sdk/client-cloudwatch-logs"; // ES Modules import
        * // const { CloudWatchLogsClient, DescribeExportTasksCommand } = require("@aws-sdk/client-cloudwatch-logs"); // CommonJS import
        * const client = new CloudWatchLogsClient(config);
        * const command = new DescribeExportTasksCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeExportTasksCommandInput} for command's `input` shape.
        * @see {@link DescribeExportTasksCommandOutput} for command's `response` shape.
        * @see {@link CloudWatchLogsClientResolvedConfig | config} for CloudWatchLogsClient's `config` shape.
        *
        */
    export class DescribeExportTasksCommand extends $Command<DescribeExportTasksCommandInput, DescribeExportTasksCommandOutput, CloudWatchLogsClientResolvedConfig> {
            readonly input: DescribeExportTasksCommandInput;
            constructor(input: DescribeExportTasksCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudWatchLogsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeExportTasksCommandInput, DescribeExportTasksCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DescribeLogGroupsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudWatchLogsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/CloudWatchLogsClient";
    import { DescribeLogGroupsRequest, DescribeLogGroupsResponse } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/models/models_0";
    export interface DescribeLogGroupsCommandInput extends DescribeLogGroupsRequest {
    }
    export interface DescribeLogGroupsCommandOutput extends DescribeLogGroupsResponse, __MetadataBearer {
    }
    /**
        * <p>Lists the specified log groups. You can list all your log groups or filter the results by prefix.
        *       The results are ASCII-sorted by log group name.</p>
        *          <p>CloudWatch Logs doesnâ€™t support IAM policies that control access to the <code>DescribeLogGroups</code> action by using the
        *       <code>aws:ResourceTag/<i>key-name</i>
        *             </code> condition key. Other CloudWatch Logs actions
        *       do support the use of the <code>aws:ResourceTag/<i>key-name</i>
        *             </code> condition key to control access.
        *       For more information about using tags to control access, see
        *       <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_tags.html">Controlling access to Amazon Web Services resources using tags</a>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudWatchLogsClient, DescribeLogGroupsCommand } from "@aws-sdk/client-cloudwatch-logs"; // ES Modules import
        * // const { CloudWatchLogsClient, DescribeLogGroupsCommand } = require("@aws-sdk/client-cloudwatch-logs"); // CommonJS import
        * const client = new CloudWatchLogsClient(config);
        * const command = new DescribeLogGroupsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeLogGroupsCommandInput} for command's `input` shape.
        * @see {@link DescribeLogGroupsCommandOutput} for command's `response` shape.
        * @see {@link CloudWatchLogsClientResolvedConfig | config} for CloudWatchLogsClient's `config` shape.
        *
        */
    export class DescribeLogGroupsCommand extends $Command<DescribeLogGroupsCommandInput, DescribeLogGroupsCommandOutput, CloudWatchLogsClientResolvedConfig> {
            readonly input: DescribeLogGroupsCommandInput;
            constructor(input: DescribeLogGroupsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudWatchLogsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeLogGroupsCommandInput, DescribeLogGroupsCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DescribeLogStreamsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudWatchLogsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/CloudWatchLogsClient";
    import { DescribeLogStreamsRequest, DescribeLogStreamsResponse } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/models/models_0";
    export interface DescribeLogStreamsCommandInput extends DescribeLogStreamsRequest {
    }
    export interface DescribeLogStreamsCommandOutput extends DescribeLogStreamsResponse, __MetadataBearer {
    }
    /**
        * <p>Lists the log streams for the specified log group.
        *       You can list all the log streams or filter the results by prefix.
        *       You can also control how the results are ordered.</p>
        *          <p>This operation has a limit of five transactions per second, after which transactions are throttled.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudWatchLogsClient, DescribeLogStreamsCommand } from "@aws-sdk/client-cloudwatch-logs"; // ES Modules import
        * // const { CloudWatchLogsClient, DescribeLogStreamsCommand } = require("@aws-sdk/client-cloudwatch-logs"); // CommonJS import
        * const client = new CloudWatchLogsClient(config);
        * const command = new DescribeLogStreamsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeLogStreamsCommandInput} for command's `input` shape.
        * @see {@link DescribeLogStreamsCommandOutput} for command's `response` shape.
        * @see {@link CloudWatchLogsClientResolvedConfig | config} for CloudWatchLogsClient's `config` shape.
        *
        */
    export class DescribeLogStreamsCommand extends $Command<DescribeLogStreamsCommandInput, DescribeLogStreamsCommandOutput, CloudWatchLogsClientResolvedConfig> {
            readonly input: DescribeLogStreamsCommandInput;
            constructor(input: DescribeLogStreamsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudWatchLogsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeLogStreamsCommandInput, DescribeLogStreamsCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DescribeMetricFiltersCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudWatchLogsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/CloudWatchLogsClient";
    import { DescribeMetricFiltersRequest, DescribeMetricFiltersResponse } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/models/models_0";
    export interface DescribeMetricFiltersCommandInput extends DescribeMetricFiltersRequest {
    }
    export interface DescribeMetricFiltersCommandOutput extends DescribeMetricFiltersResponse, __MetadataBearer {
    }
    /**
        * <p>Lists the specified metric filters. You can list all of the metric filters or filter
        *       the results by log name, prefix, metric name, or metric namespace. The results are
        *       ASCII-sorted by filter name.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudWatchLogsClient, DescribeMetricFiltersCommand } from "@aws-sdk/client-cloudwatch-logs"; // ES Modules import
        * // const { CloudWatchLogsClient, DescribeMetricFiltersCommand } = require("@aws-sdk/client-cloudwatch-logs"); // CommonJS import
        * const client = new CloudWatchLogsClient(config);
        * const command = new DescribeMetricFiltersCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeMetricFiltersCommandInput} for command's `input` shape.
        * @see {@link DescribeMetricFiltersCommandOutput} for command's `response` shape.
        * @see {@link CloudWatchLogsClientResolvedConfig | config} for CloudWatchLogsClient's `config` shape.
        *
        */
    export class DescribeMetricFiltersCommand extends $Command<DescribeMetricFiltersCommandInput, DescribeMetricFiltersCommandOutput, CloudWatchLogsClientResolvedConfig> {
            readonly input: DescribeMetricFiltersCommandInput;
            constructor(input: DescribeMetricFiltersCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudWatchLogsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeMetricFiltersCommandInput, DescribeMetricFiltersCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DescribeQueriesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudWatchLogsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/CloudWatchLogsClient";
    import { DescribeQueriesRequest, DescribeQueriesResponse } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/models/models_0";
    export interface DescribeQueriesCommandInput extends DescribeQueriesRequest {
    }
    export interface DescribeQueriesCommandOutput extends DescribeQueriesResponse, __MetadataBearer {
    }
    /**
        * <p>Returns a list of CloudWatch Logs Insights queries that are scheduled, executing, or have
        *       been executed recently in this account. You can request all queries or limit it to queries of
        *       a specific log group or queries with a certain status.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudWatchLogsClient, DescribeQueriesCommand } from "@aws-sdk/client-cloudwatch-logs"; // ES Modules import
        * // const { CloudWatchLogsClient, DescribeQueriesCommand } = require("@aws-sdk/client-cloudwatch-logs"); // CommonJS import
        * const client = new CloudWatchLogsClient(config);
        * const command = new DescribeQueriesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeQueriesCommandInput} for command's `input` shape.
        * @see {@link DescribeQueriesCommandOutput} for command's `response` shape.
        * @see {@link CloudWatchLogsClientResolvedConfig | config} for CloudWatchLogsClient's `config` shape.
        *
        */
    export class DescribeQueriesCommand extends $Command<DescribeQueriesCommandInput, DescribeQueriesCommandOutput, CloudWatchLogsClientResolvedConfig> {
            readonly input: DescribeQueriesCommandInput;
            constructor(input: DescribeQueriesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudWatchLogsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeQueriesCommandInput, DescribeQueriesCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DescribeQueryDefinitionsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudWatchLogsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/CloudWatchLogsClient";
    import { DescribeQueryDefinitionsRequest, DescribeQueryDefinitionsResponse } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/models/models_0";
    export interface DescribeQueryDefinitionsCommandInput extends DescribeQueryDefinitionsRequest {
    }
    export interface DescribeQueryDefinitionsCommandOutput extends DescribeQueryDefinitionsResponse, __MetadataBearer {
    }
    /**
        * <p>This operation returns a paginated list of your saved CloudWatch Logs Insights query definitions.</p>
        *          <p>You can use the <code>queryDefinitionNamePrefix</code> parameter to limit the results to only the
        *       query definitions that have names that start with a certain string.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudWatchLogsClient, DescribeQueryDefinitionsCommand } from "@aws-sdk/client-cloudwatch-logs"; // ES Modules import
        * // const { CloudWatchLogsClient, DescribeQueryDefinitionsCommand } = require("@aws-sdk/client-cloudwatch-logs"); // CommonJS import
        * const client = new CloudWatchLogsClient(config);
        * const command = new DescribeQueryDefinitionsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeQueryDefinitionsCommandInput} for command's `input` shape.
        * @see {@link DescribeQueryDefinitionsCommandOutput} for command's `response` shape.
        * @see {@link CloudWatchLogsClientResolvedConfig | config} for CloudWatchLogsClient's `config` shape.
        *
        */
    export class DescribeQueryDefinitionsCommand extends $Command<DescribeQueryDefinitionsCommandInput, DescribeQueryDefinitionsCommandOutput, CloudWatchLogsClientResolvedConfig> {
            readonly input: DescribeQueryDefinitionsCommandInput;
            constructor(input: DescribeQueryDefinitionsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudWatchLogsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeQueryDefinitionsCommandInput, DescribeQueryDefinitionsCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DescribeResourcePoliciesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudWatchLogsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/CloudWatchLogsClient";
    import { DescribeResourcePoliciesRequest, DescribeResourcePoliciesResponse } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/models/models_0";
    export interface DescribeResourcePoliciesCommandInput extends DescribeResourcePoliciesRequest {
    }
    export interface DescribeResourcePoliciesCommandOutput extends DescribeResourcePoliciesResponse, __MetadataBearer {
    }
    /**
        * <p>Lists the resource policies in this account.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudWatchLogsClient, DescribeResourcePoliciesCommand } from "@aws-sdk/client-cloudwatch-logs"; // ES Modules import
        * // const { CloudWatchLogsClient, DescribeResourcePoliciesCommand } = require("@aws-sdk/client-cloudwatch-logs"); // CommonJS import
        * const client = new CloudWatchLogsClient(config);
        * const command = new DescribeResourcePoliciesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeResourcePoliciesCommandInput} for command's `input` shape.
        * @see {@link DescribeResourcePoliciesCommandOutput} for command's `response` shape.
        * @see {@link CloudWatchLogsClientResolvedConfig | config} for CloudWatchLogsClient's `config` shape.
        *
        */
    export class DescribeResourcePoliciesCommand extends $Command<DescribeResourcePoliciesCommandInput, DescribeResourcePoliciesCommandOutput, CloudWatchLogsClientResolvedConfig> {
            readonly input: DescribeResourcePoliciesCommandInput;
            constructor(input: DescribeResourcePoliciesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudWatchLogsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeResourcePoliciesCommandInput, DescribeResourcePoliciesCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DescribeSubscriptionFiltersCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudWatchLogsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/CloudWatchLogsClient";
    import { DescribeSubscriptionFiltersRequest, DescribeSubscriptionFiltersResponse } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/models/models_0";
    export interface DescribeSubscriptionFiltersCommandInput extends DescribeSubscriptionFiltersRequest {
    }
    export interface DescribeSubscriptionFiltersCommandOutput extends DescribeSubscriptionFiltersResponse, __MetadataBearer {
    }
    /**
        * <p>Lists the subscription filters for the specified log group. You can list all the subscription filters or filter the results by prefix.
        *       The results are ASCII-sorted by filter name.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudWatchLogsClient, DescribeSubscriptionFiltersCommand } from "@aws-sdk/client-cloudwatch-logs"; // ES Modules import
        * // const { CloudWatchLogsClient, DescribeSubscriptionFiltersCommand } = require("@aws-sdk/client-cloudwatch-logs"); // CommonJS import
        * const client = new CloudWatchLogsClient(config);
        * const command = new DescribeSubscriptionFiltersCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeSubscriptionFiltersCommandInput} for command's `input` shape.
        * @see {@link DescribeSubscriptionFiltersCommandOutput} for command's `response` shape.
        * @see {@link CloudWatchLogsClientResolvedConfig | config} for CloudWatchLogsClient's `config` shape.
        *
        */
    export class DescribeSubscriptionFiltersCommand extends $Command<DescribeSubscriptionFiltersCommandInput, DescribeSubscriptionFiltersCommandOutput, CloudWatchLogsClientResolvedConfig> {
            readonly input: DescribeSubscriptionFiltersCommandInput;
            constructor(input: DescribeSubscriptionFiltersCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudWatchLogsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeSubscriptionFiltersCommandInput, DescribeSubscriptionFiltersCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/DisassociateKmsKeyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudWatchLogsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/CloudWatchLogsClient";
    import { DisassociateKmsKeyRequest } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/models/models_0";
    export interface DisassociateKmsKeyCommandInput extends DisassociateKmsKeyRequest {
    }
    export interface DisassociateKmsKeyCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Disassociates the associated Key Management Service customer master key (CMK) from the specified log group.</p>
        *          <p>After the KMS CMK is disassociated from the log group, CloudWatch Logs stops encrypting newly ingested data for the log group.
        *       All previously ingested data remains encrypted, and CloudWatch Logs requires permissions for the CMK whenever the encrypted data is requested.</p>
        *          <p>Note that it can take up to 5 minutes for this operation to take effect.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudWatchLogsClient, DisassociateKmsKeyCommand } from "@aws-sdk/client-cloudwatch-logs"; // ES Modules import
        * // const { CloudWatchLogsClient, DisassociateKmsKeyCommand } = require("@aws-sdk/client-cloudwatch-logs"); // CommonJS import
        * const client = new CloudWatchLogsClient(config);
        * const command = new DisassociateKmsKeyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DisassociateKmsKeyCommandInput} for command's `input` shape.
        * @see {@link DisassociateKmsKeyCommandOutput} for command's `response` shape.
        * @see {@link CloudWatchLogsClientResolvedConfig | config} for CloudWatchLogsClient's `config` shape.
        *
        */
    export class DisassociateKmsKeyCommand extends $Command<DisassociateKmsKeyCommandInput, DisassociateKmsKeyCommandOutput, CloudWatchLogsClientResolvedConfig> {
            readonly input: DisassociateKmsKeyCommandInput;
            constructor(input: DisassociateKmsKeyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudWatchLogsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DisassociateKmsKeyCommandInput, DisassociateKmsKeyCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/FilterLogEventsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudWatchLogsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/CloudWatchLogsClient";
    import { FilterLogEventsRequest, FilterLogEventsResponse } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/models/models_0";
    export interface FilterLogEventsCommandInput extends FilterLogEventsRequest {
    }
    export interface FilterLogEventsCommandOutput extends FilterLogEventsResponse, __MetadataBearer {
    }
    /**
        * <p>Lists log events from the specified log group. You can list all the log events or filter the results
        *       using a filter pattern, a time range, and the name of the log stream.</p>
        *          <p>By default, this operation returns as many log events as can fit in 1 MB (up to 10,000
        *       log events) or all the events found within the time range that you specify. If the results
        *       include a token, then there are more log events available, and you can get additional results
        *       by specifying the token in a subsequent call. This operation can return empty results
        *     while there are more log events available through the token.</p>
        *          <p>The returned log events are sorted by event timestamp, the timestamp when the event was ingested
        *     by CloudWatch Logs, and the ID of the <code>PutLogEvents</code> request.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudWatchLogsClient, FilterLogEventsCommand } from "@aws-sdk/client-cloudwatch-logs"; // ES Modules import
        * // const { CloudWatchLogsClient, FilterLogEventsCommand } = require("@aws-sdk/client-cloudwatch-logs"); // CommonJS import
        * const client = new CloudWatchLogsClient(config);
        * const command = new FilterLogEventsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link FilterLogEventsCommandInput} for command's `input` shape.
        * @see {@link FilterLogEventsCommandOutput} for command's `response` shape.
        * @see {@link CloudWatchLogsClientResolvedConfig | config} for CloudWatchLogsClient's `config` shape.
        *
        */
    export class FilterLogEventsCommand extends $Command<FilterLogEventsCommandInput, FilterLogEventsCommandOutput, CloudWatchLogsClientResolvedConfig> {
            readonly input: FilterLogEventsCommandInput;
            constructor(input: FilterLogEventsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudWatchLogsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<FilterLogEventsCommandInput, FilterLogEventsCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/GetLogEventsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudWatchLogsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/CloudWatchLogsClient";
    import { GetLogEventsRequest, GetLogEventsResponse } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/models/models_0";
    export interface GetLogEventsCommandInput extends GetLogEventsRequest {
    }
    export interface GetLogEventsCommandOutput extends GetLogEventsResponse, __MetadataBearer {
    }
    /**
        * <p>Lists log events from the specified log stream. You can list all of the log events or
        *       filter using a time range.</p>
        *
        *          <p>By default, this operation returns as many log events as can fit in a response size of 1MB (up to 10,000 log events).
        *       You can get additional log events by specifying one of the tokens in a subsequent call.
        *       This operation can return empty results while there are more log events available through the token.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudWatchLogsClient, GetLogEventsCommand } from "@aws-sdk/client-cloudwatch-logs"; // ES Modules import
        * // const { CloudWatchLogsClient, GetLogEventsCommand } = require("@aws-sdk/client-cloudwatch-logs"); // CommonJS import
        * const client = new CloudWatchLogsClient(config);
        * const command = new GetLogEventsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetLogEventsCommandInput} for command's `input` shape.
        * @see {@link GetLogEventsCommandOutput} for command's `response` shape.
        * @see {@link CloudWatchLogsClientResolvedConfig | config} for CloudWatchLogsClient's `config` shape.
        *
        */
    export class GetLogEventsCommand extends $Command<GetLogEventsCommandInput, GetLogEventsCommandOutput, CloudWatchLogsClientResolvedConfig> {
            readonly input: GetLogEventsCommandInput;
            constructor(input: GetLogEventsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudWatchLogsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetLogEventsCommandInput, GetLogEventsCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/GetLogGroupFieldsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudWatchLogsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/CloudWatchLogsClient";
    import { GetLogGroupFieldsRequest, GetLogGroupFieldsResponse } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/models/models_0";
    export interface GetLogGroupFieldsCommandInput extends GetLogGroupFieldsRequest {
    }
    export interface GetLogGroupFieldsCommandOutput extends GetLogGroupFieldsResponse, __MetadataBearer {
    }
    /**
        * <p>Returns a list of the fields that are included in log events in the specified log group, along with the percentage of log events
        *     that contain each field. The search is limited to a time period that you specify.</p>
        *          <p>In the results, fields that start with @ are fields generated by CloudWatch Logs. For
        *       example, <code>@timestamp</code> is the timestamp of each log event. For more information about the fields that are
        *       generated by CloudWatch logs, see
        *       <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CWL_AnalyzeLogData-discoverable-fields.html">Supported Logs and Discovered Fields</a>.</p>
        *          <p>The response results are sorted by the frequency percentage, starting
        *     with the highest percentage.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudWatchLogsClient, GetLogGroupFieldsCommand } from "@aws-sdk/client-cloudwatch-logs"; // ES Modules import
        * // const { CloudWatchLogsClient, GetLogGroupFieldsCommand } = require("@aws-sdk/client-cloudwatch-logs"); // CommonJS import
        * const client = new CloudWatchLogsClient(config);
        * const command = new GetLogGroupFieldsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetLogGroupFieldsCommandInput} for command's `input` shape.
        * @see {@link GetLogGroupFieldsCommandOutput} for command's `response` shape.
        * @see {@link CloudWatchLogsClientResolvedConfig | config} for CloudWatchLogsClient's `config` shape.
        *
        */
    export class GetLogGroupFieldsCommand extends $Command<GetLogGroupFieldsCommandInput, GetLogGroupFieldsCommandOutput, CloudWatchLogsClientResolvedConfig> {
            readonly input: GetLogGroupFieldsCommandInput;
            constructor(input: GetLogGroupFieldsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudWatchLogsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetLogGroupFieldsCommandInput, GetLogGroupFieldsCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/GetLogRecordCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudWatchLogsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/CloudWatchLogsClient";
    import { GetLogRecordRequest, GetLogRecordResponse } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/models/models_0";
    export interface GetLogRecordCommandInput extends GetLogRecordRequest {
    }
    export interface GetLogRecordCommandOutput extends GetLogRecordResponse, __MetadataBearer {
    }
    /**
        * <p>Retrieves all of the fields and values of a single log event. All fields are retrieved,
        *       even if the original query that produced the <code>logRecordPointer</code> retrieved only a
        *       subset of fields. Fields are returned as field name/field value pairs.</p>
        *          <p>The full unparsed log event is returned within <code>@message</code>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudWatchLogsClient, GetLogRecordCommand } from "@aws-sdk/client-cloudwatch-logs"; // ES Modules import
        * // const { CloudWatchLogsClient, GetLogRecordCommand } = require("@aws-sdk/client-cloudwatch-logs"); // CommonJS import
        * const client = new CloudWatchLogsClient(config);
        * const command = new GetLogRecordCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetLogRecordCommandInput} for command's `input` shape.
        * @see {@link GetLogRecordCommandOutput} for command's `response` shape.
        * @see {@link CloudWatchLogsClientResolvedConfig | config} for CloudWatchLogsClient's `config` shape.
        *
        */
    export class GetLogRecordCommand extends $Command<GetLogRecordCommandInput, GetLogRecordCommandOutput, CloudWatchLogsClientResolvedConfig> {
            readonly input: GetLogRecordCommandInput;
            constructor(input: GetLogRecordCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudWatchLogsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetLogRecordCommandInput, GetLogRecordCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/GetQueryResultsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudWatchLogsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/CloudWatchLogsClient";
    import { GetQueryResultsRequest, GetQueryResultsResponse } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/models/models_0";
    export interface GetQueryResultsCommandInput extends GetQueryResultsRequest {
    }
    export interface GetQueryResultsCommandOutput extends GetQueryResultsResponse, __MetadataBearer {
    }
    /**
        * <p>Returns the results from the specified query.</p>
        *          <p>Only the fields requested in the query are returned, along with a <code>@ptr</code>
        *       field, which is the identifier for the log record. You can use the value of <code>@ptr</code>
        *       in a <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_GetLogRecord.html">GetLogRecord</a>
        *       operation to get the full log record.</p>
        *          <p>
        *             <code>GetQueryResults</code>
        *       does not start a query execution. To run a query, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_StartQuery.html">StartQuery</a>.</p>
        *          <p>If the value of the <code>Status</code> field in the output is <code>Running</code>, this operation
        *       returns only partial results. If you see a value of <code>Scheduled</code> or <code>Running</code> for the status,
        *       you can retry the operation later to see the final results. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudWatchLogsClient, GetQueryResultsCommand } from "@aws-sdk/client-cloudwatch-logs"; // ES Modules import
        * // const { CloudWatchLogsClient, GetQueryResultsCommand } = require("@aws-sdk/client-cloudwatch-logs"); // CommonJS import
        * const client = new CloudWatchLogsClient(config);
        * const command = new GetQueryResultsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetQueryResultsCommandInput} for command's `input` shape.
        * @see {@link GetQueryResultsCommandOutput} for command's `response` shape.
        * @see {@link CloudWatchLogsClientResolvedConfig | config} for CloudWatchLogsClient's `config` shape.
        *
        */
    export class GetQueryResultsCommand extends $Command<GetQueryResultsCommandInput, GetQueryResultsCommandOutput, CloudWatchLogsClientResolvedConfig> {
            readonly input: GetQueryResultsCommandInput;
            constructor(input: GetQueryResultsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudWatchLogsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetQueryResultsCommandInput, GetQueryResultsCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/ListTagsLogGroupCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudWatchLogsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/CloudWatchLogsClient";
    import { ListTagsLogGroupRequest, ListTagsLogGroupResponse } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/models/models_0";
    export interface ListTagsLogGroupCommandInput extends ListTagsLogGroupRequest {
    }
    export interface ListTagsLogGroupCommandOutput extends ListTagsLogGroupResponse, __MetadataBearer {
    }
    /**
        * <p>Lists the tags for the specified log group.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudWatchLogsClient, ListTagsLogGroupCommand } from "@aws-sdk/client-cloudwatch-logs"; // ES Modules import
        * // const { CloudWatchLogsClient, ListTagsLogGroupCommand } = require("@aws-sdk/client-cloudwatch-logs"); // CommonJS import
        * const client = new CloudWatchLogsClient(config);
        * const command = new ListTagsLogGroupCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListTagsLogGroupCommandInput} for command's `input` shape.
        * @see {@link ListTagsLogGroupCommandOutput} for command's `response` shape.
        * @see {@link CloudWatchLogsClientResolvedConfig | config} for CloudWatchLogsClient's `config` shape.
        *
        */
    export class ListTagsLogGroupCommand extends $Command<ListTagsLogGroupCommandInput, ListTagsLogGroupCommandOutput, CloudWatchLogsClientResolvedConfig> {
            readonly input: ListTagsLogGroupCommandInput;
            constructor(input: ListTagsLogGroupCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudWatchLogsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListTagsLogGroupCommandInput, ListTagsLogGroupCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/PutDestinationCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudWatchLogsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/CloudWatchLogsClient";
    import { PutDestinationRequest, PutDestinationResponse } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/models/models_0";
    export interface PutDestinationCommandInput extends PutDestinationRequest {
    }
    export interface PutDestinationCommandOutput extends PutDestinationResponse, __MetadataBearer {
    }
    /**
        * <p>Creates or updates a destination. This operation is used only to create destinations for cross-account subscriptions.</p>
        *          <p>A destination encapsulates a physical resource (such
        *       as an Amazon Kinesis stream) and enables you to subscribe to a real-time stream of log events
        *       for a different account, ingested using <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutLogEvents.html">PutLogEvents</a>.</p>
        *          <p>Through an access policy, a destination controls what is written to it.
        *       By default, <code>PutDestination</code> does not set any access policy with the destination,
        *       which means a cross-account user cannot call <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutSubscriptionFilter.html">PutSubscriptionFilter</a> against
        *       this destination. To enable this, the destination owner must call <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutDestinationPolicy.html">PutDestinationPolicy</a> after <code>PutDestination</code>.</p>
        *          <p>To perform a <code>PutDestination</code> operation, you must also have the
        *     <code>iam:PassRole</code> permission.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudWatchLogsClient, PutDestinationCommand } from "@aws-sdk/client-cloudwatch-logs"; // ES Modules import
        * // const { CloudWatchLogsClient, PutDestinationCommand } = require("@aws-sdk/client-cloudwatch-logs"); // CommonJS import
        * const client = new CloudWatchLogsClient(config);
        * const command = new PutDestinationCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link PutDestinationCommandInput} for command's `input` shape.
        * @see {@link PutDestinationCommandOutput} for command's `response` shape.
        * @see {@link CloudWatchLogsClientResolvedConfig | config} for CloudWatchLogsClient's `config` shape.
        *
        */
    export class PutDestinationCommand extends $Command<PutDestinationCommandInput, PutDestinationCommandOutput, CloudWatchLogsClientResolvedConfig> {
            readonly input: PutDestinationCommandInput;
            constructor(input: PutDestinationCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudWatchLogsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<PutDestinationCommandInput, PutDestinationCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/PutDestinationPolicyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudWatchLogsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/CloudWatchLogsClient";
    import { PutDestinationPolicyRequest } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/models/models_0";
    export interface PutDestinationPolicyCommandInput extends PutDestinationPolicyRequest {
    }
    export interface PutDestinationPolicyCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Creates or updates an access policy associated with an existing
        *       destination. An access policy is an <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/policies_overview.html">IAM policy document</a> that is used
        *       to authorize claims to register a subscription filter against a given destination.</p>
        *          <p>If multiple Amazon Web Services accounts are sending logs to this destination, each sender account must be
        *     listed separately in the policy. The policy does not support specifying <code>*</code>
        *     as the Principal or the use of the <code>aws:PrincipalOrgId</code> global key.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudWatchLogsClient, PutDestinationPolicyCommand } from "@aws-sdk/client-cloudwatch-logs"; // ES Modules import
        * // const { CloudWatchLogsClient, PutDestinationPolicyCommand } = require("@aws-sdk/client-cloudwatch-logs"); // CommonJS import
        * const client = new CloudWatchLogsClient(config);
        * const command = new PutDestinationPolicyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link PutDestinationPolicyCommandInput} for command's `input` shape.
        * @see {@link PutDestinationPolicyCommandOutput} for command's `response` shape.
        * @see {@link CloudWatchLogsClientResolvedConfig | config} for CloudWatchLogsClient's `config` shape.
        *
        */
    export class PutDestinationPolicyCommand extends $Command<PutDestinationPolicyCommandInput, PutDestinationPolicyCommandOutput, CloudWatchLogsClientResolvedConfig> {
            readonly input: PutDestinationPolicyCommandInput;
            constructor(input: PutDestinationPolicyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudWatchLogsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<PutDestinationPolicyCommandInput, PutDestinationPolicyCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/PutLogEventsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudWatchLogsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/CloudWatchLogsClient";
    import { PutLogEventsRequest, PutLogEventsResponse } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/models/models_0";
    export interface PutLogEventsCommandInput extends PutLogEventsRequest {
    }
    export interface PutLogEventsCommandOutput extends PutLogEventsResponse, __MetadataBearer {
    }
    /**
        * <p>Uploads a batch of log events to the specified log stream.</p>
        *          <p>You must include the sequence token obtained from the response of the previous call. An
        *       upload in a newly created log stream does not require a sequence token. You can also get the
        *       sequence token in the <code>expectedSequenceToken</code> field from
        *         <code>InvalidSequenceTokenException</code>. If you call <code>PutLogEvents</code> twice
        *       within a narrow time period using the same value for <code>sequenceToken</code>, both calls
        *       might be successful or one might be rejected.</p>
        *          <p>The batch of events must satisfy the following constraints:</p>
        *          <ul>
        *             <li>
        *                <p>The maximum batch size is 1,048,576 bytes. This size is calculated as the sum of
        *           all event messages in UTF-8, plus 26 bytes for each log event.</p>
        *             </li>
        *             <li>
        *                <p>None of the log events in the batch can be more than 2 hours in the future.</p>
        *             </li>
        *             <li>
        *                <p>None of the log events in the batch can be older than 14 days or older than the retention
        *           period of the log group.</p>
        *             </li>
        *             <li>
        *                <p>The log events in the batch must be in chronological order by their timestamp. The
        *           timestamp is the time the event occurred, expressed as the number of milliseconds after
        *           Jan 1, 1970 00:00:00 UTC. (In Amazon Web Services Tools for PowerShell and the Amazon Web Services SDK for .NET, the
        *           timestamp is specified in .NET format: yyyy-mm-ddThh:mm:ss. For example,
        *           2017-09-15T13:45:30.) </p>
        *             </li>
        *             <li>
        *                <p>A batch of log events in a single request cannot span more than 24 hours. Otherwise, the operation fails.</p>
        *             </li>
        *             <li>
        *                <p>The maximum number of log events in a batch is 10,000.</p>
        *             </li>
        *             <li>
        *                <p>There is a quota of 5 requests per second per log stream. Additional requests are throttled. This quota can't be changed.</p>
        *             </li>
        *          </ul>
        *          <p>If a call to <code>PutLogEvents</code> returns "UnrecognizedClientException" the most likely cause is an invalid Amazon Web Services access key ID or secret key. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudWatchLogsClient, PutLogEventsCommand } from "@aws-sdk/client-cloudwatch-logs"; // ES Modules import
        * // const { CloudWatchLogsClient, PutLogEventsCommand } = require("@aws-sdk/client-cloudwatch-logs"); // CommonJS import
        * const client = new CloudWatchLogsClient(config);
        * const command = new PutLogEventsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link PutLogEventsCommandInput} for command's `input` shape.
        * @see {@link PutLogEventsCommandOutput} for command's `response` shape.
        * @see {@link CloudWatchLogsClientResolvedConfig | config} for CloudWatchLogsClient's `config` shape.
        *
        */
    export class PutLogEventsCommand extends $Command<PutLogEventsCommandInput, PutLogEventsCommandOutput, CloudWatchLogsClientResolvedConfig> {
            readonly input: PutLogEventsCommandInput;
            constructor(input: PutLogEventsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudWatchLogsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<PutLogEventsCommandInput, PutLogEventsCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/PutMetricFilterCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudWatchLogsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/CloudWatchLogsClient";
    import { PutMetricFilterRequest } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/models/models_0";
    export interface PutMetricFilterCommandInput extends PutMetricFilterRequest {
    }
    export interface PutMetricFilterCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Creates or updates a metric filter and associates it with the specified log group.
        *       Metric filters allow you to configure rules to extract metric data from log events ingested
        *       through <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutLogEvents.html">PutLogEvents</a>.</p>
        *          <p>The maximum number of metric filters that can be associated with a log group is
        *       100.</p>
        *          <p>When you create a metric filter, you can also optionally assign a unit and dimensions
        *     to the metric that is created.</p>
        *          <important>
        *             <p>Metrics extracted from log events are charged as custom metrics.
        *       To prevent unexpected high charges, do not specify high-cardinality fields such as
        *       <code>IPAddress</code> or <code>requestID</code> as dimensions. Each different value
        *       found for
        *       a dimension is treated as a separate metric and accrues charges as a separate custom metric.
        *     </p>
        *             <p>To help prevent accidental high charges, Amazon disables a metric filter
        *         if it generates 1000 different name/value pairs for the dimensions that you
        *         have specified within a certain amount of time.</p>
        *             <p>You can also set up a billing alarm to alert you if your charges are higher than
        *         expected. For more information,
        *         see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/monitor_estimated_charges_with_cloudwatch.html">
        *           Creating a Billing Alarm to Monitor Your Estimated Amazon Web Services Charges</a>.
        *       </p>
        *          </important>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudWatchLogsClient, PutMetricFilterCommand } from "@aws-sdk/client-cloudwatch-logs"; // ES Modules import
        * // const { CloudWatchLogsClient, PutMetricFilterCommand } = require("@aws-sdk/client-cloudwatch-logs"); // CommonJS import
        * const client = new CloudWatchLogsClient(config);
        * const command = new PutMetricFilterCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link PutMetricFilterCommandInput} for command's `input` shape.
        * @see {@link PutMetricFilterCommandOutput} for command's `response` shape.
        * @see {@link CloudWatchLogsClientResolvedConfig | config} for CloudWatchLogsClient's `config` shape.
        *
        */
    export class PutMetricFilterCommand extends $Command<PutMetricFilterCommandInput, PutMetricFilterCommandOutput, CloudWatchLogsClientResolvedConfig> {
            readonly input: PutMetricFilterCommandInput;
            constructor(input: PutMetricFilterCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudWatchLogsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<PutMetricFilterCommandInput, PutMetricFilterCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/PutQueryDefinitionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudWatchLogsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/CloudWatchLogsClient";
    import { PutQueryDefinitionRequest, PutQueryDefinitionResponse } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/models/models_0";
    export interface PutQueryDefinitionCommandInput extends PutQueryDefinitionRequest {
    }
    export interface PutQueryDefinitionCommandOutput extends PutQueryDefinitionResponse, __MetadataBearer {
    }
    /**
        * <p>Creates or updates a query definition for CloudWatch Logs Insights. For
        *       more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/AnalyzingLogData.html">Analyzing Log Data with CloudWatch Logs Insights</a>.</p>
        *
        *          <p>To update a query definition, specify its
        *         <code>queryDefinitionId</code> in your request. The values of <code>name</code>, <code>queryString</code>,
        *       and <code>logGroupNames</code> are changed to the values that you specify in your update
        *       operation. No current values are retained from the current query definition. For example, if
        *       you update a current query definition that includes log groups, and you don't specify the
        *         <code>logGroupNames</code> parameter in your update operation, the query definition changes
        *       to contain no log groups.</p>
        *          <p>You must have the <code>logs:PutQueryDefinition</code> permission to be able to perform
        *     this operation.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudWatchLogsClient, PutQueryDefinitionCommand } from "@aws-sdk/client-cloudwatch-logs"; // ES Modules import
        * // const { CloudWatchLogsClient, PutQueryDefinitionCommand } = require("@aws-sdk/client-cloudwatch-logs"); // CommonJS import
        * const client = new CloudWatchLogsClient(config);
        * const command = new PutQueryDefinitionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link PutQueryDefinitionCommandInput} for command's `input` shape.
        * @see {@link PutQueryDefinitionCommandOutput} for command's `response` shape.
        * @see {@link CloudWatchLogsClientResolvedConfig | config} for CloudWatchLogsClient's `config` shape.
        *
        */
    export class PutQueryDefinitionCommand extends $Command<PutQueryDefinitionCommandInput, PutQueryDefinitionCommandOutput, CloudWatchLogsClientResolvedConfig> {
            readonly input: PutQueryDefinitionCommandInput;
            constructor(input: PutQueryDefinitionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudWatchLogsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<PutQueryDefinitionCommandInput, PutQueryDefinitionCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/PutResourcePolicyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudWatchLogsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/CloudWatchLogsClient";
    import { PutResourcePolicyRequest, PutResourcePolicyResponse } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/models/models_0";
    export interface PutResourcePolicyCommandInput extends PutResourcePolicyRequest {
    }
    export interface PutResourcePolicyCommandOutput extends PutResourcePolicyResponse, __MetadataBearer {
    }
    /**
        * <p>Creates or updates a resource policy allowing other Amazon Web Services services to put log events to
        *       this account, such as Amazon Route 53. An account can have up to 10 resource policies per Amazon Web Services
        *       Region.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudWatchLogsClient, PutResourcePolicyCommand } from "@aws-sdk/client-cloudwatch-logs"; // ES Modules import
        * // const { CloudWatchLogsClient, PutResourcePolicyCommand } = require("@aws-sdk/client-cloudwatch-logs"); // CommonJS import
        * const client = new CloudWatchLogsClient(config);
        * const command = new PutResourcePolicyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link PutResourcePolicyCommandInput} for command's `input` shape.
        * @see {@link PutResourcePolicyCommandOutput} for command's `response` shape.
        * @see {@link CloudWatchLogsClientResolvedConfig | config} for CloudWatchLogsClient's `config` shape.
        *
        */
    export class PutResourcePolicyCommand extends $Command<PutResourcePolicyCommandInput, PutResourcePolicyCommandOutput, CloudWatchLogsClientResolvedConfig> {
            readonly input: PutResourcePolicyCommandInput;
            constructor(input: PutResourcePolicyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudWatchLogsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<PutResourcePolicyCommandInput, PutResourcePolicyCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/PutRetentionPolicyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudWatchLogsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/CloudWatchLogsClient";
    import { PutRetentionPolicyRequest } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/models/models_0";
    export interface PutRetentionPolicyCommandInput extends PutRetentionPolicyRequest {
    }
    export interface PutRetentionPolicyCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Sets the retention of the specified log group. A retention policy allows you to
        *       configure the number of days for which to retain log events in the specified log
        *       group.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudWatchLogsClient, PutRetentionPolicyCommand } from "@aws-sdk/client-cloudwatch-logs"; // ES Modules import
        * // const { CloudWatchLogsClient, PutRetentionPolicyCommand } = require("@aws-sdk/client-cloudwatch-logs"); // CommonJS import
        * const client = new CloudWatchLogsClient(config);
        * const command = new PutRetentionPolicyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link PutRetentionPolicyCommandInput} for command's `input` shape.
        * @see {@link PutRetentionPolicyCommandOutput} for command's `response` shape.
        * @see {@link CloudWatchLogsClientResolvedConfig | config} for CloudWatchLogsClient's `config` shape.
        *
        */
    export class PutRetentionPolicyCommand extends $Command<PutRetentionPolicyCommandInput, PutRetentionPolicyCommandOutput, CloudWatchLogsClientResolvedConfig> {
            readonly input: PutRetentionPolicyCommandInput;
            constructor(input: PutRetentionPolicyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudWatchLogsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<PutRetentionPolicyCommandInput, PutRetentionPolicyCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/PutSubscriptionFilterCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudWatchLogsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/CloudWatchLogsClient";
    import { PutSubscriptionFilterRequest } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/models/models_0";
    export interface PutSubscriptionFilterCommandInput extends PutSubscriptionFilterRequest {
    }
    export interface PutSubscriptionFilterCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Creates or updates a subscription filter and associates it with the specified log
        *       group. Subscription filters allow you to subscribe to a real-time stream of log events
        *       ingested through <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutLogEvents.html">PutLogEvents</a> and have them delivered to a specific
        *       destination. When log events are sent to the
        *       receiving service, they are Base64 encoded
        *       and compressed with the gzip format.</p>
        *          <p>The following destinations are supported for subscription filters:</p>
        *          <ul>
        *             <li>
        *                <p>An Amazon Kinesis stream belonging to the same account as the subscription filter,
        *           for same-account delivery.</p>
        *             </li>
        *             <li>
        *                <p>A logical destination that belongs to a different account, for cross-account delivery.</p>
        *             </li>
        *             <li>
        *                <p>An Amazon Kinesis Firehose delivery stream that belongs to the same account as the
        *           subscription filter, for same-account delivery.</p>
        *             </li>
        *             <li>
        *                <p>An Lambda function that belongs to the same account as the subscription filter,
        *           for same-account delivery.</p>
        *             </li>
        *          </ul>
        *          <p>Each log group can have up to two subscription filters associated with it. If you are
        *       updating an existing filter, you must specify the correct name in <code>filterName</code>.
        *       </p>
        *          <p>To perform a <code>PutSubscriptionFilter</code> operation, you must also have the
        *       <code>iam:PassRole</code> permission.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudWatchLogsClient, PutSubscriptionFilterCommand } from "@aws-sdk/client-cloudwatch-logs"; // ES Modules import
        * // const { CloudWatchLogsClient, PutSubscriptionFilterCommand } = require("@aws-sdk/client-cloudwatch-logs"); // CommonJS import
        * const client = new CloudWatchLogsClient(config);
        * const command = new PutSubscriptionFilterCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link PutSubscriptionFilterCommandInput} for command's `input` shape.
        * @see {@link PutSubscriptionFilterCommandOutput} for command's `response` shape.
        * @see {@link CloudWatchLogsClientResolvedConfig | config} for CloudWatchLogsClient's `config` shape.
        *
        */
    export class PutSubscriptionFilterCommand extends $Command<PutSubscriptionFilterCommandInput, PutSubscriptionFilterCommandOutput, CloudWatchLogsClientResolvedConfig> {
            readonly input: PutSubscriptionFilterCommandInput;
            constructor(input: PutSubscriptionFilterCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudWatchLogsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<PutSubscriptionFilterCommandInput, PutSubscriptionFilterCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/StartQueryCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudWatchLogsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/CloudWatchLogsClient";
    import { StartQueryRequest, StartQueryResponse } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/models/models_0";
    export interface StartQueryCommandInput extends StartQueryRequest {
    }
    export interface StartQueryCommandOutput extends StartQueryResponse, __MetadataBearer {
    }
    /**
        * <p>Schedules a query of a log group using CloudWatch Logs Insights. You specify the log group
        *       and time range to query and the query string to use.</p>
        *          <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CWL_QuerySyntax.html">CloudWatch Logs Insights Query Syntax</a>.</p>
        *
        *          <p>Queries time out after 15 minutes of execution. If your queries are timing out, reduce the
        *       time range being searched or partition your query into a number of queries.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudWatchLogsClient, StartQueryCommand } from "@aws-sdk/client-cloudwatch-logs"; // ES Modules import
        * // const { CloudWatchLogsClient, StartQueryCommand } = require("@aws-sdk/client-cloudwatch-logs"); // CommonJS import
        * const client = new CloudWatchLogsClient(config);
        * const command = new StartQueryCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link StartQueryCommandInput} for command's `input` shape.
        * @see {@link StartQueryCommandOutput} for command's `response` shape.
        * @see {@link CloudWatchLogsClientResolvedConfig | config} for CloudWatchLogsClient's `config` shape.
        *
        */
    export class StartQueryCommand extends $Command<StartQueryCommandInput, StartQueryCommandOutput, CloudWatchLogsClientResolvedConfig> {
            readonly input: StartQueryCommandInput;
            constructor(input: StartQueryCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudWatchLogsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<StartQueryCommandInput, StartQueryCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/StopQueryCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudWatchLogsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/CloudWatchLogsClient";
    import { StopQueryRequest, StopQueryResponse } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/models/models_0";
    export interface StopQueryCommandInput extends StopQueryRequest {
    }
    export interface StopQueryCommandOutput extends StopQueryResponse, __MetadataBearer {
    }
    /**
        * <p>Stops a CloudWatch Logs Insights query that is in progress. If the query has already ended, the operation
        *     returns an error indicating that the specified query is not running.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudWatchLogsClient, StopQueryCommand } from "@aws-sdk/client-cloudwatch-logs"; // ES Modules import
        * // const { CloudWatchLogsClient, StopQueryCommand } = require("@aws-sdk/client-cloudwatch-logs"); // CommonJS import
        * const client = new CloudWatchLogsClient(config);
        * const command = new StopQueryCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link StopQueryCommandInput} for command's `input` shape.
        * @see {@link StopQueryCommandOutput} for command's `response` shape.
        * @see {@link CloudWatchLogsClientResolvedConfig | config} for CloudWatchLogsClient's `config` shape.
        *
        */
    export class StopQueryCommand extends $Command<StopQueryCommandInput, StopQueryCommandOutput, CloudWatchLogsClientResolvedConfig> {
            readonly input: StopQueryCommandInput;
            constructor(input: StopQueryCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudWatchLogsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<StopQueryCommandInput, StopQueryCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/TagLogGroupCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudWatchLogsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/CloudWatchLogsClient";
    import { TagLogGroupRequest } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/models/models_0";
    export interface TagLogGroupCommandInput extends TagLogGroupRequest {
    }
    export interface TagLogGroupCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Adds or updates the specified tags for the specified log group.</p>
        *          <p>To list the tags for a log group, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_ListTagsLogGroup.html">ListTagsLogGroup</a>.
        *       To remove tags, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_UntagLogGroup.html">UntagLogGroup</a>.</p>
        *          <p>For more information about tags, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html#log-group-tagging">Tag Log Groups in Amazon CloudWatch Logs</a>
        *       in the <i>Amazon CloudWatch Logs User Guide</i>.</p>
        *          <p>CloudWatch Logs doesnâ€™t support IAM policies that prevent users from assigning specified tags to
        *       log groups using the <code>aws:Resource/<i>key-name</i>
        *             </code> or <code>aws:TagKeys</code> condition keys.
        *       For more information about using tags to control access, see
        *       <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_tags.html">Controlling access to Amazon Web Services resources using tags</a>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudWatchLogsClient, TagLogGroupCommand } from "@aws-sdk/client-cloudwatch-logs"; // ES Modules import
        * // const { CloudWatchLogsClient, TagLogGroupCommand } = require("@aws-sdk/client-cloudwatch-logs"); // CommonJS import
        * const client = new CloudWatchLogsClient(config);
        * const command = new TagLogGroupCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link TagLogGroupCommandInput} for command's `input` shape.
        * @see {@link TagLogGroupCommandOutput} for command's `response` shape.
        * @see {@link CloudWatchLogsClientResolvedConfig | config} for CloudWatchLogsClient's `config` shape.
        *
        */
    export class TagLogGroupCommand extends $Command<TagLogGroupCommandInput, TagLogGroupCommandOutput, CloudWatchLogsClientResolvedConfig> {
            readonly input: TagLogGroupCommandInput;
            constructor(input: TagLogGroupCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudWatchLogsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<TagLogGroupCommandInput, TagLogGroupCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/TestMetricFilterCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudWatchLogsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/CloudWatchLogsClient";
    import { TestMetricFilterRequest, TestMetricFilterResponse } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/models/models_0";
    export interface TestMetricFilterCommandInput extends TestMetricFilterRequest {
    }
    export interface TestMetricFilterCommandOutput extends TestMetricFilterResponse, __MetadataBearer {
    }
    /**
        * <p>Tests the filter pattern of a metric filter against a sample of log event messages. You
        *       can use this operation to validate the correctness of a metric filter pattern.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudWatchLogsClient, TestMetricFilterCommand } from "@aws-sdk/client-cloudwatch-logs"; // ES Modules import
        * // const { CloudWatchLogsClient, TestMetricFilterCommand } = require("@aws-sdk/client-cloudwatch-logs"); // CommonJS import
        * const client = new CloudWatchLogsClient(config);
        * const command = new TestMetricFilterCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link TestMetricFilterCommandInput} for command's `input` shape.
        * @see {@link TestMetricFilterCommandOutput} for command's `response` shape.
        * @see {@link CloudWatchLogsClientResolvedConfig | config} for CloudWatchLogsClient's `config` shape.
        *
        */
    export class TestMetricFilterCommand extends $Command<TestMetricFilterCommandInput, TestMetricFilterCommandOutput, CloudWatchLogsClientResolvedConfig> {
            readonly input: TestMetricFilterCommandInput;
            constructor(input: TestMetricFilterCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudWatchLogsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<TestMetricFilterCommandInput, TestMetricFilterCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/commands/UntagLogGroupCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CloudWatchLogsClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/CloudWatchLogsClient";
    import { UntagLogGroupRequest } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/models/models_0";
    export interface UntagLogGroupCommandInput extends UntagLogGroupRequest {
    }
    export interface UntagLogGroupCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Removes the specified tags from the specified log group.</p>
        *          <p>To list the tags for a log group, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_ListTagsLogGroup.html">ListTagsLogGroup</a>.
        *       To add tags, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_TagLogGroup.html">TagLogGroup</a>.</p>
        *          <p>CloudWatch Logs doesnâ€™t support IAM policies that prevent users from assigning specified tags to
        *       log groups using the <code>aws:Resource/<i>key-name</i>
        *             </code> or <code>aws:TagKeys</code> condition keys.
        *      </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { CloudWatchLogsClient, UntagLogGroupCommand } from "@aws-sdk/client-cloudwatch-logs"; // ES Modules import
        * // const { CloudWatchLogsClient, UntagLogGroupCommand } = require("@aws-sdk/client-cloudwatch-logs"); // CommonJS import
        * const client = new CloudWatchLogsClient(config);
        * const command = new UntagLogGroupCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UntagLogGroupCommandInput} for command's `input` shape.
        * @see {@link UntagLogGroupCommandOutput} for command's `response` shape.
        * @see {@link CloudWatchLogsClientResolvedConfig | config} for CloudWatchLogsClient's `config` shape.
        *
        */
    export class UntagLogGroupCommand extends $Command<UntagLogGroupCommandInput, UntagLogGroupCommandOutput, CloudWatchLogsClientResolvedConfig> {
            readonly input: UntagLogGroupCommandInput;
            constructor(input: UntagLogGroupCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: CloudWatchLogsClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UntagLogGroupCommandInput, UntagLogGroupCommandOutput>;
    }
}

declare module '@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/models/models_0' {
    import { ExceptionOptionType as __ExceptionOptionType } from "@aws-sdk/smithy-client";
    import { CloudWatchLogsServiceException as __BaseException } from "@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/models/CloudWatchLogsServiceException";
    export interface AssociateKmsKeyRequest {
            /**
                * <p>The name of the log group.</p>
                */
            logGroupName: string | undefined;
            /**
                * <p>The Amazon Resource Name (ARN) of the CMK to use when encrypting log data. This must be a symmetric CMK.
                *       For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-kms">Amazon Resource Names - Key Management Service</a> and <a href="https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html">Using Symmetric and Asymmetric Keys</a>.</p>
                */
            kmsKeyId: string | undefined;
    }
    export namespace AssociateKmsKeyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AssociateKmsKeyRequest) => any;
    }
    /**
        * <p>A parameter is specified incorrectly.</p>
        */
    export class InvalidParameterException extends __BaseException {
            readonly name: "InvalidParameterException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidParameterException, __BaseException>);
    }
    /**
        * <p>Multiple concurrent requests to update the same resource were in conflict.</p>
        */
    export class OperationAbortedException extends __BaseException {
            readonly name: "OperationAbortedException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<OperationAbortedException, __BaseException>);
    }
    /**
        * <p>The specified resource does not exist.</p>
        */
    export class ResourceNotFoundException extends __BaseException {
            readonly name: "ResourceNotFoundException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ResourceNotFoundException, __BaseException>);
    }
    /**
        * <p>The service cannot complete the request.</p>
        */
    export class ServiceUnavailableException extends __BaseException {
            readonly name: "ServiceUnavailableException";
            readonly $fault: "server";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ServiceUnavailableException, __BaseException>);
    }
    export interface CancelExportTaskRequest {
            /**
                * <p>The ID of the export task.</p>
                */
            taskId: string | undefined;
    }
    export namespace CancelExportTaskRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CancelExportTaskRequest) => any;
    }
    /**
        * <p>The operation is not valid on the specified resource.</p>
        */
    export class InvalidOperationException extends __BaseException {
            readonly name: "InvalidOperationException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidOperationException, __BaseException>);
    }
    export interface CreateExportTaskRequest {
            /**
                * <p>The name of the export task.</p>
                */
            taskName?: string;
            /**
                * <p>The name of the log group.</p>
                */
            logGroupName: string | undefined;
            /**
                * <p>Export only log streams that match the provided prefix. If you don't
                *       specify a value, no prefix filter is applied.</p>
                */
            logStreamNamePrefix?: string;
            /**
                * <p>The start time of the range for the request, expressed as the number of milliseconds
                *       after Jan 1, 1970 00:00:00 UTC. Events with a timestamp earlier than this time are not
                *       exported.</p>
                */
            from: number | undefined;
            /**
                * <p>The end time of the range for the request, expressed as the number of milliseconds
                *       after Jan 1, 1970 00:00:00 UTC. Events with a timestamp later than this time are not
                *       exported.</p>
                */
            to: number | undefined;
            /**
                * <p>The name of S3 bucket for the exported log data. The bucket must be in the same Amazon Web Services region.</p>
                */
            destination: string | undefined;
            /**
                * <p>The prefix used as the start of the key for every object exported. If you don't
                *       specify a value, the default is <code>exportedlogs</code>.</p>
                */
            destinationPrefix?: string;
    }
    export namespace CreateExportTaskRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateExportTaskRequest) => any;
    }
    export interface CreateExportTaskResponse {
            /**
                * <p>The ID of the export task.</p>
                */
            taskId?: string;
    }
    export namespace CreateExportTaskResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateExportTaskResponse) => any;
    }
    /**
        * <p>You have reached the maximum number of resources that can be created.</p>
        */
    export class LimitExceededException extends __BaseException {
            readonly name: "LimitExceededException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<LimitExceededException, __BaseException>);
    }
    /**
        * <p>The specified resource already exists.</p>
        */
    export class ResourceAlreadyExistsException extends __BaseException {
            readonly name: "ResourceAlreadyExistsException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ResourceAlreadyExistsException, __BaseException>);
    }
    export interface CreateLogGroupRequest {
            /**
                * <p>The name of the log group.</p>
                */
            logGroupName: string | undefined;
            /**
                * <p>The Amazon Resource Name (ARN) of the CMK to use when encrypting log data.
                *       For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-kms">Amazon Resource Names - Key Management Service</a>.</p>
                */
            kmsKeyId?: string;
            /**
                * <p>The key-value pairs to use for the tags.</p>
                *          <p>CloudWatch Logs doesnâ€™t support IAM policies that prevent users from assigning specified tags to
                *       log groups using the <code>aws:Resource/<i>key-name</i>
                *             </code> or <code>aws:TagKeys</code> condition keys.
                *       For more information about using tags to control access, see
                *       <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_tags.html">Controlling access to Amazon Web Services resources using tags</a>.</p>
                */
            tags?: Record<string, string>;
    }
    export namespace CreateLogGroupRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateLogGroupRequest) => any;
    }
    export interface CreateLogStreamRequest {
            /**
                * <p>The name of the log group.</p>
                */
            logGroupName: string | undefined;
            /**
                * <p>The name of the log stream.</p>
                */
            logStreamName: string | undefined;
    }
    export namespace CreateLogStreamRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateLogStreamRequest) => any;
    }
    /**
        * <p>The event was already logged.</p>
        */
    export class DataAlreadyAcceptedException extends __BaseException {
            readonly name: "DataAlreadyAcceptedException";
            readonly $fault: "client";
            expectedSequenceToken?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<DataAlreadyAcceptedException, __BaseException>);
    }
    export interface DeleteDestinationRequest {
            /**
                * <p>The name of the destination.</p>
                */
            destinationName: string | undefined;
    }
    export namespace DeleteDestinationRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteDestinationRequest) => any;
    }
    export interface DeleteLogGroupRequest {
            /**
                * <p>The name of the log group.</p>
                */
            logGroupName: string | undefined;
    }
    export namespace DeleteLogGroupRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteLogGroupRequest) => any;
    }
    export interface DeleteLogStreamRequest {
            /**
                * <p>The name of the log group.</p>
                */
            logGroupName: string | undefined;
            /**
                * <p>The name of the log stream.</p>
                */
            logStreamName: string | undefined;
    }
    export namespace DeleteLogStreamRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteLogStreamRequest) => any;
    }
    export interface DeleteMetricFilterRequest {
            /**
                * <p>The name of the log group.</p>
                */
            logGroupName: string | undefined;
            /**
                * <p>The name of the metric filter.</p>
                */
            filterName: string | undefined;
    }
    export namespace DeleteMetricFilterRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteMetricFilterRequest) => any;
    }
    export interface DeleteQueryDefinitionRequest {
            /**
                * <p>The ID of the query definition that you want to delete. You can use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DescribeQueryDefinitions.html">DescribeQueryDefinitions</a> to retrieve the
                *       IDs of your saved query definitions.</p>
                */
            queryDefinitionId: string | undefined;
    }
    export namespace DeleteQueryDefinitionRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteQueryDefinitionRequest) => any;
    }
    export interface DeleteQueryDefinitionResponse {
            /**
                * <p>A value of TRUE indicates that the operation succeeded. FALSE indicates that the operation
                *       failed.</p>
                */
            success?: boolean;
    }
    export namespace DeleteQueryDefinitionResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteQueryDefinitionResponse) => any;
    }
    export interface DeleteResourcePolicyRequest {
            /**
                * <p>The name of the policy to be revoked. This parameter is required.</p>
                */
            policyName?: string;
    }
    export namespace DeleteResourcePolicyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteResourcePolicyRequest) => any;
    }
    export interface DeleteRetentionPolicyRequest {
            /**
                * <p>The name of the log group.</p>
                */
            logGroupName: string | undefined;
    }
    export namespace DeleteRetentionPolicyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteRetentionPolicyRequest) => any;
    }
    export interface DeleteSubscriptionFilterRequest {
            /**
                * <p>The name of the log group.</p>
                */
            logGroupName: string | undefined;
            /**
                * <p>The name of the subscription filter.</p>
                */
            filterName: string | undefined;
    }
    export namespace DeleteSubscriptionFilterRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteSubscriptionFilterRequest) => any;
    }
    export interface DescribeDestinationsRequest {
            /**
                * <p>The prefix to match. If you don't specify a value, no prefix filter is applied.</p>
                */
            DestinationNamePrefix?: string;
            /**
                * <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
                */
            nextToken?: string;
            /**
                * <p>The maximum number of items returned. If you don't specify a value, the default is up to 50 items.</p>
                */
            limit?: number;
    }
    export namespace DescribeDestinationsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeDestinationsRequest) => any;
    }
    /**
        * <p>Represents a cross-account destination that receives subscription log events.</p>
        */
    export interface Destination {
            /**
                * <p>The name of the destination.</p>
                */
            destinationName?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of the physical target where the log events are
                *       delivered (for example, a Kinesis stream).</p>
                */
            targetArn?: string;
            /**
                * <p>A role for impersonation, used when delivering log events to the target.</p>
                */
            roleArn?: string;
            /**
                * <p>An IAM policy document that governs which Amazon Web Services accounts can create subscription filters
                *       against this destination.</p>
                */
            accessPolicy?: string;
            /**
                * <p>The ARN of this destination.</p>
                */
            arn?: string;
            /**
                * <p>The creation time of the destination, expressed as the number of milliseconds after Jan
                *       1, 1970 00:00:00 UTC.</p>
                */
            creationTime?: number;
    }
    export namespace Destination {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Destination) => any;
    }
    export interface DescribeDestinationsResponse {
            /**
                * <p>The destinations.</p>
                */
            destinations?: Destination[];
            /**
                * <p>The token for the next set of items to return. The token expires after 24 hours.</p>
                */
            nextToken?: string;
    }
    export namespace DescribeDestinationsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeDestinationsResponse) => any;
    }
    export enum ExportTaskStatusCode {
            CANCELLED = "CANCELLED",
            COMPLETED = "COMPLETED",
            FAILED = "FAILED",
            PENDING = "PENDING",
            PENDING_CANCEL = "PENDING_CANCEL",
            RUNNING = "RUNNING"
    }
    export interface DescribeExportTasksRequest {
            /**
                * <p>The ID of the export task. Specifying a task ID filters the results to zero or one export tasks.</p>
                */
            taskId?: string;
            /**
                * <p>The status code of the export task. Specifying a status code filters the results to zero or more export tasks.</p>
                */
            statusCode?: ExportTaskStatusCode | string;
            /**
                * <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
                */
            nextToken?: string;
            /**
                * <p>The maximum number of items returned. If you don't specify a value, the default is up to 50 items.</p>
                */
            limit?: number;
    }
    export namespace DescribeExportTasksRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeExportTasksRequest) => any;
    }
    /**
        * <p>Represents the status of an export task.</p>
        */
    export interface ExportTaskExecutionInfo {
            /**
                * <p>The creation time of the export task, expressed as the number of milliseconds after Jan
                *       1, 1970 00:00:00 UTC.</p>
                */
            creationTime?: number;
            /**
                * <p>The completion time of the export task, expressed as the number of milliseconds after
                *       Jan 1, 1970 00:00:00 UTC.</p>
                */
            completionTime?: number;
    }
    export namespace ExportTaskExecutionInfo {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ExportTaskExecutionInfo) => any;
    }
    /**
        * <p>Represents the status of an export task.</p>
        */
    export interface ExportTaskStatus {
            /**
                * <p>The status code of the export task.</p>
                */
            code?: ExportTaskStatusCode | string;
            /**
                * <p>The status message related to the status code.</p>
                */
            message?: string;
    }
    export namespace ExportTaskStatus {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ExportTaskStatus) => any;
    }
    /**
        * <p>Represents an export task.</p>
        */
    export interface ExportTask {
            /**
                * <p>The ID of the export task.</p>
                */
            taskId?: string;
            /**
                * <p>The name of the export task.</p>
                */
            taskName?: string;
            /**
                * <p>The name of the log group from which logs data was exported.</p>
                */
            logGroupName?: string;
            /**
                * <p>The start time, expressed as the number of milliseconds after Jan 1, 1970 00:00:00 UTC.
                *       Events with a timestamp before this time are not exported.</p>
                */
            from?: number;
            /**
                * <p>The end time, expressed as the number of milliseconds after Jan 1, 1970 00:00:00 UTC.
                *       Events with a timestamp later than this time are not exported.</p>
                */
            to?: number;
            /**
                * <p>The name of the S3 bucket to which the log data was exported.</p>
                */
            destination?: string;
            /**
                * <p>The prefix that was used as the start of Amazon S3 key for every object exported.</p>
                */
            destinationPrefix?: string;
            /**
                * <p>The status of the export task.</p>
                */
            status?: ExportTaskStatus;
            /**
                * <p>Execution information about the export task.</p>
                */
            executionInfo?: ExportTaskExecutionInfo;
    }
    export namespace ExportTask {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ExportTask) => any;
    }
    export interface DescribeExportTasksResponse {
            /**
                * <p>The export tasks.</p>
                */
            exportTasks?: ExportTask[];
            /**
                * <p>The token for the next set of items to return. The token expires after 24 hours.</p>
                */
            nextToken?: string;
    }
    export namespace DescribeExportTasksResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeExportTasksResponse) => any;
    }
    export interface DescribeLogGroupsRequest {
            /**
                * <p>The prefix to match.</p>
                */
            logGroupNamePrefix?: string;
            /**
                * <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
                */
            nextToken?: string;
            /**
                * <p>The maximum number of items returned. If you don't specify a value, the default is up to 50 items.</p>
                */
            limit?: number;
    }
    export namespace DescribeLogGroupsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeLogGroupsRequest) => any;
    }
    /**
        * <p>Represents a log group.</p>
        */
    export interface LogGroup {
            /**
                * <p>The name of the log group.</p>
                */
            logGroupName?: string;
            /**
                * <p>The creation time of the log group, expressed as the number of milliseconds after Jan
                *       1, 1970 00:00:00 UTC.</p>
                */
            creationTime?: number;
            /**
                * <p>The number of days to retain the log events in the specified log group.
                *       Possible values are: 1, 3, 5, 7, 14, 30, 60, 90, 120, 150, 180, 365, 400, 545, 731, 1827, 2192, 2557, 2922, 3288, and 3653.</p>
                *          <p>To set a log group to never have log events expire, use
                *     <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DeleteRetentionPolicy.html">DeleteRetentionPolicy</a>.
                *   </p>
                */
            retentionInDays?: number;
            /**
                * <p>The number of metric filters.</p>
                */
            metricFilterCount?: number;
            /**
                * <p>The Amazon Resource Name (ARN) of the log group.</p>
                */
            arn?: string;
            /**
                * <p>The number of bytes stored.</p>
                */
            storedBytes?: number;
            /**
                * <p>The Amazon Resource Name (ARN) of the CMK to use when encrypting log data.</p>
                */
            kmsKeyId?: string;
    }
    export namespace LogGroup {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: LogGroup) => any;
    }
    export interface DescribeLogGroupsResponse {
            /**
                * <p>The log groups.</p>
                *          <p>If the <code>retentionInDays</code> value is not included for a log group, then that log group
                *     is set to have its events never expire.</p>
                */
            logGroups?: LogGroup[];
            /**
                * <p>The token for the next set of items to return. The token expires after 24 hours.</p>
                */
            nextToken?: string;
    }
    export namespace DescribeLogGroupsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeLogGroupsResponse) => any;
    }
    export enum OrderBy {
            LastEventTime = "LastEventTime",
            LogStreamName = "LogStreamName"
    }
    export interface DescribeLogStreamsRequest {
            /**
                * <p>The name of the log group.</p>
                */
            logGroupName: string | undefined;
            /**
                * <p>The prefix to match.</p>
                *          <p>If <code>orderBy</code> is <code>LastEventTime</code>, you cannot specify this
                *       parameter.</p>
                */
            logStreamNamePrefix?: string;
            /**
                * <p>If the value is <code>LogStreamName</code>, the results are ordered by log stream name.
                *       If the value is <code>LastEventTime</code>, the results are ordered by the event time.
                *       The default value is <code>LogStreamName</code>.</p>
                *          <p>If you order the results by event time, you cannot specify the <code>logStreamNamePrefix</code> parameter.</p>
                *          <p>
                *             <code>lastEventTimestamp</code> represents the time of the most recent log event in the
                *       log stream in CloudWatch Logs. This number is expressed as the number of milliseconds after
                *       Jan 1, 1970 00:00:00 UTC. <code>lastEventTimestamp</code> updates on an eventual consistency
                *       basis. It typically updates in less than an hour from ingestion, but in rare situations might
                *       take longer.</p>
                */
            orderBy?: OrderBy | string;
            /**
                * <p>If the value is true, results are returned in descending order.
                *       If the value is to false, results are returned in ascending order.
                *       The default value is false.</p>
                */
            descending?: boolean;
            /**
                * <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
                */
            nextToken?: string;
            /**
                * <p>The maximum number of items returned. If you don't specify a value, the default is up to 50 items.</p>
                */
            limit?: number;
    }
    export namespace DescribeLogStreamsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeLogStreamsRequest) => any;
    }
    /**
        * <p>Represents a log stream, which is a sequence of log events from
        *       a single emitter of logs.</p>
        */
    export interface LogStream {
            /**
                * <p>The name of the log stream.</p>
                */
            logStreamName?: string;
            /**
                * <p>The creation time of the stream, expressed as the number of milliseconds after Jan 1,
                *       1970 00:00:00 UTC.</p>
                */
            creationTime?: number;
            /**
                * <p>The time of the first event, expressed as the number of milliseconds after Jan 1, 1970
                *       00:00:00 UTC.</p>
                */
            firstEventTimestamp?: number;
            /**
                * <p>The time of the most recent log event in the log stream in CloudWatch Logs. This number
                *       is expressed as the number of milliseconds after Jan 1, 1970 00:00:00 UTC. The
                *         <code>lastEventTime</code> value updates on an eventual consistency basis. It typically
                *       updates in less than an hour from ingestion, but in rare situations might take
                *       longer.</p>
                */
            lastEventTimestamp?: number;
            /**
                * <p>The ingestion time, expressed as the number of milliseconds after Jan 1, 1970 00:00:00
                *       UTC.</p>
                */
            lastIngestionTime?: number;
            /**
                * <p>The sequence token.</p>
                */
            uploadSequenceToken?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of the log stream.</p>
                */
            arn?: string;
            /**
                * @deprecated
                *
                * <p>The number of bytes stored.</p>
                *          <p>
                *             <b>Important:</b> On June 17, 2019, this parameter was
                *       deprecated for log streams, and is always reported as zero. This change applies only to log
                *       streams. The <code>storedBytes</code> parameter for log groups is not affected.</p>
                */
            storedBytes?: number;
    }
    export namespace LogStream {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: LogStream) => any;
    }
    export interface DescribeLogStreamsResponse {
            /**
                * <p>The log streams.</p>
                */
            logStreams?: LogStream[];
            /**
                * <p>The token for the next set of items to return. The token expires after 24 hours.</p>
                */
            nextToken?: string;
    }
    export namespace DescribeLogStreamsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeLogStreamsResponse) => any;
    }
    export interface DescribeMetricFiltersRequest {
            /**
                * <p>The name of the log group.</p>
                */
            logGroupName?: string;
            /**
                * <p>The prefix to match. CloudWatch Logs uses the value you set here
                *     only if you also include the <code>logGroupName</code> parameter in your request.</p>
                */
            filterNamePrefix?: string;
            /**
                * <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
                */
            nextToken?: string;
            /**
                * <p>The maximum number of items returned. If you don't specify a value, the default is up to 50 items.</p>
                */
            limit?: number;
            /**
                * <p>Filters results to include only those with the specified metric name. If you include this parameter in your request, you
                *     must also include the <code>metricNamespace</code> parameter.</p>
                */
            metricName?: string;
            /**
                * <p>Filters results to include only those in the specified namespace. If you include this parameter in your request, you
                *     must also include the <code>metricName</code> parameter.</p>
                */
            metricNamespace?: string;
    }
    export namespace DescribeMetricFiltersRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeMetricFiltersRequest) => any;
    }
    export enum StandardUnit {
            Bits = "Bits",
            BitsSecond = "Bits/Second",
            Bytes = "Bytes",
            BytesSecond = "Bytes/Second",
            Count = "Count",
            CountSecond = "Count/Second",
            Gigabits = "Gigabits",
            GigabitsSecond = "Gigabits/Second",
            Gigabytes = "Gigabytes",
            GigabytesSecond = "Gigabytes/Second",
            Kilobits = "Kilobits",
            KilobitsSecond = "Kilobits/Second",
            Kilobytes = "Kilobytes",
            KilobytesSecond = "Kilobytes/Second",
            Megabits = "Megabits",
            MegabitsSecond = "Megabits/Second",
            Megabytes = "Megabytes",
            MegabytesSecond = "Megabytes/Second",
            Microseconds = "Microseconds",
            Milliseconds = "Milliseconds",
            None = "None",
            Percent = "Percent",
            Seconds = "Seconds",
            Terabits = "Terabits",
            TerabitsSecond = "Terabits/Second",
            Terabytes = "Terabytes",
            TerabytesSecond = "Terabytes/Second"
    }
    /**
        * <p>Indicates how to transform ingested log events to metric data in a CloudWatch
        *       metric.</p>
        */
    export interface MetricTransformation {
            /**
                * <p>The name of the CloudWatch metric.</p>
                */
            metricName: string | undefined;
            /**
                * <p>A custom namespace to contain your metric in CloudWatch. Use namespaces to group together metrics
                *       that are similar. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html#Namespace">Namespaces</a>.</p>
                */
            metricNamespace: string | undefined;
            /**
                * <p>The value to publish to the CloudWatch metric when a filter pattern matches a log event.</p>
                */
            metricValue: string | undefined;
            /**
                * <p>(Optional) The value to emit when a filter pattern does not match a log event.
                *       This value can be null.</p>
                */
            defaultValue?: number;
            /**
                * <p>The fields to use as dimensions for the metric. One metric filter can include
                *     as many as three dimensions.</p>
                *          <important>
                *             <p>Metrics extracted from log events are charged as custom metrics.
                *       To prevent unexpected high charges, do not specify high-cardinality fields such as
                *       <code>IPAddress</code> or <code>requestID</code> as dimensions. Each different value
                *       found for
                *       a dimension is treated as a separate metric and accrues charges as a separate custom metric.
                *     </p>
                *             <p>To help prevent accidental high charges, Amazon disables a metric filter
                *         if it generates 1000 different name/value pairs for the dimensions that you
                *         have specified within a certain amount of time.</p>
                *             <p>You can also set up a billing alarm to alert you if your charges are higher than
                *         expected. For more information,
                *         see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/monitor_estimated_charges_with_cloudwatch.html">
                *           Creating a Billing Alarm to Monitor Your Estimated Amazon Web Services Charges</a>.
                *        </p>
                *          </important>
                */
            dimensions?: Record<string, string>;
            /**
                * <p>The unit to assign to the metric. If you omit this, the unit is set as <code>None</code>.</p>
                */
            unit?: StandardUnit | string;
    }
    export namespace MetricTransformation {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: MetricTransformation) => any;
    }
    /**
        * <p>Metric filters express how CloudWatch Logs would extract metric observations
        *       from ingested log events and transform them into metric data in a CloudWatch metric.</p>
        */
    export interface MetricFilter {
            /**
                * <p>The name of the metric filter.</p>
                */
            filterName?: string;
            /**
                * <p>A symbolic description of how CloudWatch Logs should interpret the data in each log
                *       event. For example, a log event can contain timestamps, IP addresses, strings, and so on. You
                *       use the filter pattern to specify what to look for in the log event message.</p>
                */
            filterPattern?: string;
            /**
                * <p>The metric transformations.</p>
                */
            metricTransformations?: MetricTransformation[];
            /**
                * <p>The creation time of the metric filter, expressed as the number of milliseconds after
                *       Jan 1, 1970 00:00:00 UTC.</p>
                */
            creationTime?: number;
            /**
                * <p>The name of the log group.</p>
                */
            logGroupName?: string;
    }
    export namespace MetricFilter {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: MetricFilter) => any;
    }
    export interface DescribeMetricFiltersResponse {
            /**
                * <p>The metric filters.</p>
                */
            metricFilters?: MetricFilter[];
            /**
                * <p>The token for the next set of items to return. The token expires after 24 hours.</p>
                */
            nextToken?: string;
    }
    export namespace DescribeMetricFiltersResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeMetricFiltersResponse) => any;
    }
    export enum QueryStatus {
            Cancelled = "Cancelled",
            Complete = "Complete",
            Failed = "Failed",
            Running = "Running",
            Scheduled = "Scheduled",
            Timeout = "Timeout",
            Unknown = "Unknown"
    }
    export interface DescribeQueriesRequest {
            /**
                * <p>Limits the returned queries to only those for the specified log group.</p>
                */
            logGroupName?: string;
            /**
                * <p>Limits the returned queries to only those that have the specified status. Valid values are <code>Cancelled</code>,
                *       <code>Complete</code>, <code>Failed</code>, <code>Running</code>, and <code>Scheduled</code>.</p>
                */
            status?: QueryStatus | string;
            /**
                * <p>Limits the number of returned queries to the specified number.</p>
                */
            maxResults?: number;
            /**
                * <p>The token for the next set of items to return. The token expires after 24 hours.</p>
                */
            nextToken?: string;
    }
    export namespace DescribeQueriesRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeQueriesRequest) => any;
    }
    /**
        * <p>Information about one CloudWatch Logs Insights query that matches the request in a <code>DescribeQueries</code> operation. </p>
        */
    export interface QueryInfo {
            /**
                * <p>The unique ID number of this query.</p>
                */
            queryId?: string;
            /**
                * <p>The query string used in this query.</p>
                */
            queryString?: string;
            /**
                * <p>The status of this query. Possible values are <code>Cancelled</code>,
                *       <code>Complete</code>, <code>Failed</code>, <code>Running</code>, <code>Scheduled</code>, and <code>Unknown</code>.</p>
                */
            status?: QueryStatus | string;
            /**
                * <p>The date and time that this query was created.</p>
                */
            createTime?: number;
            /**
                * <p>The name of the log group scanned by this query.</p>
                */
            logGroupName?: string;
    }
    export namespace QueryInfo {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: QueryInfo) => any;
    }
    export interface DescribeQueriesResponse {
            /**
                * <p>The list of queries that match the request.</p>
                */
            queries?: QueryInfo[];
            /**
                * <p>The token for the next set of items to return. The token expires after 24 hours.</p>
                */
            nextToken?: string;
    }
    export namespace DescribeQueriesResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeQueriesResponse) => any;
    }
    export interface DescribeQueryDefinitionsRequest {
            /**
                * <p>Use this parameter to filter your results to only the query definitions that have names that start with the prefix you specify.</p>
                */
            queryDefinitionNamePrefix?: string;
            /**
                * <p>Limits the number of returned query definitions to the specified number.</p>
                */
            maxResults?: number;
            /**
                * <p>The token for the next set of items to return. The token expires after 24 hours.</p>
                */
            nextToken?: string;
    }
    export namespace DescribeQueryDefinitionsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeQueryDefinitionsRequest) => any;
    }
    /**
        * <p>This structure contains details about a saved CloudWatch Logs Insights query definition.</p>
        */
    export interface QueryDefinition {
            /**
                * <p>The unique ID of the query definition.</p>
                */
            queryDefinitionId?: string;
            /**
                * <p>The name of the query definition.</p>
                */
            name?: string;
            /**
                * <p>The query string to use for this definition.
                *       For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CWL_QuerySyntax.html">CloudWatch Logs Insights Query Syntax</a>.</p>
                */
            queryString?: string;
            /**
                * <p>The date that the query definition was most recently modified.</p>
                */
            lastModified?: number;
            /**
                * <p>If this query definition contains a list of log groups that it is limited to, that list appears here.</p>
                */
            logGroupNames?: string[];
    }
    export namespace QueryDefinition {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: QueryDefinition) => any;
    }
    export interface DescribeQueryDefinitionsResponse {
            /**
                * <p>The list of query definitions that match your request.</p>
                */
            queryDefinitions?: QueryDefinition[];
            /**
                * <p>The token for the next set of items to return. The token expires after 24 hours.</p>
                */
            nextToken?: string;
    }
    export namespace DescribeQueryDefinitionsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeQueryDefinitionsResponse) => any;
    }
    export interface DescribeResourcePoliciesRequest {
            /**
                * <p>The token for the next set of items to return. The token expires after 24 hours.</p>
                */
            nextToken?: string;
            /**
                * <p>The maximum number of resource policies to be displayed with one call of this API.</p>
                */
            limit?: number;
    }
    export namespace DescribeResourcePoliciesRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeResourcePoliciesRequest) => any;
    }
    /**
        * <p>A policy enabling one or more entities to put logs to a log group in this account.</p>
        */
    export interface ResourcePolicy {
            /**
                * <p>The name of the resource policy.</p>
                */
            policyName?: string;
            /**
                * <p>The details of the policy.</p>
                */
            policyDocument?: string;
            /**
                * <p>Timestamp showing when this policy was last updated, expressed as the number of
                *       milliseconds after Jan 1, 1970 00:00:00 UTC.</p>
                */
            lastUpdatedTime?: number;
    }
    export namespace ResourcePolicy {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResourcePolicy) => any;
    }
    export interface DescribeResourcePoliciesResponse {
            /**
                * <p>The resource policies that exist in this account.</p>
                */
            resourcePolicies?: ResourcePolicy[];
            /**
                * <p>The token for the next set of items to return. The token expires after 24 hours.</p>
                */
            nextToken?: string;
    }
    export namespace DescribeResourcePoliciesResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeResourcePoliciesResponse) => any;
    }
    export interface DescribeSubscriptionFiltersRequest {
            /**
                * <p>The name of the log group.</p>
                */
            logGroupName: string | undefined;
            /**
                * <p>The prefix to match. If you don't specify a value, no prefix filter is applied.</p>
                */
            filterNamePrefix?: string;
            /**
                * <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
                */
            nextToken?: string;
            /**
                * <p>The maximum number of items returned. If you don't specify a value, the default is up to 50 items.</p>
                */
            limit?: number;
    }
    export namespace DescribeSubscriptionFiltersRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeSubscriptionFiltersRequest) => any;
    }
    export enum Distribution {
            ByLogStream = "ByLogStream",
            Random = "Random"
    }
    /**
        * <p>Represents a subscription filter.</p>
        */
    export interface SubscriptionFilter {
            /**
                * <p>The name of the subscription filter.</p>
                */
            filterName?: string;
            /**
                * <p>The name of the log group.</p>
                */
            logGroupName?: string;
            /**
                * <p>A symbolic description of how CloudWatch Logs should interpret the data in each log
                *       event. For example, a log event can contain timestamps, IP addresses, strings, and so on. You
                *       use the filter pattern to specify what to look for in the log event message.</p>
                */
            filterPattern?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of the destination.</p>
                */
            destinationArn?: string;
            /**
                * <p></p>
                */
            roleArn?: string;
            /**
                * <p>The method used to distribute log data to the destination, which can be either
                *       random or grouped by log stream.</p>
                */
            distribution?: Distribution | string;
            /**
                * <p>The creation time of the subscription filter, expressed as the number of milliseconds
                *       after Jan 1, 1970 00:00:00 UTC.</p>
                */
            creationTime?: number;
    }
    export namespace SubscriptionFilter {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SubscriptionFilter) => any;
    }
    export interface DescribeSubscriptionFiltersResponse {
            /**
                * <p>The subscription filters.</p>
                */
            subscriptionFilters?: SubscriptionFilter[];
            /**
                * <p>The token for the next set of items to return. The token expires after 24 hours.</p>
                */
            nextToken?: string;
    }
    export namespace DescribeSubscriptionFiltersResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeSubscriptionFiltersResponse) => any;
    }
    export interface DisassociateKmsKeyRequest {
            /**
                * <p>The name of the log group.</p>
                */
            logGroupName: string | undefined;
    }
    export namespace DisassociateKmsKeyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DisassociateKmsKeyRequest) => any;
    }
    /**
        * <p>Represents a matched event.</p>
        */
    export interface FilteredLogEvent {
            /**
                * <p>The name of the log stream to which this event belongs.</p>
                */
            logStreamName?: string;
            /**
                * <p>The time the event occurred, expressed as the number of milliseconds after Jan 1, 1970
                *       00:00:00 UTC.</p>
                */
            timestamp?: number;
            /**
                * <p>The data contained in the log event.</p>
                */
            message?: string;
            /**
                * <p>The time the event was ingested, expressed as the number of milliseconds after Jan 1,
                *       1970 00:00:00 UTC.</p>
                */
            ingestionTime?: number;
            /**
                * <p>The ID of the event.</p>
                */
            eventId?: string;
    }
    export namespace FilteredLogEvent {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: FilteredLogEvent) => any;
    }
    export interface FilterLogEventsRequest {
            /**
                * <p>The name of the log group to search.</p>
                */
            logGroupName: string | undefined;
            /**
                * <p>Filters the results to only logs from the log streams in this list.</p>
                *          <p>If you specify a value for both <code>logStreamNamePrefix</code> and <code>logStreamNames</code>, the action
                *       returns an <code>InvalidParameterException</code> error.</p>
                */
            logStreamNames?: string[];
            /**
                * <p>Filters the results to include only events from log streams that have names starting with this prefix.</p>
                *          <p>If you specify a value for both <code>logStreamNamePrefix</code> and <code>logStreamNames</code>, but the value for
                *       <code>logStreamNamePrefix</code> does not match any log stream names specified in <code>logStreamNames</code>, the action
                *     returns an <code>InvalidParameterException</code> error.</p>
                */
            logStreamNamePrefix?: string;
            /**
                * <p>The start of the time range, expressed as the number of milliseconds after Jan 1, 1970
                *       00:00:00 UTC. Events with a timestamp before this time are not returned.</p>
                */
            startTime?: number;
            /**
                * <p>The end of the time range, expressed as the number of milliseconds after Jan 1, 1970
                *       00:00:00 UTC. Events with a timestamp later than this time are not returned.</p>
                */
            endTime?: number;
            /**
                * <p>The filter pattern to use. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/FilterAndPatternSyntax.html">Filter and Pattern Syntax</a>.</p>
                *          <p>If not provided, all the events are matched.</p>
                */
            filterPattern?: string;
            /**
                * <p>The token for the next set of events to return. (You received this token from a previous call.)</p>
                */
            nextToken?: string;
            /**
                * <p>The maximum number of events to return. The default is 10,000 events.</p>
                */
            limit?: number;
            /**
                * @deprecated
                *
                * <p>If the value is true, the operation makes a best effort to provide responses that
                *       contain events from multiple log streams within the log group, interleaved in a single
                *       response. If the value is false, all the matched log events in the first log stream are
                *       searched first, then those in the next log stream, and so on. The default is false.</p>
                *          <p>
                *             <b>Important:</b> Starting on June 17, 2019, this parameter
                *       is ignored and the value is assumed to be true. The response from this operation always
                *       interleaves events from multiple log streams within a log group.</p>
                */
            interleaved?: boolean;
    }
    export namespace FilterLogEventsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: FilterLogEventsRequest) => any;
    }
    /**
        * <p>Represents the search status of a log stream.</p>
        */
    export interface SearchedLogStream {
            /**
                * <p>The name of the log stream.</p>
                */
            logStreamName?: string;
            /**
                * <p>Indicates whether all the events in this log stream were searched.</p>
                */
            searchedCompletely?: boolean;
    }
    export namespace SearchedLogStream {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SearchedLogStream) => any;
    }
    export interface FilterLogEventsResponse {
            /**
                * <p>The matched events.</p>
                */
            events?: FilteredLogEvent[];
            /**
                * <p>
                *             <b>IMPORTANT</b> Starting on May 15, 2020,
                *     this parameter will be deprecated. This parameter will be an empty list
                *     after the deprecation occurs.</p>
                *          <p>Indicates which log streams have been searched and whether each has been searched completely.</p>
                */
            searchedLogStreams?: SearchedLogStream[];
            /**
                * <p>The token to use when requesting the next set of items. The token expires after 24 hours.</p>
                */
            nextToken?: string;
    }
    export namespace FilterLogEventsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: FilterLogEventsResponse) => any;
    }
    export interface GetLogEventsRequest {
            /**
                * <p>The name of the log group.</p>
                */
            logGroupName: string | undefined;
            /**
                * <p>The name of the log stream.</p>
                */
            logStreamName: string | undefined;
            /**
                * <p>The start of the time range, expressed as the number of milliseconds after Jan 1, 1970
                *       00:00:00 UTC. Events with a timestamp equal to this time or later than this time are included.
                *       Events with a timestamp earlier than this time are not included.</p>
                */
            startTime?: number;
            /**
                * <p>The end of the time range, expressed as the number of milliseconds after Jan 1, 1970
                *       00:00:00 UTC. Events with a timestamp equal to or later than this time are not
                *       included.</p>
                */
            endTime?: number;
            /**
                * <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
                */
            nextToken?: string;
            /**
                * <p>The maximum number of log events returned. If you don't specify a value, the maximum is
                *       as many log events as can fit in a response size of 1 MB, up to 10,000 log events.</p>
                */
            limit?: number;
            /**
                * <p>If the value is true, the earliest log events are returned first.
                *       If the value is false, the latest log events are returned first.
                *       The default value is false.</p>
                *          <p>If you are using a previous <code>nextForwardToken</code> value as the <code>nextToken</code> in this operation,
                *       you must specify <code>true</code> for <code>startFromHead</code>.</p>
                */
            startFromHead?: boolean;
    }
    export namespace GetLogEventsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetLogEventsRequest) => any;
    }
    /**
        * <p>Represents a log event.</p>
        */
    export interface OutputLogEvent {
            /**
                * <p>The time the event occurred, expressed as the number of milliseconds after Jan 1, 1970
                *       00:00:00 UTC.</p>
                */
            timestamp?: number;
            /**
                * <p>The data contained in the log event.</p>
                */
            message?: string;
            /**
                * <p>The time the event was ingested, expressed as the number of milliseconds after Jan 1,
                *       1970 00:00:00 UTC.</p>
                */
            ingestionTime?: number;
    }
    export namespace OutputLogEvent {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: OutputLogEvent) => any;
    }
    export interface GetLogEventsResponse {
            /**
                * <p>The events.</p>
                */
            events?: OutputLogEvent[];
            /**
                * <p>The token for the next set of items in the forward direction. The token expires after
                *       24 hours. If you have reached the end of the stream, it returns the same token you passed
                *       in.</p>
                */
            nextForwardToken?: string;
            /**
                * <p>The token for the next set of items in the backward direction. The token expires after
                *       24 hours. This token is never null. If you have reached the end of the stream, it returns the
                *       same token you passed in.</p>
                */
            nextBackwardToken?: string;
    }
    export namespace GetLogEventsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetLogEventsResponse) => any;
    }
    export interface GetLogGroupFieldsRequest {
            /**
                * <p>The name of the log group to search.</p>
                */
            logGroupName: string | undefined;
            /**
                * <p>The time to set as the center of the query. If you specify <code>time</code>, the 15 minutes
                *        before this time are queries. If you omit <code>time</code> the 8
                *       minutes before and 8 minutes after this time are searched.</p>
                *          <p>The <code>time</code> value is specified as epoch time, the number of seconds since
                *       January 1, 1970, 00:00:00 UTC.</p>
                */
            time?: number;
    }
    export namespace GetLogGroupFieldsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetLogGroupFieldsRequest) => any;
    }
    /**
        * <p>The fields contained in log events found by a <code>GetLogGroupFields</code> operation,
        *       along with the percentage of queried log events in which each field appears.</p>
        */
    export interface LogGroupField {
            /**
                * <p>The name of a log field.</p>
                */
            name?: string;
            /**
                * <p>The percentage of log events queried that contained the field.</p>
                */
            percent?: number;
    }
    export namespace LogGroupField {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: LogGroupField) => any;
    }
    export interface GetLogGroupFieldsResponse {
            /**
                * <p>The array of fields found in the query. Each object in the array contains the name of the field, along with the
                *     percentage of time it appeared in the log events that were queried.</p>
                */
            logGroupFields?: LogGroupField[];
    }
    export namespace GetLogGroupFieldsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetLogGroupFieldsResponse) => any;
    }
    export interface GetLogRecordRequest {
            /**
                * <p>The pointer corresponding to the log event record you want to retrieve. You get this from
                *       the response of a <code>GetQueryResults</code> operation. In that response, the value of the
                *         <code>@ptr</code> field for a log event is the value to use as <code>logRecordPointer</code>
                *       to retrieve that complete log event record.</p>
                */
            logRecordPointer: string | undefined;
    }
    export namespace GetLogRecordRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetLogRecordRequest) => any;
    }
    export interface GetLogRecordResponse {
            /**
                * <p>The requested log event, as a JSON string.</p>
                */
            logRecord?: Record<string, string>;
    }
    export namespace GetLogRecordResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetLogRecordResponse) => any;
    }
    export interface GetQueryResultsRequest {
            /**
                * <p>The ID number of the query.</p>
                */
            queryId: string | undefined;
    }
    export namespace GetQueryResultsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetQueryResultsRequest) => any;
    }
    /**
        * <p>Contains one field from one log event returned by a CloudWatch Logs Insights query, along with the value of that field.</p>
        *          <p>For more information about the fields that are
        *       generated by CloudWatch logs, see
        *       <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CWL_AnalyzeLogData-discoverable-fields.html">Supported Logs and Discovered Fields</a>.</p>
        */
    export interface ResultField {
            /**
                * <p>The log event field.</p>
                */
            field?: string;
            /**
                * <p>The value of this field.</p>
                */
            value?: string;
    }
    export namespace ResultField {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResultField) => any;
    }
    /**
        * <p>Contains the number of log events scanned by the query, the number of log events that matched the
        *       query criteria, and the total number of bytes in the log events that were scanned.</p>
        */
    export interface QueryStatistics {
            /**
                * <p>The number of log events that matched the query string.</p>
                */
            recordsMatched?: number;
            /**
                * <p>The total number of log events scanned during the query.</p>
                */
            recordsScanned?: number;
            /**
                * <p>The total number of bytes in the log events scanned during the query.</p>
                */
            bytesScanned?: number;
    }
    export namespace QueryStatistics {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: QueryStatistics) => any;
    }
    export interface GetQueryResultsResponse {
            /**
                * <p>The log events that matched the query criteria during the most recent time it ran.</p>
                *          <p>The <code>results</code> value is an array of arrays. Each log event is one object in the
                *       top-level array. Each of these log event objects is an array of
                *         <code>field</code>/<code>value</code> pairs.</p>
                */
            results?: ResultField[][];
            /**
                * <p>Includes the number of log events scanned by the query, the number of log events that matched the
                *     query criteria, and the total number of bytes in the log events that were scanned. These values
                *     reflect the full raw results of the query.</p>
                */
            statistics?: QueryStatistics;
            /**
                * <p>The status of the most recent running of the query. Possible values are <code>Cancelled</code>,
                *       <code>Complete</code>, <code>Failed</code>, <code>Running</code>, <code>Scheduled</code>,
                *       <code>Timeout</code>, and <code>Unknown</code>.</p>
                *          <p>Queries time out after 15 minutes of execution. To avoid having your queries time out,
                *       reduce the time range being searched or partition your query into a number of queries.</p>
                */
            status?: QueryStatus | string;
    }
    export namespace GetQueryResultsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetQueryResultsResponse) => any;
    }
    /**
        * <p>Represents a log event, which is a record of activity that was recorded
        *       by the application or resource being monitored.</p>
        */
    export interface InputLogEvent {
            /**
                * <p>The time the event occurred, expressed as the number of milliseconds after Jan 1, 1970
                *       00:00:00 UTC.</p>
                */
            timestamp: number | undefined;
            /**
                * <p>The raw event message.</p>
                */
            message: string | undefined;
    }
    export namespace InputLogEvent {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: InputLogEvent) => any;
    }
    /**
        * <p>The sequence token is not valid. You can get the correct sequence token in
        *       the <code>expectedSequenceToken</code> field in the <code>InvalidSequenceTokenException</code>
        *     message. </p>
        */
    export class InvalidSequenceTokenException extends __BaseException {
            readonly name: "InvalidSequenceTokenException";
            readonly $fault: "client";
            expectedSequenceToken?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidSequenceTokenException, __BaseException>);
    }
    export interface ListTagsLogGroupRequest {
            /**
                * <p>The name of the log group.</p>
                */
            logGroupName: string | undefined;
    }
    export namespace ListTagsLogGroupRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTagsLogGroupRequest) => any;
    }
    export interface ListTagsLogGroupResponse {
            /**
                * <p>The tags for the log group.</p>
                */
            tags?: Record<string, string>;
    }
    export namespace ListTagsLogGroupResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTagsLogGroupResponse) => any;
    }
    export interface PutDestinationRequest {
            /**
                * <p>A name for the destination.</p>
                */
            destinationName: string | undefined;
            /**
                * <p>The ARN of an Amazon Kinesis stream to which to deliver matching log events.</p>
                */
            targetArn: string | undefined;
            /**
                * <p>The ARN of an IAM role that grants CloudWatch Logs permissions to call the Amazon
                *       Kinesis <code>PutRecord</code> operation on the destination stream.</p>
                */
            roleArn: string | undefined;
    }
    export namespace PutDestinationRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutDestinationRequest) => any;
    }
    export interface PutDestinationResponse {
            /**
                * <p>The destination.</p>
                */
            destination?: Destination;
    }
    export namespace PutDestinationResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutDestinationResponse) => any;
    }
    export interface PutDestinationPolicyRequest {
            /**
                * <p>A name for an existing destination.</p>
                */
            destinationName: string | undefined;
            /**
                * <p>An IAM policy document that authorizes cross-account users to deliver their log events
                *       to the associated destination. This can be up to 5120 bytes.</p>
                */
            accessPolicy: string | undefined;
            /**
                * <p>Specify true if you are updating an existing destination policy to grant permission to
                *     an organization ID instead of granting permission to individual AWS accounts. Before
                *     you update a destination policy this way, you must first update the subscription
                *     filters in the accounts that send logs to this destination. If you do not, the subscription
                *     filters might stop working. By specifying <code>true</code>
                *       for <code>forceUpdate</code>, you are affirming that you have already updated the subscription
                *       filters.
                *     For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Cross-Account-Log_Subscription-Update.html">
                *       Updating an existing cross-account subscription</a>
                *          </p>
                *          <p>If you omit this parameter, the default of <code>false</code> is used.</p>
                */
            forceUpdate?: boolean;
    }
    export namespace PutDestinationPolicyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutDestinationPolicyRequest) => any;
    }
    export interface PutLogEventsRequest {
            /**
                * <p>The name of the log group.</p>
                */
            logGroupName: string | undefined;
            /**
                * <p>The name of the log stream.</p>
                */
            logStreamName: string | undefined;
            /**
                * <p>The log events.</p>
                */
            logEvents: InputLogEvent[] | undefined;
            /**
                * <p>The sequence token obtained from the response of the previous <code>PutLogEvents</code>
                *       call. An upload in a newly created log stream does not require a sequence token. You can also
                *       get the sequence token using <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DescribeLogStreams.html">DescribeLogStreams</a>. If you call <code>PutLogEvents</code> twice within a narrow
                *       time period using the same value for <code>sequenceToken</code>, both calls might be
                *       successful or one might be rejected.</p>
                */
            sequenceToken?: string;
    }
    export namespace PutLogEventsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutLogEventsRequest) => any;
    }
    /**
        * <p>Represents the rejected events.</p>
        */
    export interface RejectedLogEventsInfo {
            /**
                * <p>The log events that are too new.</p>
                */
            tooNewLogEventStartIndex?: number;
            /**
                * <p>The log events that are too old.</p>
                */
            tooOldLogEventEndIndex?: number;
            /**
                * <p>The expired log events.</p>
                */
            expiredLogEventEndIndex?: number;
    }
    export namespace RejectedLogEventsInfo {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RejectedLogEventsInfo) => any;
    }
    export interface PutLogEventsResponse {
            /**
                * <p>The next sequence token.</p>
                */
            nextSequenceToken?: string;
            /**
                * <p>The rejected events.</p>
                */
            rejectedLogEventsInfo?: RejectedLogEventsInfo;
    }
    export namespace PutLogEventsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutLogEventsResponse) => any;
    }
    /**
        * <p>The most likely cause is an invalid Amazon Web Services access key ID or secret key.</p>
        */
    export class UnrecognizedClientException extends __BaseException {
            readonly name: "UnrecognizedClientException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<UnrecognizedClientException, __BaseException>);
    }
    export interface PutMetricFilterRequest {
            /**
                * <p>The name of the log group.</p>
                */
            logGroupName: string | undefined;
            /**
                * <p>A name for the metric filter.</p>
                */
            filterName: string | undefined;
            /**
                * <p>A filter pattern for extracting metric data out of ingested log events.</p>
                */
            filterPattern: string | undefined;
            /**
                * <p>A collection of information that defines how metric data gets emitted.</p>
                */
            metricTransformations: MetricTransformation[] | undefined;
    }
    export namespace PutMetricFilterRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutMetricFilterRequest) => any;
    }
    export interface PutQueryDefinitionRequest {
            /**
                * <p>A name for the query definition. If you are saving a lot of query definitions, we
                *       recommend that you name them so that you can easily find the ones you want by using the first
                *       part of the name as a filter in the <code>queryDefinitionNamePrefix</code> parameter of <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DescribeQueryDefinitions.html">DescribeQueryDefinitions</a>.</p>
                */
            name: string | undefined;
            /**
                * <p>If you are updating a query definition, use this parameter to specify the ID of the query
                *       definition that you want to update. You can use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DescribeQueryDefinitions.html">DescribeQueryDefinitions</a> to retrieve the IDs of your saved query
                *       definitions.</p>
                *          <p>If you are creating a query definition, do not specify this parameter. CloudWatch
                *       generates a unique ID for the new query definition and include it in the response to this
                *       operation.</p>
                */
            queryDefinitionId?: string;
            /**
                * <p>Use this parameter to include specific log groups as part of your query definition.</p>
                *          <p>If you are updating a query definition and you omit this parameter, then the updated
                *       definition will contain no log groups.</p>
                */
            logGroupNames?: string[];
            /**
                * <p>The query string to use for this definition.
                *       For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CWL_QuerySyntax.html">CloudWatch Logs Insights Query Syntax</a>.</p>
                */
            queryString: string | undefined;
    }
    export namespace PutQueryDefinitionRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutQueryDefinitionRequest) => any;
    }
    export interface PutQueryDefinitionResponse {
            /**
                * <p>The ID of the query definition.</p>
                */
            queryDefinitionId?: string;
    }
    export namespace PutQueryDefinitionResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutQueryDefinitionResponse) => any;
    }
    export interface PutResourcePolicyRequest {
            /**
                * <p>Name of the new policy. This parameter is required.</p>
                */
            policyName?: string;
            /**
                * <p>Details of the new policy, including the identity of the principal that is enabled to put logs to this account. This is formatted as a JSON string.
                *     This parameter is required.</p>
                *          <p>The following example creates a resource policy enabling the Route 53 service to put
                *       DNS query logs in to the specified log group. Replace <code>"logArn"</code> with the ARN of
                *       your CloudWatch Logs resource, such as a log group or log stream.</p>
                *          <p>CloudWatch Logs also supports <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_condition-keys.html#condition-keys-sourcearn">aws:SourceArn</a>
                *       and <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_condition-keys.html#condition-keys-sourceaccount">aws:SourceAccount</a>
                * condition context keys.</p>
                *          <p>In the example resource policy, you would replace the value of <code>SourceArn</code> with the resource making the
                *       call from RouteÂ 53 to CloudWatch Logs and replace the value of <code>SourceAccount</code> with
                *       the Amazon Web Services account ID making that call.</p>
                *          <p></p>
                *          <p>
                *             <code>{
                *     "Version": "2012-10-17",
                *     "Statement": [
                *         {
                *            "Sid": "Route53LogsToCloudWatchLogs",
                *            "Effect": "Allow",
                *            "Principal": {
                *                "Service": [
                *                    "route53.amazonaws.com"
                *                 ]
                *             },
                *            "Action": "logs:PutLogEvents",
                *            "Resource": "logArn",
                *            "Condition": {
                *                "ArnLike": {
                *                    "aws:SourceArn": "myRoute53ResourceArn"
                *                 },
                *                "StringEquals": {
                *                    "aws:SourceAccount": "myAwsAccountId"
                *                }
                *             }
                *         }
                *       ]
                * }</code>
                *
                *          </p>
                */
            policyDocument?: string;
    }
    export namespace PutResourcePolicyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutResourcePolicyRequest) => any;
    }
    export interface PutResourcePolicyResponse {
            /**
                * <p>The new policy.</p>
                */
            resourcePolicy?: ResourcePolicy;
    }
    export namespace PutResourcePolicyResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutResourcePolicyResponse) => any;
    }
    export interface PutRetentionPolicyRequest {
            /**
                * <p>The name of the log group.</p>
                */
            logGroupName: string | undefined;
            /**
                * <p>The number of days to retain the log events in the specified log group.
                *       Possible values are: 1, 3, 5, 7, 14, 30, 60, 90, 120, 150, 180, 365, 400, 545, 731, 1827, 2192, 2557, 2922, 3288, and 3653.</p>
                *          <p>To set a log group to never have log events expire, use
                *     <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DeleteRetentionPolicy.html">DeleteRetentionPolicy</a>.
                *   </p>
                */
            retentionInDays: number | undefined;
    }
    export namespace PutRetentionPolicyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutRetentionPolicyRequest) => any;
    }
    export interface PutSubscriptionFilterRequest {
            /**
                * <p>The name of the log group.</p>
                */
            logGroupName: string | undefined;
            /**
                * <p>A name for the subscription filter. If you are updating an existing filter, you must
                *       specify the correct name in <code>filterName</code>. To find the name of the filter currently
                *       associated with a log group, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DescribeSubscriptionFilters.html">DescribeSubscriptionFilters</a>.</p>
                */
            filterName: string | undefined;
            /**
                * <p>A filter pattern for subscribing to a filtered stream of log events.</p>
                */
            filterPattern: string | undefined;
            /**
                * <p>The ARN of the destination to deliver matching log events to. Currently, the supported
                *       destinations are:</p>
                *          <ul>
                *             <li>
                *                <p>An Amazon Kinesis stream belonging to the same account as the subscription filter,
                *           for same-account delivery.</p>
                *             </li>
                *             <li>
                *                <p>A logical destination (specified using an ARN) belonging to a different account,
                *           for cross-account delivery.</p>
                *                <p>If you are setting up a cross-account subscription, the destination must have an
                *         IAM policy associated with it that allows the sender to send logs to the destination.
                *         For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutDestinationPolicy.html">PutDestinationPolicy</a>.</p>
                *             </li>
                *             <li>
                *                <p>An Amazon Kinesis Firehose delivery stream belonging to the same account as the
                *           subscription filter, for same-account delivery.</p>
                *             </li>
                *             <li>
                *                <p>A Lambda function belonging to the same account as the subscription filter,
                *           for same-account delivery.</p>
                *             </li>
                *          </ul>
                */
            destinationArn: string | undefined;
            /**
                * <p>The ARN of an IAM role that grants CloudWatch Logs permissions to deliver ingested log
                *       events to the destination stream. You don't need to provide the ARN when you are working with
                *       a logical destination for cross-account delivery.</p>
                */
            roleArn?: string;
            /**
                * <p>The method used to distribute log data to the destination. By default, log data is
                *       grouped by log stream, but the grouping can be set to random for a more even distribution.
                *       This property is only applicable when the destination is an Amazon Kinesis stream. </p>
                */
            distribution?: Distribution | string;
    }
    export namespace PutSubscriptionFilterRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutSubscriptionFilterRequest) => any;
    }
    /**
        * <p>Reserved.</p>
        */
    export interface QueryCompileErrorLocation {
            /**
                * <p>Reserved.</p>
                */
            startCharOffset?: number;
            /**
                * <p>Reserved.</p>
                */
            endCharOffset?: number;
    }
    export namespace QueryCompileErrorLocation {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: QueryCompileErrorLocation) => any;
    }
    /**
        * <p>Reserved.</p>
        */
    export interface QueryCompileError {
            /**
                * <p>Reserved.</p>
                */
            location?: QueryCompileErrorLocation;
            /**
                * <p>Reserved.</p>
                */
            message?: string;
    }
    export namespace QueryCompileError {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: QueryCompileError) => any;
    }
    /**
        * <p>The query string is not valid. Details about this error are displayed in a
        *       <code>QueryCompileError</code> object. For more information, see
        *       <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_QueryCompileError.html">QueryCompileError</a>.</p>
        *          <p>For more information about valid query syntax, see
        *       <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CWL_QuerySyntax.html">CloudWatch Logs Insights Query Syntax</a>.</p>
        */
    export class MalformedQueryException extends __BaseException {
            readonly name: "MalformedQueryException";
            readonly $fault: "client";
            /**
                * <p>Reserved.</p>
                */
            queryCompileError?: QueryCompileError;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<MalformedQueryException, __BaseException>);
    }
    export interface StartQueryRequest {
            /**
                * <p>The log group on which to perform the query.</p>
                *          <p>A <code>StartQuery</code> operation must include a <code>logGroupNames</code> or a <code>logGroupName</code> parameter, but
                *       not both.</p>
                */
            logGroupName?: string;
            /**
                * <p>The list of log groups to be queried. You can include up to 20 log groups.</p>
                *          <p>A <code>StartQuery</code> operation must include a <code>logGroupNames</code> or a <code>logGroupName</code> parameter, but
                *     not both.</p>
                */
            logGroupNames?: string[];
            /**
                * <p>The beginning of the time range to query. The range is inclusive, so the specified
                *       start time is included in the query. Specified as epoch time, the
                *       number of seconds since January 1, 1970, 00:00:00 UTC.</p>
                */
            startTime: number | undefined;
            /**
                * <p>The end of the time range to query. The range is inclusive, so the specified
                *       end time is included in the query. Specified as epoch
                *       time, the number of seconds since January 1, 1970, 00:00:00 UTC.</p>
                */
            endTime: number | undefined;
            /**
                * <p>The query string to use.
                *       For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CWL_QuerySyntax.html">CloudWatch Logs Insights Query Syntax</a>.</p>
                */
            queryString: string | undefined;
            /**
                * <p>The maximum number of log events to return in the query. If the query string uses the <code>fields</code> command,
                *     only the specified fields and their values are returned. The default is 1000.</p>
                */
            limit?: number;
    }
    export namespace StartQueryRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StartQueryRequest) => any;
    }
    export interface StartQueryResponse {
            /**
                * <p>The unique ID of the query. </p>
                */
            queryId?: string;
    }
    export namespace StartQueryResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StartQueryResponse) => any;
    }
    export interface StopQueryRequest {
            /**
                * <p>The ID number of the query to stop. To find this ID number, use
                *         <code>DescribeQueries</code>.</p>
                */
            queryId: string | undefined;
    }
    export namespace StopQueryRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StopQueryRequest) => any;
    }
    export interface StopQueryResponse {
            /**
                * <p>This is true if the query was stopped by the <code>StopQuery</code> operation.</p>
                */
            success?: boolean;
    }
    export namespace StopQueryResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StopQueryResponse) => any;
    }
    export interface TagLogGroupRequest {
            /**
                * <p>The name of the log group.</p>
                */
            logGroupName: string | undefined;
            /**
                * <p>The key-value pairs to use for the tags.</p>
                */
            tags: Record<string, string> | undefined;
    }
    export namespace TagLogGroupRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TagLogGroupRequest) => any;
    }
    export interface TestMetricFilterRequest {
            /**
                * <p>A symbolic description of how CloudWatch Logs should interpret the data in each log
                *       event. For example, a log event can contain timestamps, IP addresses, strings, and so on. You
                *       use the filter pattern to specify what to look for in the log event message.</p>
                */
            filterPattern: string | undefined;
            /**
                * <p>The log event messages to test.</p>
                */
            logEventMessages: string[] | undefined;
    }
    export namespace TestMetricFilterRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TestMetricFilterRequest) => any;
    }
    /**
        * <p>Represents a matched event.</p>
        */
    export interface MetricFilterMatchRecord {
            /**
                * <p>The event number.</p>
                */
            eventNumber?: number;
            /**
                * <p>The raw event data.</p>
                */
            eventMessage?: string;
            /**
                * <p>The values extracted from the event data by the filter.</p>
                */
            extractedValues?: Record<string, string>;
    }
    export namespace MetricFilterMatchRecord {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: MetricFilterMatchRecord) => any;
    }
    export interface TestMetricFilterResponse {
            /**
                * <p>The matched events.</p>
                */
            matches?: MetricFilterMatchRecord[];
    }
    export namespace TestMetricFilterResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TestMetricFilterResponse) => any;
    }
    export interface UntagLogGroupRequest {
            /**
                * <p>The name of the log group.</p>
                */
            logGroupName: string | undefined;
            /**
                * <p>The tag keys. The corresponding tags are removed from the log group.</p>
                */
            tags: string[] | undefined;
    }
    export namespace UntagLogGroupRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UntagLogGroupRequest) => any;
    }
}

declare module '@aws-sdk/client-cloudwatch-logs/node_modules/@aws-sdk/client-cloudwatch-logs/dist-types/models/CloudWatchLogsServiceException' {
    import { ServiceException as __ServiceException, ServiceExceptionOptions as __ServiceExceptionOptions } from "@aws-sdk/smithy-client";
    /**
        * Base exception class for all service exceptions from CloudWatchLogs service.
        */
    export class CloudWatchLogsServiceException extends __ServiceException {
            /**
                * @internal
                */
            constructor(options: __ServiceExceptionOptions);
    }
}

