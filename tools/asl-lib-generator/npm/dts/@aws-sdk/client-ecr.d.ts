// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   @aws-sdk/types
//   @aws-sdk/smithy-client
//   @aws-sdk/config-resolver
//   @aws-sdk/middleware-host-header
//   @aws-sdk/middleware-retry
//   @aws-sdk/middleware-signing
//   @aws-sdk/middleware-user-agent
//   @aws-sdk/protocol-http

declare module '@aws-sdk/client-ecr' {
    import { HttpHandlerOptions as __HttpHandlerOptions } from "@aws-sdk/types";
    import { BatchCheckLayerAvailabilityCommandInput, BatchCheckLayerAvailabilityCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/BatchCheckLayerAvailabilityCommand";
    import { BatchDeleteImageCommandInput, BatchDeleteImageCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/BatchDeleteImageCommand";
    import { BatchGetImageCommandInput, BatchGetImageCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/BatchGetImageCommand";
    import { BatchGetRepositoryScanningConfigurationCommandInput, BatchGetRepositoryScanningConfigurationCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/BatchGetRepositoryScanningConfigurationCommand";
    import { CompleteLayerUploadCommandInput, CompleteLayerUploadCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/CompleteLayerUploadCommand";
    import { CreatePullThroughCacheRuleCommandInput, CreatePullThroughCacheRuleCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/CreatePullThroughCacheRuleCommand";
    import { CreateRepositoryCommandInput, CreateRepositoryCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/CreateRepositoryCommand";
    import { DeleteLifecyclePolicyCommandInput, DeleteLifecyclePolicyCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/DeleteLifecyclePolicyCommand";
    import { DeletePullThroughCacheRuleCommandInput, DeletePullThroughCacheRuleCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/DeletePullThroughCacheRuleCommand";
    import { DeleteRegistryPolicyCommandInput, DeleteRegistryPolicyCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/DeleteRegistryPolicyCommand";
    import { DeleteRepositoryCommandInput, DeleteRepositoryCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/DeleteRepositoryCommand";
    import { DeleteRepositoryPolicyCommandInput, DeleteRepositoryPolicyCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/DeleteRepositoryPolicyCommand";
    import { DescribeImageReplicationStatusCommandInput, DescribeImageReplicationStatusCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/DescribeImageReplicationStatusCommand";
    import { DescribeImageScanFindingsCommandInput, DescribeImageScanFindingsCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/DescribeImageScanFindingsCommand";
    import { DescribeImagesCommandInput, DescribeImagesCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/DescribeImagesCommand";
    import { DescribePullThroughCacheRulesCommandInput, DescribePullThroughCacheRulesCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/DescribePullThroughCacheRulesCommand";
    import { DescribeRegistryCommandInput, DescribeRegistryCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/DescribeRegistryCommand";
    import { DescribeRepositoriesCommandInput, DescribeRepositoriesCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/DescribeRepositoriesCommand";
    import { GetAuthorizationTokenCommandInput, GetAuthorizationTokenCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/GetAuthorizationTokenCommand";
    import { GetDownloadUrlForLayerCommandInput, GetDownloadUrlForLayerCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/GetDownloadUrlForLayerCommand";
    import { GetLifecyclePolicyCommandInput, GetLifecyclePolicyCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/GetLifecyclePolicyCommand";
    import { GetLifecyclePolicyPreviewCommandInput, GetLifecyclePolicyPreviewCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/GetLifecyclePolicyPreviewCommand";
    import { GetRegistryPolicyCommandInput, GetRegistryPolicyCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/GetRegistryPolicyCommand";
    import { GetRegistryScanningConfigurationCommandInput, GetRegistryScanningConfigurationCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/GetRegistryScanningConfigurationCommand";
    import { GetRepositoryPolicyCommandInput, GetRepositoryPolicyCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/GetRepositoryPolicyCommand";
    import { InitiateLayerUploadCommandInput, InitiateLayerUploadCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/InitiateLayerUploadCommand";
    import { ListImagesCommandInput, ListImagesCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/ListImagesCommand";
    import { ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/ListTagsForResourceCommand";
    import { PutImageCommandInput, PutImageCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/PutImageCommand";
    import { PutImageScanningConfigurationCommandInput, PutImageScanningConfigurationCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/PutImageScanningConfigurationCommand";
    import { PutImageTagMutabilityCommandInput, PutImageTagMutabilityCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/PutImageTagMutabilityCommand";
    import { PutLifecyclePolicyCommandInput, PutLifecyclePolicyCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/PutLifecyclePolicyCommand";
    import { PutRegistryPolicyCommandInput, PutRegistryPolicyCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/PutRegistryPolicyCommand";
    import { PutRegistryScanningConfigurationCommandInput, PutRegistryScanningConfigurationCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/PutRegistryScanningConfigurationCommand";
    import { PutReplicationConfigurationCommandInput, PutReplicationConfigurationCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/PutReplicationConfigurationCommand";
    import { SetRepositoryPolicyCommandInput, SetRepositoryPolicyCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/SetRepositoryPolicyCommand";
    import { StartImageScanCommandInput, StartImageScanCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/StartImageScanCommand";
    import { StartLifecyclePolicyPreviewCommandInput, StartLifecyclePolicyPreviewCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/StartLifecyclePolicyPreviewCommand";
    import { TagResourceCommandInput, TagResourceCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/TagResourceCommand";
    import { UntagResourceCommandInput, UntagResourceCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/UntagResourceCommand";
    import { UploadLayerPartCommandInput, UploadLayerPartCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/UploadLayerPartCommand";
    import { ECRClient } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/ECRClient";
    /**
        * <fullname>Amazon Elastic Container Registry</fullname>
        *         <p>Amazon Elastic Container Registry (Amazon ECR) is a managed container image registry service. Customers can use the
        *             familiar Docker CLI, or their preferred client, to push, pull, and manage images. Amazon ECR
        *             provides a secure, scalable, and reliable registry for your Docker or Open Container
        *             Initiative (OCI) images. Amazon ECR supports private repositories with resource-based
        *             permissions using IAM so that specific users or Amazon EC2 instances can access
        *             repositories and images.</p>
        *         <p>Amazon ECR has service endpoints in each supported Region. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/ecr.html">Amazon ECR endpoints</a> in the
        *                 <i>Amazon Web Services General Reference</i>.</p>
        */
    export class ECR extends ECRClient {
            /**
                * <p>Checks the availability of one or more image layers in a repository.</p>
                *         <p>When an image is pushed to a repository, each image layer is checked to verify if it
                *             has been uploaded before. If it has been uploaded, then the image layer is
                *             skipped.</p>
                *         <note>
                *             <p>This operation is used by the Amazon ECR proxy and is not generally used by
                *         customers for pulling and pushing images. In most cases, you should use the <code>docker</code> CLI to pull, tag, and push images.</p>
                *          </note>
                */
            batchCheckLayerAvailability(args: BatchCheckLayerAvailabilityCommandInput, options?: __HttpHandlerOptions): Promise<BatchCheckLayerAvailabilityCommandOutput>;
            batchCheckLayerAvailability(args: BatchCheckLayerAvailabilityCommandInput, cb: (err: any, data?: BatchCheckLayerAvailabilityCommandOutput) => void): void;
            batchCheckLayerAvailability(args: BatchCheckLayerAvailabilityCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: BatchCheckLayerAvailabilityCommandOutput) => void): void;
            /**
                * <p>Deletes a list of specified images within a repository. Images are specified with
                *             either an <code>imageTag</code> or <code>imageDigest</code>.</p>
                *         <p>You can remove a tag from an image by specifying the image's tag in your request. When
                *             you remove the last tag from an image, the image is deleted from your repository.</p>
                *         <p>You can completely delete an image (and all of its tags) by specifying the image's
                *             digest in your request.</p>
                */
            batchDeleteImage(args: BatchDeleteImageCommandInput, options?: __HttpHandlerOptions): Promise<BatchDeleteImageCommandOutput>;
            batchDeleteImage(args: BatchDeleteImageCommandInput, cb: (err: any, data?: BatchDeleteImageCommandOutput) => void): void;
            batchDeleteImage(args: BatchDeleteImageCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: BatchDeleteImageCommandOutput) => void): void;
            /**
                * <p>Gets detailed information for an image. Images are specified with either an
                *                 <code>imageTag</code> or <code>imageDigest</code>.</p>
                *         <p>When an image is pulled, the BatchGetImage API is called once to retrieve the image
                *             manifest.</p>
                */
            batchGetImage(args: BatchGetImageCommandInput, options?: __HttpHandlerOptions): Promise<BatchGetImageCommandOutput>;
            batchGetImage(args: BatchGetImageCommandInput, cb: (err: any, data?: BatchGetImageCommandOutput) => void): void;
            batchGetImage(args: BatchGetImageCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: BatchGetImageCommandOutput) => void): void;
            /**
                * <p>Gets the scanning configuration for one or more repositories.</p>
                */
            batchGetRepositoryScanningConfiguration(args: BatchGetRepositoryScanningConfigurationCommandInput, options?: __HttpHandlerOptions): Promise<BatchGetRepositoryScanningConfigurationCommandOutput>;
            batchGetRepositoryScanningConfiguration(args: BatchGetRepositoryScanningConfigurationCommandInput, cb: (err: any, data?: BatchGetRepositoryScanningConfigurationCommandOutput) => void): void;
            batchGetRepositoryScanningConfiguration(args: BatchGetRepositoryScanningConfigurationCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: BatchGetRepositoryScanningConfigurationCommandOutput) => void): void;
            /**
                * <p>Informs Amazon ECR that the image layer upload has completed for a specified registry,
                *             repository name, and upload ID. You can optionally provide a <code>sha256</code> digest
                *             of the image layer for data validation purposes.</p>
                *         <p>When an image is pushed, the CompleteLayerUpload API is called once per each new image
                *             layer to verify that the upload has completed.</p>
                *         <note>
                *             <p>This operation is used by the Amazon ECR proxy and is not generally used by
                *         customers for pulling and pushing images. In most cases, you should use the <code>docker</code> CLI to pull, tag, and push images.</p>
                *          </note>
                */
            completeLayerUpload(args: CompleteLayerUploadCommandInput, options?: __HttpHandlerOptions): Promise<CompleteLayerUploadCommandOutput>;
            completeLayerUpload(args: CompleteLayerUploadCommandInput, cb: (err: any, data?: CompleteLayerUploadCommandOutput) => void): void;
            completeLayerUpload(args: CompleteLayerUploadCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CompleteLayerUploadCommandOutput) => void): void;
            /**
                * <p>Creates a pull through cache rule. A pull through cache rule provides a way to cache
                *             images from an external public registry in your Amazon ECR private registry.</p>
                */
            createPullThroughCacheRule(args: CreatePullThroughCacheRuleCommandInput, options?: __HttpHandlerOptions): Promise<CreatePullThroughCacheRuleCommandOutput>;
            createPullThroughCacheRule(args: CreatePullThroughCacheRuleCommandInput, cb: (err: any, data?: CreatePullThroughCacheRuleCommandOutput) => void): void;
            createPullThroughCacheRule(args: CreatePullThroughCacheRuleCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreatePullThroughCacheRuleCommandOutput) => void): void;
            /**
                * <p>Creates a repository. For more information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/Repositories.html">Amazon ECR repositories</a> in the
                *                 <i>Amazon Elastic Container Registry User Guide</i>.</p>
                */
            createRepository(args: CreateRepositoryCommandInput, options?: __HttpHandlerOptions): Promise<CreateRepositoryCommandOutput>;
            createRepository(args: CreateRepositoryCommandInput, cb: (err: any, data?: CreateRepositoryCommandOutput) => void): void;
            createRepository(args: CreateRepositoryCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateRepositoryCommandOutput) => void): void;
            /**
                * <p>Deletes the lifecycle policy associated with the specified repository.</p>
                */
            deleteLifecyclePolicy(args: DeleteLifecyclePolicyCommandInput, options?: __HttpHandlerOptions): Promise<DeleteLifecyclePolicyCommandOutput>;
            deleteLifecyclePolicy(args: DeleteLifecyclePolicyCommandInput, cb: (err: any, data?: DeleteLifecyclePolicyCommandOutput) => void): void;
            deleteLifecyclePolicy(args: DeleteLifecyclePolicyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteLifecyclePolicyCommandOutput) => void): void;
            /**
                * <p>Deletes a pull through cache rule.</p>
                */
            deletePullThroughCacheRule(args: DeletePullThroughCacheRuleCommandInput, options?: __HttpHandlerOptions): Promise<DeletePullThroughCacheRuleCommandOutput>;
            deletePullThroughCacheRule(args: DeletePullThroughCacheRuleCommandInput, cb: (err: any, data?: DeletePullThroughCacheRuleCommandOutput) => void): void;
            deletePullThroughCacheRule(args: DeletePullThroughCacheRuleCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeletePullThroughCacheRuleCommandOutput) => void): void;
            /**
                * <p>Deletes the registry permissions policy.</p>
                */
            deleteRegistryPolicy(args: DeleteRegistryPolicyCommandInput, options?: __HttpHandlerOptions): Promise<DeleteRegistryPolicyCommandOutput>;
            deleteRegistryPolicy(args: DeleteRegistryPolicyCommandInput, cb: (err: any, data?: DeleteRegistryPolicyCommandOutput) => void): void;
            deleteRegistryPolicy(args: DeleteRegistryPolicyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteRegistryPolicyCommandOutput) => void): void;
            /**
                * <p>Deletes a repository. If the repository contains images, you must either delete all
                *             images in the repository or use the <code>force</code> option to delete the
                *             repository.</p>
                */
            deleteRepository(args: DeleteRepositoryCommandInput, options?: __HttpHandlerOptions): Promise<DeleteRepositoryCommandOutput>;
            deleteRepository(args: DeleteRepositoryCommandInput, cb: (err: any, data?: DeleteRepositoryCommandOutput) => void): void;
            deleteRepository(args: DeleteRepositoryCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteRepositoryCommandOutput) => void): void;
            /**
                * <p>Deletes the repository policy associated with the specified repository.</p>
                */
            deleteRepositoryPolicy(args: DeleteRepositoryPolicyCommandInput, options?: __HttpHandlerOptions): Promise<DeleteRepositoryPolicyCommandOutput>;
            deleteRepositoryPolicy(args: DeleteRepositoryPolicyCommandInput, cb: (err: any, data?: DeleteRepositoryPolicyCommandOutput) => void): void;
            deleteRepositoryPolicy(args: DeleteRepositoryPolicyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteRepositoryPolicyCommandOutput) => void): void;
            /**
                * <p>Returns the replication status for a specified image.</p>
                */
            describeImageReplicationStatus(args: DescribeImageReplicationStatusCommandInput, options?: __HttpHandlerOptions): Promise<DescribeImageReplicationStatusCommandOutput>;
            describeImageReplicationStatus(args: DescribeImageReplicationStatusCommandInput, cb: (err: any, data?: DescribeImageReplicationStatusCommandOutput) => void): void;
            describeImageReplicationStatus(args: DescribeImageReplicationStatusCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeImageReplicationStatusCommandOutput) => void): void;
            /**
                * <p>Returns metadata about the images in a repository.</p>
                *         <note>
                *             <p>Beginning with Docker version 1.9, the Docker client compresses image layers
                *                 before pushing them to a V2 Docker registry. The output of the <code>docker
                *                     images</code> command shows the uncompressed image size, so it may return a
                *                 larger image size than the image sizes returned by <a>DescribeImages</a>.</p>
                *         </note>
                */
            describeImages(args: DescribeImagesCommandInput, options?: __HttpHandlerOptions): Promise<DescribeImagesCommandOutput>;
            describeImages(args: DescribeImagesCommandInput, cb: (err: any, data?: DescribeImagesCommandOutput) => void): void;
            describeImages(args: DescribeImagesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeImagesCommandOutput) => void): void;
            /**
                * <p>Returns the scan findings for the specified image.</p>
                */
            describeImageScanFindings(args: DescribeImageScanFindingsCommandInput, options?: __HttpHandlerOptions): Promise<DescribeImageScanFindingsCommandOutput>;
            describeImageScanFindings(args: DescribeImageScanFindingsCommandInput, cb: (err: any, data?: DescribeImageScanFindingsCommandOutput) => void): void;
            describeImageScanFindings(args: DescribeImageScanFindingsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeImageScanFindingsCommandOutput) => void): void;
            /**
                * <p>Returns the pull through cache rules for a registry.</p>
                */
            describePullThroughCacheRules(args: DescribePullThroughCacheRulesCommandInput, options?: __HttpHandlerOptions): Promise<DescribePullThroughCacheRulesCommandOutput>;
            describePullThroughCacheRules(args: DescribePullThroughCacheRulesCommandInput, cb: (err: any, data?: DescribePullThroughCacheRulesCommandOutput) => void): void;
            describePullThroughCacheRules(args: DescribePullThroughCacheRulesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribePullThroughCacheRulesCommandOutput) => void): void;
            /**
                * <p>Describes the settings for a registry. The replication configuration for a repository
                *             can be created or updated with the <a>PutReplicationConfiguration</a> API
                *             action.</p>
                */
            describeRegistry(args: DescribeRegistryCommandInput, options?: __HttpHandlerOptions): Promise<DescribeRegistryCommandOutput>;
            describeRegistry(args: DescribeRegistryCommandInput, cb: (err: any, data?: DescribeRegistryCommandOutput) => void): void;
            describeRegistry(args: DescribeRegistryCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeRegistryCommandOutput) => void): void;
            /**
                * <p>Describes image repositories in a registry.</p>
                */
            describeRepositories(args: DescribeRepositoriesCommandInput, options?: __HttpHandlerOptions): Promise<DescribeRepositoriesCommandOutput>;
            describeRepositories(args: DescribeRepositoriesCommandInput, cb: (err: any, data?: DescribeRepositoriesCommandOutput) => void): void;
            describeRepositories(args: DescribeRepositoriesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeRepositoriesCommandOutput) => void): void;
            /**
                * <p>Retrieves an authorization token. An authorization token represents your IAM
                *             authentication credentials and can be used to access any Amazon ECR registry that your IAM
                *             principal has access to. The authorization token is valid for 12 hours.</p>
                *         <p>The <code>authorizationToken</code> returned is a base64 encoded string that can be
                *             decoded and used in a <code>docker login</code> command to authenticate to a registry.
                *             The CLI offers an <code>get-login-password</code> command that simplifies the login
                *             process. For more information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/Registries.html#registry_auth">Registry
                *                 authentication</a> in the <i>Amazon Elastic Container Registry User Guide</i>.</p>
                */
            getAuthorizationToken(args: GetAuthorizationTokenCommandInput, options?: __HttpHandlerOptions): Promise<GetAuthorizationTokenCommandOutput>;
            getAuthorizationToken(args: GetAuthorizationTokenCommandInput, cb: (err: any, data?: GetAuthorizationTokenCommandOutput) => void): void;
            getAuthorizationToken(args: GetAuthorizationTokenCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetAuthorizationTokenCommandOutput) => void): void;
            /**
                * <p>Retrieves the pre-signed Amazon S3 download URL corresponding to an image layer. You can
                *             only get URLs for image layers that are referenced in an image.</p>
                *         <p>When an image is pulled, the GetDownloadUrlForLayer API is called once per image layer
                *             that is not already cached.</p>
                *         <note>
                *             <p>This operation is used by the Amazon ECR proxy and is not generally used by
                *         customers for pulling and pushing images. In most cases, you should use the <code>docker</code> CLI to pull, tag, and push images.</p>
                *          </note>
                */
            getDownloadUrlForLayer(args: GetDownloadUrlForLayerCommandInput, options?: __HttpHandlerOptions): Promise<GetDownloadUrlForLayerCommandOutput>;
            getDownloadUrlForLayer(args: GetDownloadUrlForLayerCommandInput, cb: (err: any, data?: GetDownloadUrlForLayerCommandOutput) => void): void;
            getDownloadUrlForLayer(args: GetDownloadUrlForLayerCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetDownloadUrlForLayerCommandOutput) => void): void;
            /**
                * <p>Retrieves the lifecycle policy for the specified repository.</p>
                */
            getLifecyclePolicy(args: GetLifecyclePolicyCommandInput, options?: __HttpHandlerOptions): Promise<GetLifecyclePolicyCommandOutput>;
            getLifecyclePolicy(args: GetLifecyclePolicyCommandInput, cb: (err: any, data?: GetLifecyclePolicyCommandOutput) => void): void;
            getLifecyclePolicy(args: GetLifecyclePolicyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetLifecyclePolicyCommandOutput) => void): void;
            /**
                * <p>Retrieves the results of the lifecycle policy preview request for the specified
                *             repository.</p>
                */
            getLifecyclePolicyPreview(args: GetLifecyclePolicyPreviewCommandInput, options?: __HttpHandlerOptions): Promise<GetLifecyclePolicyPreviewCommandOutput>;
            getLifecyclePolicyPreview(args: GetLifecyclePolicyPreviewCommandInput, cb: (err: any, data?: GetLifecyclePolicyPreviewCommandOutput) => void): void;
            getLifecyclePolicyPreview(args: GetLifecyclePolicyPreviewCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetLifecyclePolicyPreviewCommandOutput) => void): void;
            /**
                * <p>Retrieves the permissions policy for a registry.</p>
                */
            getRegistryPolicy(args: GetRegistryPolicyCommandInput, options?: __HttpHandlerOptions): Promise<GetRegistryPolicyCommandOutput>;
            getRegistryPolicy(args: GetRegistryPolicyCommandInput, cb: (err: any, data?: GetRegistryPolicyCommandOutput) => void): void;
            getRegistryPolicy(args: GetRegistryPolicyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetRegistryPolicyCommandOutput) => void): void;
            /**
                * <p>Retrieves the scanning configuration for a registry.</p>
                */
            getRegistryScanningConfiguration(args: GetRegistryScanningConfigurationCommandInput, options?: __HttpHandlerOptions): Promise<GetRegistryScanningConfigurationCommandOutput>;
            getRegistryScanningConfiguration(args: GetRegistryScanningConfigurationCommandInput, cb: (err: any, data?: GetRegistryScanningConfigurationCommandOutput) => void): void;
            getRegistryScanningConfiguration(args: GetRegistryScanningConfigurationCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetRegistryScanningConfigurationCommandOutput) => void): void;
            /**
                * <p>Retrieves the repository policy for the specified repository.</p>
                */
            getRepositoryPolicy(args: GetRepositoryPolicyCommandInput, options?: __HttpHandlerOptions): Promise<GetRepositoryPolicyCommandOutput>;
            getRepositoryPolicy(args: GetRepositoryPolicyCommandInput, cb: (err: any, data?: GetRepositoryPolicyCommandOutput) => void): void;
            getRepositoryPolicy(args: GetRepositoryPolicyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetRepositoryPolicyCommandOutput) => void): void;
            /**
                * <p>Notifies Amazon ECR that you intend to upload an image layer.</p>
                *         <p>When an image is pushed, the InitiateLayerUpload API is called once per image layer
                *             that has not already been uploaded. Whether or not an image layer has been uploaded is
                *             determined by the BatchCheckLayerAvailability API action.</p>
                *         <note>
                *             <p>This operation is used by the Amazon ECR proxy and is not generally used by
                *         customers for pulling and pushing images. In most cases, you should use the <code>docker</code> CLI to pull, tag, and push images.</p>
                *          </note>
                */
            initiateLayerUpload(args: InitiateLayerUploadCommandInput, options?: __HttpHandlerOptions): Promise<InitiateLayerUploadCommandOutput>;
            initiateLayerUpload(args: InitiateLayerUploadCommandInput, cb: (err: any, data?: InitiateLayerUploadCommandOutput) => void): void;
            initiateLayerUpload(args: InitiateLayerUploadCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: InitiateLayerUploadCommandOutput) => void): void;
            /**
                * <p>Lists all the image IDs for the specified repository.</p>
                *         <p>You can filter images based on whether or not they are tagged by using the
                *                 <code>tagStatus</code> filter and specifying either <code>TAGGED</code>,
                *                 <code>UNTAGGED</code> or <code>ANY</code>. For example, you can filter your results
                *             to return only <code>UNTAGGED</code> images and then pipe that result to a <a>BatchDeleteImage</a> operation to delete them. Or, you can filter your
                *             results to return only <code>TAGGED</code> images to list all of the tags in your
                *             repository.</p>
                */
            listImages(args: ListImagesCommandInput, options?: __HttpHandlerOptions): Promise<ListImagesCommandOutput>;
            listImages(args: ListImagesCommandInput, cb: (err: any, data?: ListImagesCommandOutput) => void): void;
            listImages(args: ListImagesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListImagesCommandOutput) => void): void;
            /**
                * <p>List the tags for an Amazon ECR resource.</p>
                */
            listTagsForResource(args: ListTagsForResourceCommandInput, options?: __HttpHandlerOptions): Promise<ListTagsForResourceCommandOutput>;
            listTagsForResource(args: ListTagsForResourceCommandInput, cb: (err: any, data?: ListTagsForResourceCommandOutput) => void): void;
            listTagsForResource(args: ListTagsForResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListTagsForResourceCommandOutput) => void): void;
            /**
                * <p>Creates or updates the image manifest and tags associated with an image.</p>
                *         <p>When an image is pushed and all new image layers have been uploaded, the PutImage API
                *             is called once to create or update the image manifest and the tags associated with the
                *             image.</p>
                *
                *         <note>
                *             <p>This operation is used by the Amazon ECR proxy and is not generally used by
                *         customers for pulling and pushing images. In most cases, you should use the <code>docker</code> CLI to pull, tag, and push images.</p>
                *          </note>
                */
            putImage(args: PutImageCommandInput, options?: __HttpHandlerOptions): Promise<PutImageCommandOutput>;
            putImage(args: PutImageCommandInput, cb: (err: any, data?: PutImageCommandOutput) => void): void;
            putImage(args: PutImageCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: PutImageCommandOutput) => void): void;
            /**
                * <important>
                *             <p>The <code>PutImageScanningConfiguration</code> API is being deprecated, in favor
                *                 of specifying the image scanning configuration at the registry level. For more
                *                 information, see <a>PutRegistryScanningConfiguration</a>.</p>
                *         </important>
                *         <p>Updates the image scanning configuration for the specified repository.</p>
                */
            putImageScanningConfiguration(args: PutImageScanningConfigurationCommandInput, options?: __HttpHandlerOptions): Promise<PutImageScanningConfigurationCommandOutput>;
            putImageScanningConfiguration(args: PutImageScanningConfigurationCommandInput, cb: (err: any, data?: PutImageScanningConfigurationCommandOutput) => void): void;
            putImageScanningConfiguration(args: PutImageScanningConfigurationCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: PutImageScanningConfigurationCommandOutput) => void): void;
            /**
                * <p>Updates the image tag mutability settings for the specified repository. For more
                *             information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/image-tag-mutability.html">Image tag
                *                 mutability</a> in the <i>Amazon Elastic Container Registry User Guide</i>.</p>
                */
            putImageTagMutability(args: PutImageTagMutabilityCommandInput, options?: __HttpHandlerOptions): Promise<PutImageTagMutabilityCommandOutput>;
            putImageTagMutability(args: PutImageTagMutabilityCommandInput, cb: (err: any, data?: PutImageTagMutabilityCommandOutput) => void): void;
            putImageTagMutability(args: PutImageTagMutabilityCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: PutImageTagMutabilityCommandOutput) => void): void;
            /**
                * <p>Creates or updates the lifecycle policy for the specified repository. For more
                *             information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/LifecyclePolicies.html">Lifecycle policy
                *                 template</a>.</p>
                */
            putLifecyclePolicy(args: PutLifecyclePolicyCommandInput, options?: __HttpHandlerOptions): Promise<PutLifecyclePolicyCommandOutput>;
            putLifecyclePolicy(args: PutLifecyclePolicyCommandInput, cb: (err: any, data?: PutLifecyclePolicyCommandOutput) => void): void;
            putLifecyclePolicy(args: PutLifecyclePolicyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: PutLifecyclePolicyCommandOutput) => void): void;
            /**
                * <p>Creates or updates the permissions policy for your registry.</p>
                *         <p>A registry policy is used to specify permissions for another Amazon Web Services account and is used
                *             when configuring cross-account replication. For more information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/registry-permissions.html">Registry permissions</a> in the <i>Amazon Elastic Container Registry User Guide</i>.</p>
                */
            putRegistryPolicy(args: PutRegistryPolicyCommandInput, options?: __HttpHandlerOptions): Promise<PutRegistryPolicyCommandOutput>;
            putRegistryPolicy(args: PutRegistryPolicyCommandInput, cb: (err: any, data?: PutRegistryPolicyCommandOutput) => void): void;
            putRegistryPolicy(args: PutRegistryPolicyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: PutRegistryPolicyCommandOutput) => void): void;
            /**
                * <p>Creates or updates the scanning configuration for your private registry.</p>
                */
            putRegistryScanningConfiguration(args: PutRegistryScanningConfigurationCommandInput, options?: __HttpHandlerOptions): Promise<PutRegistryScanningConfigurationCommandOutput>;
            putRegistryScanningConfiguration(args: PutRegistryScanningConfigurationCommandInput, cb: (err: any, data?: PutRegistryScanningConfigurationCommandOutput) => void): void;
            putRegistryScanningConfiguration(args: PutRegistryScanningConfigurationCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: PutRegistryScanningConfigurationCommandOutput) => void): void;
            /**
                * <p>Creates or updates the replication configuration for a registry. The existing
                *             replication configuration for a repository can be retrieved with the <a>DescribeRegistry</a> API action. The first time the
                *             PutReplicationConfiguration API is called, a service-linked IAM role is created in
                *             your account for the replication process. For more information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/using-service-linked-roles.html">Using
                *                 service-linked roles for Amazon ECR</a> in the
                *             <i>Amazon Elastic Container Registry User Guide</i>.</p>
                *         <note>
                *             <p>When configuring cross-account replication, the destination account must grant the
                *                 source account permission to replicate. This permission is controlled using a
                *                 registry permissions policy. For more information, see <a>PutRegistryPolicy</a>.</p>
                *         </note>
                */
            putReplicationConfiguration(args: PutReplicationConfigurationCommandInput, options?: __HttpHandlerOptions): Promise<PutReplicationConfigurationCommandOutput>;
            putReplicationConfiguration(args: PutReplicationConfigurationCommandInput, cb: (err: any, data?: PutReplicationConfigurationCommandOutput) => void): void;
            putReplicationConfiguration(args: PutReplicationConfigurationCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: PutReplicationConfigurationCommandOutput) => void): void;
            /**
                * <p>Applies a repository policy to the specified repository to control access permissions.
                *             For more information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/repository-policies.html">Amazon ECR Repository
                *                 policies</a> in the <i>Amazon Elastic Container Registry User Guide</i>.</p>
                */
            setRepositoryPolicy(args: SetRepositoryPolicyCommandInput, options?: __HttpHandlerOptions): Promise<SetRepositoryPolicyCommandOutput>;
            setRepositoryPolicy(args: SetRepositoryPolicyCommandInput, cb: (err: any, data?: SetRepositoryPolicyCommandOutput) => void): void;
            setRepositoryPolicy(args: SetRepositoryPolicyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: SetRepositoryPolicyCommandOutput) => void): void;
            /**
                * <p>Starts an image vulnerability scan. An image scan can only be started once per 24
                *             hours on an individual image. This limit includes if an image was scanned on initial
                *             push. For more information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/image-scanning.html">Image scanning</a> in the
                *                 <i>Amazon Elastic Container Registry User Guide</i>.</p>
                */
            startImageScan(args: StartImageScanCommandInput, options?: __HttpHandlerOptions): Promise<StartImageScanCommandOutput>;
            startImageScan(args: StartImageScanCommandInput, cb: (err: any, data?: StartImageScanCommandOutput) => void): void;
            startImageScan(args: StartImageScanCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: StartImageScanCommandOutput) => void): void;
            /**
                * <p>Starts a preview of a lifecycle policy for the specified repository. This allows you
                *             to see the results before associating the lifecycle policy with the repository.</p>
                */
            startLifecyclePolicyPreview(args: StartLifecyclePolicyPreviewCommandInput, options?: __HttpHandlerOptions): Promise<StartLifecyclePolicyPreviewCommandOutput>;
            startLifecyclePolicyPreview(args: StartLifecyclePolicyPreviewCommandInput, cb: (err: any, data?: StartLifecyclePolicyPreviewCommandOutput) => void): void;
            startLifecyclePolicyPreview(args: StartLifecyclePolicyPreviewCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: StartLifecyclePolicyPreviewCommandOutput) => void): void;
            /**
                * <p>Adds specified tags to a resource with the specified ARN. Existing tags on a resource
                *             are not changed if they are not specified in the request parameters.</p>
                */
            tagResource(args: TagResourceCommandInput, options?: __HttpHandlerOptions): Promise<TagResourceCommandOutput>;
            tagResource(args: TagResourceCommandInput, cb: (err: any, data?: TagResourceCommandOutput) => void): void;
            tagResource(args: TagResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: TagResourceCommandOutput) => void): void;
            /**
                * <p>Deletes specified tags from a resource.</p>
                */
            untagResource(args: UntagResourceCommandInput, options?: __HttpHandlerOptions): Promise<UntagResourceCommandOutput>;
            untagResource(args: UntagResourceCommandInput, cb: (err: any, data?: UntagResourceCommandOutput) => void): void;
            untagResource(args: UntagResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UntagResourceCommandOutput) => void): void;
            /**
                * <p>Uploads an image layer part to Amazon ECR.</p>
                *         <p>When an image is pushed, each new image layer is uploaded in parts. The maximum size
                *             of each image layer part can be 20971520 bytes (or about 20MB). The UploadLayerPart API
                *             is called once per each new image layer part.</p>
                *         <note>
                *             <p>This operation is used by the Amazon ECR proxy and is not generally used by
                *         customers for pulling and pushing images. In most cases, you should use the <code>docker</code> CLI to pull, tag, and push images.</p>
                *          </note>
                */
            uploadLayerPart(args: UploadLayerPartCommandInput, options?: __HttpHandlerOptions): Promise<UploadLayerPartCommandOutput>;
            uploadLayerPart(args: UploadLayerPartCommandInput, cb: (err: any, data?: UploadLayerPartCommandOutput) => void): void;
            uploadLayerPart(args: UploadLayerPartCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UploadLayerPartCommandOutput) => void): void;
    }
}

declare module '@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/BatchCheckLayerAvailabilityCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/ECRClient";
    import { BatchCheckLayerAvailabilityRequest, BatchCheckLayerAvailabilityResponse } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/models/models_0";
    export interface BatchCheckLayerAvailabilityCommandInput extends BatchCheckLayerAvailabilityRequest {
    }
    export interface BatchCheckLayerAvailabilityCommandOutput extends BatchCheckLayerAvailabilityResponse, __MetadataBearer {
    }
    /**
        * <p>Checks the availability of one or more image layers in a repository.</p>
        *         <p>When an image is pushed to a repository, each image layer is checked to verify if it
        *             has been uploaded before. If it has been uploaded, then the image layer is
        *             skipped.</p>
        *         <note>
        *             <p>This operation is used by the Amazon ECR proxy and is not generally used by
        *         customers for pulling and pushing images. In most cases, you should use the <code>docker</code> CLI to pull, tag, and push images.</p>
        *          </note>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRClient, BatchCheckLayerAvailabilityCommand } from "@aws-sdk/client-ecr"; // ES Modules import
        * // const { ECRClient, BatchCheckLayerAvailabilityCommand } = require("@aws-sdk/client-ecr"); // CommonJS import
        * const client = new ECRClient(config);
        * const command = new BatchCheckLayerAvailabilityCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link BatchCheckLayerAvailabilityCommandInput} for command's `input` shape.
        * @see {@link BatchCheckLayerAvailabilityCommandOutput} for command's `response` shape.
        * @see {@link ECRClientResolvedConfig | config} for ECRClient's `config` shape.
        *
        */
    export class BatchCheckLayerAvailabilityCommand extends $Command<BatchCheckLayerAvailabilityCommandInput, BatchCheckLayerAvailabilityCommandOutput, ECRClientResolvedConfig> {
            readonly input: BatchCheckLayerAvailabilityCommandInput;
            constructor(input: BatchCheckLayerAvailabilityCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRClientResolvedConfig, options?: __HttpHandlerOptions): Handler<BatchCheckLayerAvailabilityCommandInput, BatchCheckLayerAvailabilityCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/BatchDeleteImageCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/ECRClient";
    import { BatchDeleteImageRequest, BatchDeleteImageResponse } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/models/models_0";
    export interface BatchDeleteImageCommandInput extends BatchDeleteImageRequest {
    }
    export interface BatchDeleteImageCommandOutput extends BatchDeleteImageResponse, __MetadataBearer {
    }
    /**
        * <p>Deletes a list of specified images within a repository. Images are specified with
        *             either an <code>imageTag</code> or <code>imageDigest</code>.</p>
        *         <p>You can remove a tag from an image by specifying the image's tag in your request. When
        *             you remove the last tag from an image, the image is deleted from your repository.</p>
        *         <p>You can completely delete an image (and all of its tags) by specifying the image's
        *             digest in your request.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRClient, BatchDeleteImageCommand } from "@aws-sdk/client-ecr"; // ES Modules import
        * // const { ECRClient, BatchDeleteImageCommand } = require("@aws-sdk/client-ecr"); // CommonJS import
        * const client = new ECRClient(config);
        * const command = new BatchDeleteImageCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link BatchDeleteImageCommandInput} for command's `input` shape.
        * @see {@link BatchDeleteImageCommandOutput} for command's `response` shape.
        * @see {@link ECRClientResolvedConfig | config} for ECRClient's `config` shape.
        *
        */
    export class BatchDeleteImageCommand extends $Command<BatchDeleteImageCommandInput, BatchDeleteImageCommandOutput, ECRClientResolvedConfig> {
            readonly input: BatchDeleteImageCommandInput;
            constructor(input: BatchDeleteImageCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRClientResolvedConfig, options?: __HttpHandlerOptions): Handler<BatchDeleteImageCommandInput, BatchDeleteImageCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/BatchGetImageCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/ECRClient";
    import { BatchGetImageRequest, BatchGetImageResponse } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/models/models_0";
    export interface BatchGetImageCommandInput extends BatchGetImageRequest {
    }
    export interface BatchGetImageCommandOutput extends BatchGetImageResponse, __MetadataBearer {
    }
    /**
        * <p>Gets detailed information for an image. Images are specified with either an
        *                 <code>imageTag</code> or <code>imageDigest</code>.</p>
        *         <p>When an image is pulled, the BatchGetImage API is called once to retrieve the image
        *             manifest.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRClient, BatchGetImageCommand } from "@aws-sdk/client-ecr"; // ES Modules import
        * // const { ECRClient, BatchGetImageCommand } = require("@aws-sdk/client-ecr"); // CommonJS import
        * const client = new ECRClient(config);
        * const command = new BatchGetImageCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link BatchGetImageCommandInput} for command's `input` shape.
        * @see {@link BatchGetImageCommandOutput} for command's `response` shape.
        * @see {@link ECRClientResolvedConfig | config} for ECRClient's `config` shape.
        *
        */
    export class BatchGetImageCommand extends $Command<BatchGetImageCommandInput, BatchGetImageCommandOutput, ECRClientResolvedConfig> {
            readonly input: BatchGetImageCommandInput;
            constructor(input: BatchGetImageCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRClientResolvedConfig, options?: __HttpHandlerOptions): Handler<BatchGetImageCommandInput, BatchGetImageCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/BatchGetRepositoryScanningConfigurationCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/ECRClient";
    import { BatchGetRepositoryScanningConfigurationRequest, BatchGetRepositoryScanningConfigurationResponse } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/models/models_0";
    export interface BatchGetRepositoryScanningConfigurationCommandInput extends BatchGetRepositoryScanningConfigurationRequest {
    }
    export interface BatchGetRepositoryScanningConfigurationCommandOutput extends BatchGetRepositoryScanningConfigurationResponse, __MetadataBearer {
    }
    /**
        * <p>Gets the scanning configuration for one or more repositories.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRClient, BatchGetRepositoryScanningConfigurationCommand } from "@aws-sdk/client-ecr"; // ES Modules import
        * // const { ECRClient, BatchGetRepositoryScanningConfigurationCommand } = require("@aws-sdk/client-ecr"); // CommonJS import
        * const client = new ECRClient(config);
        * const command = new BatchGetRepositoryScanningConfigurationCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link BatchGetRepositoryScanningConfigurationCommandInput} for command's `input` shape.
        * @see {@link BatchGetRepositoryScanningConfigurationCommandOutput} for command's `response` shape.
        * @see {@link ECRClientResolvedConfig | config} for ECRClient's `config` shape.
        *
        */
    export class BatchGetRepositoryScanningConfigurationCommand extends $Command<BatchGetRepositoryScanningConfigurationCommandInput, BatchGetRepositoryScanningConfigurationCommandOutput, ECRClientResolvedConfig> {
            readonly input: BatchGetRepositoryScanningConfigurationCommandInput;
            constructor(input: BatchGetRepositoryScanningConfigurationCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRClientResolvedConfig, options?: __HttpHandlerOptions): Handler<BatchGetRepositoryScanningConfigurationCommandInput, BatchGetRepositoryScanningConfigurationCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/CompleteLayerUploadCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/ECRClient";
    import { CompleteLayerUploadRequest, CompleteLayerUploadResponse } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/models/models_0";
    export interface CompleteLayerUploadCommandInput extends CompleteLayerUploadRequest {
    }
    export interface CompleteLayerUploadCommandOutput extends CompleteLayerUploadResponse, __MetadataBearer {
    }
    /**
        * <p>Informs Amazon ECR that the image layer upload has completed for a specified registry,
        *             repository name, and upload ID. You can optionally provide a <code>sha256</code> digest
        *             of the image layer for data validation purposes.</p>
        *         <p>When an image is pushed, the CompleteLayerUpload API is called once per each new image
        *             layer to verify that the upload has completed.</p>
        *         <note>
        *             <p>This operation is used by the Amazon ECR proxy and is not generally used by
        *         customers for pulling and pushing images. In most cases, you should use the <code>docker</code> CLI to pull, tag, and push images.</p>
        *          </note>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRClient, CompleteLayerUploadCommand } from "@aws-sdk/client-ecr"; // ES Modules import
        * // const { ECRClient, CompleteLayerUploadCommand } = require("@aws-sdk/client-ecr"); // CommonJS import
        * const client = new ECRClient(config);
        * const command = new CompleteLayerUploadCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CompleteLayerUploadCommandInput} for command's `input` shape.
        * @see {@link CompleteLayerUploadCommandOutput} for command's `response` shape.
        * @see {@link ECRClientResolvedConfig | config} for ECRClient's `config` shape.
        *
        */
    export class CompleteLayerUploadCommand extends $Command<CompleteLayerUploadCommandInput, CompleteLayerUploadCommandOutput, ECRClientResolvedConfig> {
            readonly input: CompleteLayerUploadCommandInput;
            constructor(input: CompleteLayerUploadCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CompleteLayerUploadCommandInput, CompleteLayerUploadCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/CreatePullThroughCacheRuleCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/ECRClient";
    import { CreatePullThroughCacheRuleRequest, CreatePullThroughCacheRuleResponse } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/models/models_0";
    export interface CreatePullThroughCacheRuleCommandInput extends CreatePullThroughCacheRuleRequest {
    }
    export interface CreatePullThroughCacheRuleCommandOutput extends CreatePullThroughCacheRuleResponse, __MetadataBearer {
    }
    /**
        * <p>Creates a pull through cache rule. A pull through cache rule provides a way to cache
        *             images from an external public registry in your Amazon ECR private registry.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRClient, CreatePullThroughCacheRuleCommand } from "@aws-sdk/client-ecr"; // ES Modules import
        * // const { ECRClient, CreatePullThroughCacheRuleCommand } = require("@aws-sdk/client-ecr"); // CommonJS import
        * const client = new ECRClient(config);
        * const command = new CreatePullThroughCacheRuleCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreatePullThroughCacheRuleCommandInput} for command's `input` shape.
        * @see {@link CreatePullThroughCacheRuleCommandOutput} for command's `response` shape.
        * @see {@link ECRClientResolvedConfig | config} for ECRClient's `config` shape.
        *
        */
    export class CreatePullThroughCacheRuleCommand extends $Command<CreatePullThroughCacheRuleCommandInput, CreatePullThroughCacheRuleCommandOutput, ECRClientResolvedConfig> {
            readonly input: CreatePullThroughCacheRuleCommandInput;
            constructor(input: CreatePullThroughCacheRuleCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreatePullThroughCacheRuleCommandInput, CreatePullThroughCacheRuleCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/CreateRepositoryCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/ECRClient";
    import { CreateRepositoryRequest, CreateRepositoryResponse } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/models/models_0";
    export interface CreateRepositoryCommandInput extends CreateRepositoryRequest {
    }
    export interface CreateRepositoryCommandOutput extends CreateRepositoryResponse, __MetadataBearer {
    }
    /**
        * <p>Creates a repository. For more information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/Repositories.html">Amazon ECR repositories</a> in the
        *                 <i>Amazon Elastic Container Registry User Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRClient, CreateRepositoryCommand } from "@aws-sdk/client-ecr"; // ES Modules import
        * // const { ECRClient, CreateRepositoryCommand } = require("@aws-sdk/client-ecr"); // CommonJS import
        * const client = new ECRClient(config);
        * const command = new CreateRepositoryCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateRepositoryCommandInput} for command's `input` shape.
        * @see {@link CreateRepositoryCommandOutput} for command's `response` shape.
        * @see {@link ECRClientResolvedConfig | config} for ECRClient's `config` shape.
        *
        */
    export class CreateRepositoryCommand extends $Command<CreateRepositoryCommandInput, CreateRepositoryCommandOutput, ECRClientResolvedConfig> {
            readonly input: CreateRepositoryCommandInput;
            constructor(input: CreateRepositoryCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateRepositoryCommandInput, CreateRepositoryCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/DeleteLifecyclePolicyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/ECRClient";
    import { DeleteLifecyclePolicyRequest, DeleteLifecyclePolicyResponse } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/models/models_0";
    export interface DeleteLifecyclePolicyCommandInput extends DeleteLifecyclePolicyRequest {
    }
    export interface DeleteLifecyclePolicyCommandOutput extends DeleteLifecyclePolicyResponse, __MetadataBearer {
    }
    /**
        * <p>Deletes the lifecycle policy associated with the specified repository.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRClient, DeleteLifecyclePolicyCommand } from "@aws-sdk/client-ecr"; // ES Modules import
        * // const { ECRClient, DeleteLifecyclePolicyCommand } = require("@aws-sdk/client-ecr"); // CommonJS import
        * const client = new ECRClient(config);
        * const command = new DeleteLifecyclePolicyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteLifecyclePolicyCommandInput} for command's `input` shape.
        * @see {@link DeleteLifecyclePolicyCommandOutput} for command's `response` shape.
        * @see {@link ECRClientResolvedConfig | config} for ECRClient's `config` shape.
        *
        */
    export class DeleteLifecyclePolicyCommand extends $Command<DeleteLifecyclePolicyCommandInput, DeleteLifecyclePolicyCommandOutput, ECRClientResolvedConfig> {
            readonly input: DeleteLifecyclePolicyCommandInput;
            constructor(input: DeleteLifecyclePolicyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteLifecyclePolicyCommandInput, DeleteLifecyclePolicyCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/DeletePullThroughCacheRuleCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/ECRClient";
    import { DeletePullThroughCacheRuleRequest, DeletePullThroughCacheRuleResponse } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/models/models_0";
    export interface DeletePullThroughCacheRuleCommandInput extends DeletePullThroughCacheRuleRequest {
    }
    export interface DeletePullThroughCacheRuleCommandOutput extends DeletePullThroughCacheRuleResponse, __MetadataBearer {
    }
    /**
        * <p>Deletes a pull through cache rule.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRClient, DeletePullThroughCacheRuleCommand } from "@aws-sdk/client-ecr"; // ES Modules import
        * // const { ECRClient, DeletePullThroughCacheRuleCommand } = require("@aws-sdk/client-ecr"); // CommonJS import
        * const client = new ECRClient(config);
        * const command = new DeletePullThroughCacheRuleCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeletePullThroughCacheRuleCommandInput} for command's `input` shape.
        * @see {@link DeletePullThroughCacheRuleCommandOutput} for command's `response` shape.
        * @see {@link ECRClientResolvedConfig | config} for ECRClient's `config` shape.
        *
        */
    export class DeletePullThroughCacheRuleCommand extends $Command<DeletePullThroughCacheRuleCommandInput, DeletePullThroughCacheRuleCommandOutput, ECRClientResolvedConfig> {
            readonly input: DeletePullThroughCacheRuleCommandInput;
            constructor(input: DeletePullThroughCacheRuleCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeletePullThroughCacheRuleCommandInput, DeletePullThroughCacheRuleCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/DeleteRegistryPolicyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/ECRClient";
    import { DeleteRegistryPolicyRequest, DeleteRegistryPolicyResponse } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/models/models_0";
    export interface DeleteRegistryPolicyCommandInput extends DeleteRegistryPolicyRequest {
    }
    export interface DeleteRegistryPolicyCommandOutput extends DeleteRegistryPolicyResponse, __MetadataBearer {
    }
    /**
        * <p>Deletes the registry permissions policy.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRClient, DeleteRegistryPolicyCommand } from "@aws-sdk/client-ecr"; // ES Modules import
        * // const { ECRClient, DeleteRegistryPolicyCommand } = require("@aws-sdk/client-ecr"); // CommonJS import
        * const client = new ECRClient(config);
        * const command = new DeleteRegistryPolicyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteRegistryPolicyCommandInput} for command's `input` shape.
        * @see {@link DeleteRegistryPolicyCommandOutput} for command's `response` shape.
        * @see {@link ECRClientResolvedConfig | config} for ECRClient's `config` shape.
        *
        */
    export class DeleteRegistryPolicyCommand extends $Command<DeleteRegistryPolicyCommandInput, DeleteRegistryPolicyCommandOutput, ECRClientResolvedConfig> {
            readonly input: DeleteRegistryPolicyCommandInput;
            constructor(input: DeleteRegistryPolicyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteRegistryPolicyCommandInput, DeleteRegistryPolicyCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/DeleteRepositoryCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/ECRClient";
    import { DeleteRepositoryRequest, DeleteRepositoryResponse } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/models/models_0";
    export interface DeleteRepositoryCommandInput extends DeleteRepositoryRequest {
    }
    export interface DeleteRepositoryCommandOutput extends DeleteRepositoryResponse, __MetadataBearer {
    }
    /**
        * <p>Deletes a repository. If the repository contains images, you must either delete all
        *             images in the repository or use the <code>force</code> option to delete the
        *             repository.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRClient, DeleteRepositoryCommand } from "@aws-sdk/client-ecr"; // ES Modules import
        * // const { ECRClient, DeleteRepositoryCommand } = require("@aws-sdk/client-ecr"); // CommonJS import
        * const client = new ECRClient(config);
        * const command = new DeleteRepositoryCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteRepositoryCommandInput} for command's `input` shape.
        * @see {@link DeleteRepositoryCommandOutput} for command's `response` shape.
        * @see {@link ECRClientResolvedConfig | config} for ECRClient's `config` shape.
        *
        */
    export class DeleteRepositoryCommand extends $Command<DeleteRepositoryCommandInput, DeleteRepositoryCommandOutput, ECRClientResolvedConfig> {
            readonly input: DeleteRepositoryCommandInput;
            constructor(input: DeleteRepositoryCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteRepositoryCommandInput, DeleteRepositoryCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/DeleteRepositoryPolicyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/ECRClient";
    import { DeleteRepositoryPolicyRequest, DeleteRepositoryPolicyResponse } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/models/models_0";
    export interface DeleteRepositoryPolicyCommandInput extends DeleteRepositoryPolicyRequest {
    }
    export interface DeleteRepositoryPolicyCommandOutput extends DeleteRepositoryPolicyResponse, __MetadataBearer {
    }
    /**
        * <p>Deletes the repository policy associated with the specified repository.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRClient, DeleteRepositoryPolicyCommand } from "@aws-sdk/client-ecr"; // ES Modules import
        * // const { ECRClient, DeleteRepositoryPolicyCommand } = require("@aws-sdk/client-ecr"); // CommonJS import
        * const client = new ECRClient(config);
        * const command = new DeleteRepositoryPolicyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteRepositoryPolicyCommandInput} for command's `input` shape.
        * @see {@link DeleteRepositoryPolicyCommandOutput} for command's `response` shape.
        * @see {@link ECRClientResolvedConfig | config} for ECRClient's `config` shape.
        *
        */
    export class DeleteRepositoryPolicyCommand extends $Command<DeleteRepositoryPolicyCommandInput, DeleteRepositoryPolicyCommandOutput, ECRClientResolvedConfig> {
            readonly input: DeleteRepositoryPolicyCommandInput;
            constructor(input: DeleteRepositoryPolicyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteRepositoryPolicyCommandInput, DeleteRepositoryPolicyCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/DescribeImageReplicationStatusCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/ECRClient";
    import { DescribeImageReplicationStatusRequest, DescribeImageReplicationStatusResponse } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/models/models_0";
    export interface DescribeImageReplicationStatusCommandInput extends DescribeImageReplicationStatusRequest {
    }
    export interface DescribeImageReplicationStatusCommandOutput extends DescribeImageReplicationStatusResponse, __MetadataBearer {
    }
    /**
        * <p>Returns the replication status for a specified image.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRClient, DescribeImageReplicationStatusCommand } from "@aws-sdk/client-ecr"; // ES Modules import
        * // const { ECRClient, DescribeImageReplicationStatusCommand } = require("@aws-sdk/client-ecr"); // CommonJS import
        * const client = new ECRClient(config);
        * const command = new DescribeImageReplicationStatusCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeImageReplicationStatusCommandInput} for command's `input` shape.
        * @see {@link DescribeImageReplicationStatusCommandOutput} for command's `response` shape.
        * @see {@link ECRClientResolvedConfig | config} for ECRClient's `config` shape.
        *
        */
    export class DescribeImageReplicationStatusCommand extends $Command<DescribeImageReplicationStatusCommandInput, DescribeImageReplicationStatusCommandOutput, ECRClientResolvedConfig> {
            readonly input: DescribeImageReplicationStatusCommandInput;
            constructor(input: DescribeImageReplicationStatusCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeImageReplicationStatusCommandInput, DescribeImageReplicationStatusCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/DescribeImageScanFindingsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/ECRClient";
    import { DescribeImageScanFindingsRequest, DescribeImageScanFindingsResponse } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/models/models_0";
    export interface DescribeImageScanFindingsCommandInput extends DescribeImageScanFindingsRequest {
    }
    export interface DescribeImageScanFindingsCommandOutput extends DescribeImageScanFindingsResponse, __MetadataBearer {
    }
    /**
        * <p>Returns the scan findings for the specified image.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRClient, DescribeImageScanFindingsCommand } from "@aws-sdk/client-ecr"; // ES Modules import
        * // const { ECRClient, DescribeImageScanFindingsCommand } = require("@aws-sdk/client-ecr"); // CommonJS import
        * const client = new ECRClient(config);
        * const command = new DescribeImageScanFindingsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeImageScanFindingsCommandInput} for command's `input` shape.
        * @see {@link DescribeImageScanFindingsCommandOutput} for command's `response` shape.
        * @see {@link ECRClientResolvedConfig | config} for ECRClient's `config` shape.
        *
        */
    export class DescribeImageScanFindingsCommand extends $Command<DescribeImageScanFindingsCommandInput, DescribeImageScanFindingsCommandOutput, ECRClientResolvedConfig> {
            readonly input: DescribeImageScanFindingsCommandInput;
            constructor(input: DescribeImageScanFindingsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeImageScanFindingsCommandInput, DescribeImageScanFindingsCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/DescribeImagesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/ECRClient";
    import { DescribeImagesRequest, DescribeImagesResponse } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/models/models_0";
    export interface DescribeImagesCommandInput extends DescribeImagesRequest {
    }
    export interface DescribeImagesCommandOutput extends DescribeImagesResponse, __MetadataBearer {
    }
    /**
        * <p>Returns metadata about the images in a repository.</p>
        *         <note>
        *             <p>Beginning with Docker version 1.9, the Docker client compresses image layers
        *                 before pushing them to a V2 Docker registry. The output of the <code>docker
        *                     images</code> command shows the uncompressed image size, so it may return a
        *                 larger image size than the image sizes returned by <a>DescribeImages</a>.</p>
        *         </note>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRClient, DescribeImagesCommand } from "@aws-sdk/client-ecr"; // ES Modules import
        * // const { ECRClient, DescribeImagesCommand } = require("@aws-sdk/client-ecr"); // CommonJS import
        * const client = new ECRClient(config);
        * const command = new DescribeImagesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeImagesCommandInput} for command's `input` shape.
        * @see {@link DescribeImagesCommandOutput} for command's `response` shape.
        * @see {@link ECRClientResolvedConfig | config} for ECRClient's `config` shape.
        *
        */
    export class DescribeImagesCommand extends $Command<DescribeImagesCommandInput, DescribeImagesCommandOutput, ECRClientResolvedConfig> {
            readonly input: DescribeImagesCommandInput;
            constructor(input: DescribeImagesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeImagesCommandInput, DescribeImagesCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/DescribePullThroughCacheRulesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/ECRClient";
    import { DescribePullThroughCacheRulesRequest, DescribePullThroughCacheRulesResponse } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/models/models_0";
    export interface DescribePullThroughCacheRulesCommandInput extends DescribePullThroughCacheRulesRequest {
    }
    export interface DescribePullThroughCacheRulesCommandOutput extends DescribePullThroughCacheRulesResponse, __MetadataBearer {
    }
    /**
        * <p>Returns the pull through cache rules for a registry.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRClient, DescribePullThroughCacheRulesCommand } from "@aws-sdk/client-ecr"; // ES Modules import
        * // const { ECRClient, DescribePullThroughCacheRulesCommand } = require("@aws-sdk/client-ecr"); // CommonJS import
        * const client = new ECRClient(config);
        * const command = new DescribePullThroughCacheRulesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribePullThroughCacheRulesCommandInput} for command's `input` shape.
        * @see {@link DescribePullThroughCacheRulesCommandOutput} for command's `response` shape.
        * @see {@link ECRClientResolvedConfig | config} for ECRClient's `config` shape.
        *
        */
    export class DescribePullThroughCacheRulesCommand extends $Command<DescribePullThroughCacheRulesCommandInput, DescribePullThroughCacheRulesCommandOutput, ECRClientResolvedConfig> {
            readonly input: DescribePullThroughCacheRulesCommandInput;
            constructor(input: DescribePullThroughCacheRulesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribePullThroughCacheRulesCommandInput, DescribePullThroughCacheRulesCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/DescribeRegistryCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/ECRClient";
    import { DescribeRegistryRequest, DescribeRegistryResponse } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/models/models_0";
    export interface DescribeRegistryCommandInput extends DescribeRegistryRequest {
    }
    export interface DescribeRegistryCommandOutput extends DescribeRegistryResponse, __MetadataBearer {
    }
    /**
        * <p>Describes the settings for a registry. The replication configuration for a repository
        *             can be created or updated with the <a>PutReplicationConfiguration</a> API
        *             action.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRClient, DescribeRegistryCommand } from "@aws-sdk/client-ecr"; // ES Modules import
        * // const { ECRClient, DescribeRegistryCommand } = require("@aws-sdk/client-ecr"); // CommonJS import
        * const client = new ECRClient(config);
        * const command = new DescribeRegistryCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeRegistryCommandInput} for command's `input` shape.
        * @see {@link DescribeRegistryCommandOutput} for command's `response` shape.
        * @see {@link ECRClientResolvedConfig | config} for ECRClient's `config` shape.
        *
        */
    export class DescribeRegistryCommand extends $Command<DescribeRegistryCommandInput, DescribeRegistryCommandOutput, ECRClientResolvedConfig> {
            readonly input: DescribeRegistryCommandInput;
            constructor(input: DescribeRegistryCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeRegistryCommandInput, DescribeRegistryCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/DescribeRepositoriesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/ECRClient";
    import { DescribeRepositoriesRequest, DescribeRepositoriesResponse } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/models/models_0";
    export interface DescribeRepositoriesCommandInput extends DescribeRepositoriesRequest {
    }
    export interface DescribeRepositoriesCommandOutput extends DescribeRepositoriesResponse, __MetadataBearer {
    }
    /**
        * <p>Describes image repositories in a registry.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRClient, DescribeRepositoriesCommand } from "@aws-sdk/client-ecr"; // ES Modules import
        * // const { ECRClient, DescribeRepositoriesCommand } = require("@aws-sdk/client-ecr"); // CommonJS import
        * const client = new ECRClient(config);
        * const command = new DescribeRepositoriesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeRepositoriesCommandInput} for command's `input` shape.
        * @see {@link DescribeRepositoriesCommandOutput} for command's `response` shape.
        * @see {@link ECRClientResolvedConfig | config} for ECRClient's `config` shape.
        *
        */
    export class DescribeRepositoriesCommand extends $Command<DescribeRepositoriesCommandInput, DescribeRepositoriesCommandOutput, ECRClientResolvedConfig> {
            readonly input: DescribeRepositoriesCommandInput;
            constructor(input: DescribeRepositoriesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeRepositoriesCommandInput, DescribeRepositoriesCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/GetAuthorizationTokenCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/ECRClient";
    import { GetAuthorizationTokenRequest, GetAuthorizationTokenResponse } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/models/models_0";
    export interface GetAuthorizationTokenCommandInput extends GetAuthorizationTokenRequest {
    }
    export interface GetAuthorizationTokenCommandOutput extends GetAuthorizationTokenResponse, __MetadataBearer {
    }
    /**
        * <p>Retrieves an authorization token. An authorization token represents your IAM
        *             authentication credentials and can be used to access any Amazon ECR registry that your IAM
        *             principal has access to. The authorization token is valid for 12 hours.</p>
        *         <p>The <code>authorizationToken</code> returned is a base64 encoded string that can be
        *             decoded and used in a <code>docker login</code> command to authenticate to a registry.
        *             The CLI offers an <code>get-login-password</code> command that simplifies the login
        *             process. For more information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/Registries.html#registry_auth">Registry
        *                 authentication</a> in the <i>Amazon Elastic Container Registry User Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRClient, GetAuthorizationTokenCommand } from "@aws-sdk/client-ecr"; // ES Modules import
        * // const { ECRClient, GetAuthorizationTokenCommand } = require("@aws-sdk/client-ecr"); // CommonJS import
        * const client = new ECRClient(config);
        * const command = new GetAuthorizationTokenCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetAuthorizationTokenCommandInput} for command's `input` shape.
        * @see {@link GetAuthorizationTokenCommandOutput} for command's `response` shape.
        * @see {@link ECRClientResolvedConfig | config} for ECRClient's `config` shape.
        *
        */
    export class GetAuthorizationTokenCommand extends $Command<GetAuthorizationTokenCommandInput, GetAuthorizationTokenCommandOutput, ECRClientResolvedConfig> {
            readonly input: GetAuthorizationTokenCommandInput;
            constructor(input: GetAuthorizationTokenCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetAuthorizationTokenCommandInput, GetAuthorizationTokenCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/GetDownloadUrlForLayerCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/ECRClient";
    import { GetDownloadUrlForLayerRequest, GetDownloadUrlForLayerResponse } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/models/models_0";
    export interface GetDownloadUrlForLayerCommandInput extends GetDownloadUrlForLayerRequest {
    }
    export interface GetDownloadUrlForLayerCommandOutput extends GetDownloadUrlForLayerResponse, __MetadataBearer {
    }
    /**
        * <p>Retrieves the pre-signed Amazon S3 download URL corresponding to an image layer. You can
        *             only get URLs for image layers that are referenced in an image.</p>
        *         <p>When an image is pulled, the GetDownloadUrlForLayer API is called once per image layer
        *             that is not already cached.</p>
        *         <note>
        *             <p>This operation is used by the Amazon ECR proxy and is not generally used by
        *         customers for pulling and pushing images. In most cases, you should use the <code>docker</code> CLI to pull, tag, and push images.</p>
        *          </note>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRClient, GetDownloadUrlForLayerCommand } from "@aws-sdk/client-ecr"; // ES Modules import
        * // const { ECRClient, GetDownloadUrlForLayerCommand } = require("@aws-sdk/client-ecr"); // CommonJS import
        * const client = new ECRClient(config);
        * const command = new GetDownloadUrlForLayerCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetDownloadUrlForLayerCommandInput} for command's `input` shape.
        * @see {@link GetDownloadUrlForLayerCommandOutput} for command's `response` shape.
        * @see {@link ECRClientResolvedConfig | config} for ECRClient's `config` shape.
        *
        */
    export class GetDownloadUrlForLayerCommand extends $Command<GetDownloadUrlForLayerCommandInput, GetDownloadUrlForLayerCommandOutput, ECRClientResolvedConfig> {
            readonly input: GetDownloadUrlForLayerCommandInput;
            constructor(input: GetDownloadUrlForLayerCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetDownloadUrlForLayerCommandInput, GetDownloadUrlForLayerCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/GetLifecyclePolicyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/ECRClient";
    import { GetLifecyclePolicyRequest, GetLifecyclePolicyResponse } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/models/models_0";
    export interface GetLifecyclePolicyCommandInput extends GetLifecyclePolicyRequest {
    }
    export interface GetLifecyclePolicyCommandOutput extends GetLifecyclePolicyResponse, __MetadataBearer {
    }
    /**
        * <p>Retrieves the lifecycle policy for the specified repository.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRClient, GetLifecyclePolicyCommand } from "@aws-sdk/client-ecr"; // ES Modules import
        * // const { ECRClient, GetLifecyclePolicyCommand } = require("@aws-sdk/client-ecr"); // CommonJS import
        * const client = new ECRClient(config);
        * const command = new GetLifecyclePolicyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetLifecyclePolicyCommandInput} for command's `input` shape.
        * @see {@link GetLifecyclePolicyCommandOutput} for command's `response` shape.
        * @see {@link ECRClientResolvedConfig | config} for ECRClient's `config` shape.
        *
        */
    export class GetLifecyclePolicyCommand extends $Command<GetLifecyclePolicyCommandInput, GetLifecyclePolicyCommandOutput, ECRClientResolvedConfig> {
            readonly input: GetLifecyclePolicyCommandInput;
            constructor(input: GetLifecyclePolicyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetLifecyclePolicyCommandInput, GetLifecyclePolicyCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/GetLifecyclePolicyPreviewCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/ECRClient";
    import { GetLifecyclePolicyPreviewRequest, GetLifecyclePolicyPreviewResponse } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/models/models_0";
    export interface GetLifecyclePolicyPreviewCommandInput extends GetLifecyclePolicyPreviewRequest {
    }
    export interface GetLifecyclePolicyPreviewCommandOutput extends GetLifecyclePolicyPreviewResponse, __MetadataBearer {
    }
    /**
        * <p>Retrieves the results of the lifecycle policy preview request for the specified
        *             repository.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRClient, GetLifecyclePolicyPreviewCommand } from "@aws-sdk/client-ecr"; // ES Modules import
        * // const { ECRClient, GetLifecyclePolicyPreviewCommand } = require("@aws-sdk/client-ecr"); // CommonJS import
        * const client = new ECRClient(config);
        * const command = new GetLifecyclePolicyPreviewCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetLifecyclePolicyPreviewCommandInput} for command's `input` shape.
        * @see {@link GetLifecyclePolicyPreviewCommandOutput} for command's `response` shape.
        * @see {@link ECRClientResolvedConfig | config} for ECRClient's `config` shape.
        *
        */
    export class GetLifecyclePolicyPreviewCommand extends $Command<GetLifecyclePolicyPreviewCommandInput, GetLifecyclePolicyPreviewCommandOutput, ECRClientResolvedConfig> {
            readonly input: GetLifecyclePolicyPreviewCommandInput;
            constructor(input: GetLifecyclePolicyPreviewCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetLifecyclePolicyPreviewCommandInput, GetLifecyclePolicyPreviewCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/GetRegistryPolicyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/ECRClient";
    import { GetRegistryPolicyRequest, GetRegistryPolicyResponse } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/models/models_0";
    export interface GetRegistryPolicyCommandInput extends GetRegistryPolicyRequest {
    }
    export interface GetRegistryPolicyCommandOutput extends GetRegistryPolicyResponse, __MetadataBearer {
    }
    /**
        * <p>Retrieves the permissions policy for a registry.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRClient, GetRegistryPolicyCommand } from "@aws-sdk/client-ecr"; // ES Modules import
        * // const { ECRClient, GetRegistryPolicyCommand } = require("@aws-sdk/client-ecr"); // CommonJS import
        * const client = new ECRClient(config);
        * const command = new GetRegistryPolicyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetRegistryPolicyCommandInput} for command's `input` shape.
        * @see {@link GetRegistryPolicyCommandOutput} for command's `response` shape.
        * @see {@link ECRClientResolvedConfig | config} for ECRClient's `config` shape.
        *
        */
    export class GetRegistryPolicyCommand extends $Command<GetRegistryPolicyCommandInput, GetRegistryPolicyCommandOutput, ECRClientResolvedConfig> {
            readonly input: GetRegistryPolicyCommandInput;
            constructor(input: GetRegistryPolicyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetRegistryPolicyCommandInput, GetRegistryPolicyCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/GetRegistryScanningConfigurationCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/ECRClient";
    import { GetRegistryScanningConfigurationRequest, GetRegistryScanningConfigurationResponse } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/models/models_0";
    export interface GetRegistryScanningConfigurationCommandInput extends GetRegistryScanningConfigurationRequest {
    }
    export interface GetRegistryScanningConfigurationCommandOutput extends GetRegistryScanningConfigurationResponse, __MetadataBearer {
    }
    /**
        * <p>Retrieves the scanning configuration for a registry.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRClient, GetRegistryScanningConfigurationCommand } from "@aws-sdk/client-ecr"; // ES Modules import
        * // const { ECRClient, GetRegistryScanningConfigurationCommand } = require("@aws-sdk/client-ecr"); // CommonJS import
        * const client = new ECRClient(config);
        * const command = new GetRegistryScanningConfigurationCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetRegistryScanningConfigurationCommandInput} for command's `input` shape.
        * @see {@link GetRegistryScanningConfigurationCommandOutput} for command's `response` shape.
        * @see {@link ECRClientResolvedConfig | config} for ECRClient's `config` shape.
        *
        */
    export class GetRegistryScanningConfigurationCommand extends $Command<GetRegistryScanningConfigurationCommandInput, GetRegistryScanningConfigurationCommandOutput, ECRClientResolvedConfig> {
            readonly input: GetRegistryScanningConfigurationCommandInput;
            constructor(input: GetRegistryScanningConfigurationCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetRegistryScanningConfigurationCommandInput, GetRegistryScanningConfigurationCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/GetRepositoryPolicyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/ECRClient";
    import { GetRepositoryPolicyRequest, GetRepositoryPolicyResponse } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/models/models_0";
    export interface GetRepositoryPolicyCommandInput extends GetRepositoryPolicyRequest {
    }
    export interface GetRepositoryPolicyCommandOutput extends GetRepositoryPolicyResponse, __MetadataBearer {
    }
    /**
        * <p>Retrieves the repository policy for the specified repository.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRClient, GetRepositoryPolicyCommand } from "@aws-sdk/client-ecr"; // ES Modules import
        * // const { ECRClient, GetRepositoryPolicyCommand } = require("@aws-sdk/client-ecr"); // CommonJS import
        * const client = new ECRClient(config);
        * const command = new GetRepositoryPolicyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetRepositoryPolicyCommandInput} for command's `input` shape.
        * @see {@link GetRepositoryPolicyCommandOutput} for command's `response` shape.
        * @see {@link ECRClientResolvedConfig | config} for ECRClient's `config` shape.
        *
        */
    export class GetRepositoryPolicyCommand extends $Command<GetRepositoryPolicyCommandInput, GetRepositoryPolicyCommandOutput, ECRClientResolvedConfig> {
            readonly input: GetRepositoryPolicyCommandInput;
            constructor(input: GetRepositoryPolicyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetRepositoryPolicyCommandInput, GetRepositoryPolicyCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/InitiateLayerUploadCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/ECRClient";
    import { InitiateLayerUploadRequest, InitiateLayerUploadResponse } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/models/models_0";
    export interface InitiateLayerUploadCommandInput extends InitiateLayerUploadRequest {
    }
    export interface InitiateLayerUploadCommandOutput extends InitiateLayerUploadResponse, __MetadataBearer {
    }
    /**
        * <p>Notifies Amazon ECR that you intend to upload an image layer.</p>
        *         <p>When an image is pushed, the InitiateLayerUpload API is called once per image layer
        *             that has not already been uploaded. Whether or not an image layer has been uploaded is
        *             determined by the BatchCheckLayerAvailability API action.</p>
        *         <note>
        *             <p>This operation is used by the Amazon ECR proxy and is not generally used by
        *         customers for pulling and pushing images. In most cases, you should use the <code>docker</code> CLI to pull, tag, and push images.</p>
        *          </note>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRClient, InitiateLayerUploadCommand } from "@aws-sdk/client-ecr"; // ES Modules import
        * // const { ECRClient, InitiateLayerUploadCommand } = require("@aws-sdk/client-ecr"); // CommonJS import
        * const client = new ECRClient(config);
        * const command = new InitiateLayerUploadCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link InitiateLayerUploadCommandInput} for command's `input` shape.
        * @see {@link InitiateLayerUploadCommandOutput} for command's `response` shape.
        * @see {@link ECRClientResolvedConfig | config} for ECRClient's `config` shape.
        *
        */
    export class InitiateLayerUploadCommand extends $Command<InitiateLayerUploadCommandInput, InitiateLayerUploadCommandOutput, ECRClientResolvedConfig> {
            readonly input: InitiateLayerUploadCommandInput;
            constructor(input: InitiateLayerUploadCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRClientResolvedConfig, options?: __HttpHandlerOptions): Handler<InitiateLayerUploadCommandInput, InitiateLayerUploadCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/ListImagesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/ECRClient";
    import { ListImagesRequest, ListImagesResponse } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/models/models_0";
    export interface ListImagesCommandInput extends ListImagesRequest {
    }
    export interface ListImagesCommandOutput extends ListImagesResponse, __MetadataBearer {
    }
    /**
        * <p>Lists all the image IDs for the specified repository.</p>
        *         <p>You can filter images based on whether or not they are tagged by using the
        *                 <code>tagStatus</code> filter and specifying either <code>TAGGED</code>,
        *                 <code>UNTAGGED</code> or <code>ANY</code>. For example, you can filter your results
        *             to return only <code>UNTAGGED</code> images and then pipe that result to a <a>BatchDeleteImage</a> operation to delete them. Or, you can filter your
        *             results to return only <code>TAGGED</code> images to list all of the tags in your
        *             repository.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRClient, ListImagesCommand } from "@aws-sdk/client-ecr"; // ES Modules import
        * // const { ECRClient, ListImagesCommand } = require("@aws-sdk/client-ecr"); // CommonJS import
        * const client = new ECRClient(config);
        * const command = new ListImagesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListImagesCommandInput} for command's `input` shape.
        * @see {@link ListImagesCommandOutput} for command's `response` shape.
        * @see {@link ECRClientResolvedConfig | config} for ECRClient's `config` shape.
        *
        */
    export class ListImagesCommand extends $Command<ListImagesCommandInput, ListImagesCommandOutput, ECRClientResolvedConfig> {
            readonly input: ListImagesCommandInput;
            constructor(input: ListImagesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListImagesCommandInput, ListImagesCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/ListTagsForResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/ECRClient";
    import { ListTagsForResourceRequest, ListTagsForResourceResponse } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/models/models_0";
    export interface ListTagsForResourceCommandInput extends ListTagsForResourceRequest {
    }
    export interface ListTagsForResourceCommandOutput extends ListTagsForResourceResponse, __MetadataBearer {
    }
    /**
        * <p>List the tags for an Amazon ECR resource.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRClient, ListTagsForResourceCommand } from "@aws-sdk/client-ecr"; // ES Modules import
        * // const { ECRClient, ListTagsForResourceCommand } = require("@aws-sdk/client-ecr"); // CommonJS import
        * const client = new ECRClient(config);
        * const command = new ListTagsForResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListTagsForResourceCommandInput} for command's `input` shape.
        * @see {@link ListTagsForResourceCommandOutput} for command's `response` shape.
        * @see {@link ECRClientResolvedConfig | config} for ECRClient's `config` shape.
        *
        */
    export class ListTagsForResourceCommand extends $Command<ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput, ECRClientResolvedConfig> {
            readonly input: ListTagsForResourceCommandInput;
            constructor(input: ListTagsForResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/PutImageCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/ECRClient";
    import { PutImageRequest, PutImageResponse } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/models/models_0";
    export interface PutImageCommandInput extends PutImageRequest {
    }
    export interface PutImageCommandOutput extends PutImageResponse, __MetadataBearer {
    }
    /**
        * <p>Creates or updates the image manifest and tags associated with an image.</p>
        *         <p>When an image is pushed and all new image layers have been uploaded, the PutImage API
        *             is called once to create or update the image manifest and the tags associated with the
        *             image.</p>
        *
        *         <note>
        *             <p>This operation is used by the Amazon ECR proxy and is not generally used by
        *         customers for pulling and pushing images. In most cases, you should use the <code>docker</code> CLI to pull, tag, and push images.</p>
        *          </note>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRClient, PutImageCommand } from "@aws-sdk/client-ecr"; // ES Modules import
        * // const { ECRClient, PutImageCommand } = require("@aws-sdk/client-ecr"); // CommonJS import
        * const client = new ECRClient(config);
        * const command = new PutImageCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link PutImageCommandInput} for command's `input` shape.
        * @see {@link PutImageCommandOutput} for command's `response` shape.
        * @see {@link ECRClientResolvedConfig | config} for ECRClient's `config` shape.
        *
        */
    export class PutImageCommand extends $Command<PutImageCommandInput, PutImageCommandOutput, ECRClientResolvedConfig> {
            readonly input: PutImageCommandInput;
            constructor(input: PutImageCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRClientResolvedConfig, options?: __HttpHandlerOptions): Handler<PutImageCommandInput, PutImageCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/PutImageScanningConfigurationCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/ECRClient";
    import { PutImageScanningConfigurationRequest, PutImageScanningConfigurationResponse } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/models/models_0";
    export interface PutImageScanningConfigurationCommandInput extends PutImageScanningConfigurationRequest {
    }
    export interface PutImageScanningConfigurationCommandOutput extends PutImageScanningConfigurationResponse, __MetadataBearer {
    }
    /**
        * <important>
        *             <p>The <code>PutImageScanningConfiguration</code> API is being deprecated, in favor
        *                 of specifying the image scanning configuration at the registry level. For more
        *                 information, see <a>PutRegistryScanningConfiguration</a>.</p>
        *         </important>
        *         <p>Updates the image scanning configuration for the specified repository.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRClient, PutImageScanningConfigurationCommand } from "@aws-sdk/client-ecr"; // ES Modules import
        * // const { ECRClient, PutImageScanningConfigurationCommand } = require("@aws-sdk/client-ecr"); // CommonJS import
        * const client = new ECRClient(config);
        * const command = new PutImageScanningConfigurationCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link PutImageScanningConfigurationCommandInput} for command's `input` shape.
        * @see {@link PutImageScanningConfigurationCommandOutput} for command's `response` shape.
        * @see {@link ECRClientResolvedConfig | config} for ECRClient's `config` shape.
        *
        */
    export class PutImageScanningConfigurationCommand extends $Command<PutImageScanningConfigurationCommandInput, PutImageScanningConfigurationCommandOutput, ECRClientResolvedConfig> {
            readonly input: PutImageScanningConfigurationCommandInput;
            constructor(input: PutImageScanningConfigurationCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRClientResolvedConfig, options?: __HttpHandlerOptions): Handler<PutImageScanningConfigurationCommandInput, PutImageScanningConfigurationCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/PutImageTagMutabilityCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/ECRClient";
    import { PutImageTagMutabilityRequest, PutImageTagMutabilityResponse } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/models/models_0";
    export interface PutImageTagMutabilityCommandInput extends PutImageTagMutabilityRequest {
    }
    export interface PutImageTagMutabilityCommandOutput extends PutImageTagMutabilityResponse, __MetadataBearer {
    }
    /**
        * <p>Updates the image tag mutability settings for the specified repository. For more
        *             information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/image-tag-mutability.html">Image tag
        *                 mutability</a> in the <i>Amazon Elastic Container Registry User Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRClient, PutImageTagMutabilityCommand } from "@aws-sdk/client-ecr"; // ES Modules import
        * // const { ECRClient, PutImageTagMutabilityCommand } = require("@aws-sdk/client-ecr"); // CommonJS import
        * const client = new ECRClient(config);
        * const command = new PutImageTagMutabilityCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link PutImageTagMutabilityCommandInput} for command's `input` shape.
        * @see {@link PutImageTagMutabilityCommandOutput} for command's `response` shape.
        * @see {@link ECRClientResolvedConfig | config} for ECRClient's `config` shape.
        *
        */
    export class PutImageTagMutabilityCommand extends $Command<PutImageTagMutabilityCommandInput, PutImageTagMutabilityCommandOutput, ECRClientResolvedConfig> {
            readonly input: PutImageTagMutabilityCommandInput;
            constructor(input: PutImageTagMutabilityCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRClientResolvedConfig, options?: __HttpHandlerOptions): Handler<PutImageTagMutabilityCommandInput, PutImageTagMutabilityCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/PutLifecyclePolicyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/ECRClient";
    import { PutLifecyclePolicyRequest, PutLifecyclePolicyResponse } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/models/models_0";
    export interface PutLifecyclePolicyCommandInput extends PutLifecyclePolicyRequest {
    }
    export interface PutLifecyclePolicyCommandOutput extends PutLifecyclePolicyResponse, __MetadataBearer {
    }
    /**
        * <p>Creates or updates the lifecycle policy for the specified repository. For more
        *             information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/LifecyclePolicies.html">Lifecycle policy
        *                 template</a>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRClient, PutLifecyclePolicyCommand } from "@aws-sdk/client-ecr"; // ES Modules import
        * // const { ECRClient, PutLifecyclePolicyCommand } = require("@aws-sdk/client-ecr"); // CommonJS import
        * const client = new ECRClient(config);
        * const command = new PutLifecyclePolicyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link PutLifecyclePolicyCommandInput} for command's `input` shape.
        * @see {@link PutLifecyclePolicyCommandOutput} for command's `response` shape.
        * @see {@link ECRClientResolvedConfig | config} for ECRClient's `config` shape.
        *
        */
    export class PutLifecyclePolicyCommand extends $Command<PutLifecyclePolicyCommandInput, PutLifecyclePolicyCommandOutput, ECRClientResolvedConfig> {
            readonly input: PutLifecyclePolicyCommandInput;
            constructor(input: PutLifecyclePolicyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRClientResolvedConfig, options?: __HttpHandlerOptions): Handler<PutLifecyclePolicyCommandInput, PutLifecyclePolicyCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/PutRegistryPolicyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/ECRClient";
    import { PutRegistryPolicyRequest, PutRegistryPolicyResponse } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/models/models_0";
    export interface PutRegistryPolicyCommandInput extends PutRegistryPolicyRequest {
    }
    export interface PutRegistryPolicyCommandOutput extends PutRegistryPolicyResponse, __MetadataBearer {
    }
    /**
        * <p>Creates or updates the permissions policy for your registry.</p>
        *         <p>A registry policy is used to specify permissions for another Amazon Web Services account and is used
        *             when configuring cross-account replication. For more information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/registry-permissions.html">Registry permissions</a> in the <i>Amazon Elastic Container Registry User Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRClient, PutRegistryPolicyCommand } from "@aws-sdk/client-ecr"; // ES Modules import
        * // const { ECRClient, PutRegistryPolicyCommand } = require("@aws-sdk/client-ecr"); // CommonJS import
        * const client = new ECRClient(config);
        * const command = new PutRegistryPolicyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link PutRegistryPolicyCommandInput} for command's `input` shape.
        * @see {@link PutRegistryPolicyCommandOutput} for command's `response` shape.
        * @see {@link ECRClientResolvedConfig | config} for ECRClient's `config` shape.
        *
        */
    export class PutRegistryPolicyCommand extends $Command<PutRegistryPolicyCommandInput, PutRegistryPolicyCommandOutput, ECRClientResolvedConfig> {
            readonly input: PutRegistryPolicyCommandInput;
            constructor(input: PutRegistryPolicyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRClientResolvedConfig, options?: __HttpHandlerOptions): Handler<PutRegistryPolicyCommandInput, PutRegistryPolicyCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/PutRegistryScanningConfigurationCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/ECRClient";
    import { PutRegistryScanningConfigurationRequest, PutRegistryScanningConfigurationResponse } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/models/models_0";
    export interface PutRegistryScanningConfigurationCommandInput extends PutRegistryScanningConfigurationRequest {
    }
    export interface PutRegistryScanningConfigurationCommandOutput extends PutRegistryScanningConfigurationResponse, __MetadataBearer {
    }
    /**
        * <p>Creates or updates the scanning configuration for your private registry.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRClient, PutRegistryScanningConfigurationCommand } from "@aws-sdk/client-ecr"; // ES Modules import
        * // const { ECRClient, PutRegistryScanningConfigurationCommand } = require("@aws-sdk/client-ecr"); // CommonJS import
        * const client = new ECRClient(config);
        * const command = new PutRegistryScanningConfigurationCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link PutRegistryScanningConfigurationCommandInput} for command's `input` shape.
        * @see {@link PutRegistryScanningConfigurationCommandOutput} for command's `response` shape.
        * @see {@link ECRClientResolvedConfig | config} for ECRClient's `config` shape.
        *
        */
    export class PutRegistryScanningConfigurationCommand extends $Command<PutRegistryScanningConfigurationCommandInput, PutRegistryScanningConfigurationCommandOutput, ECRClientResolvedConfig> {
            readonly input: PutRegistryScanningConfigurationCommandInput;
            constructor(input: PutRegistryScanningConfigurationCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRClientResolvedConfig, options?: __HttpHandlerOptions): Handler<PutRegistryScanningConfigurationCommandInput, PutRegistryScanningConfigurationCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/PutReplicationConfigurationCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/ECRClient";
    import { PutReplicationConfigurationRequest, PutReplicationConfigurationResponse } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/models/models_0";
    export interface PutReplicationConfigurationCommandInput extends PutReplicationConfigurationRequest {
    }
    export interface PutReplicationConfigurationCommandOutput extends PutReplicationConfigurationResponse, __MetadataBearer {
    }
    /**
        * <p>Creates or updates the replication configuration for a registry. The existing
        *             replication configuration for a repository can be retrieved with the <a>DescribeRegistry</a> API action. The first time the
        *             PutReplicationConfiguration API is called, a service-linked IAM role is created in
        *             your account for the replication process. For more information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/using-service-linked-roles.html">Using
        *                 service-linked roles for Amazon ECR</a> in the
        *             <i>Amazon Elastic Container Registry User Guide</i>.</p>
        *         <note>
        *             <p>When configuring cross-account replication, the destination account must grant the
        *                 source account permission to replicate. This permission is controlled using a
        *                 registry permissions policy. For more information, see <a>PutRegistryPolicy</a>.</p>
        *         </note>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRClient, PutReplicationConfigurationCommand } from "@aws-sdk/client-ecr"; // ES Modules import
        * // const { ECRClient, PutReplicationConfigurationCommand } = require("@aws-sdk/client-ecr"); // CommonJS import
        * const client = new ECRClient(config);
        * const command = new PutReplicationConfigurationCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link PutReplicationConfigurationCommandInput} for command's `input` shape.
        * @see {@link PutReplicationConfigurationCommandOutput} for command's `response` shape.
        * @see {@link ECRClientResolvedConfig | config} for ECRClient's `config` shape.
        *
        */
    export class PutReplicationConfigurationCommand extends $Command<PutReplicationConfigurationCommandInput, PutReplicationConfigurationCommandOutput, ECRClientResolvedConfig> {
            readonly input: PutReplicationConfigurationCommandInput;
            constructor(input: PutReplicationConfigurationCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRClientResolvedConfig, options?: __HttpHandlerOptions): Handler<PutReplicationConfigurationCommandInput, PutReplicationConfigurationCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/SetRepositoryPolicyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/ECRClient";
    import { SetRepositoryPolicyRequest, SetRepositoryPolicyResponse } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/models/models_0";
    export interface SetRepositoryPolicyCommandInput extends SetRepositoryPolicyRequest {
    }
    export interface SetRepositoryPolicyCommandOutput extends SetRepositoryPolicyResponse, __MetadataBearer {
    }
    /**
        * <p>Applies a repository policy to the specified repository to control access permissions.
        *             For more information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/repository-policies.html">Amazon ECR Repository
        *                 policies</a> in the <i>Amazon Elastic Container Registry User Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRClient, SetRepositoryPolicyCommand } from "@aws-sdk/client-ecr"; // ES Modules import
        * // const { ECRClient, SetRepositoryPolicyCommand } = require("@aws-sdk/client-ecr"); // CommonJS import
        * const client = new ECRClient(config);
        * const command = new SetRepositoryPolicyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link SetRepositoryPolicyCommandInput} for command's `input` shape.
        * @see {@link SetRepositoryPolicyCommandOutput} for command's `response` shape.
        * @see {@link ECRClientResolvedConfig | config} for ECRClient's `config` shape.
        *
        */
    export class SetRepositoryPolicyCommand extends $Command<SetRepositoryPolicyCommandInput, SetRepositoryPolicyCommandOutput, ECRClientResolvedConfig> {
            readonly input: SetRepositoryPolicyCommandInput;
            constructor(input: SetRepositoryPolicyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRClientResolvedConfig, options?: __HttpHandlerOptions): Handler<SetRepositoryPolicyCommandInput, SetRepositoryPolicyCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/StartImageScanCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/ECRClient";
    import { StartImageScanRequest, StartImageScanResponse } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/models/models_0";
    export interface StartImageScanCommandInput extends StartImageScanRequest {
    }
    export interface StartImageScanCommandOutput extends StartImageScanResponse, __MetadataBearer {
    }
    /**
        * <p>Starts an image vulnerability scan. An image scan can only be started once per 24
        *             hours on an individual image. This limit includes if an image was scanned on initial
        *             push. For more information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/image-scanning.html">Image scanning</a> in the
        *                 <i>Amazon Elastic Container Registry User Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRClient, StartImageScanCommand } from "@aws-sdk/client-ecr"; // ES Modules import
        * // const { ECRClient, StartImageScanCommand } = require("@aws-sdk/client-ecr"); // CommonJS import
        * const client = new ECRClient(config);
        * const command = new StartImageScanCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link StartImageScanCommandInput} for command's `input` shape.
        * @see {@link StartImageScanCommandOutput} for command's `response` shape.
        * @see {@link ECRClientResolvedConfig | config} for ECRClient's `config` shape.
        *
        */
    export class StartImageScanCommand extends $Command<StartImageScanCommandInput, StartImageScanCommandOutput, ECRClientResolvedConfig> {
            readonly input: StartImageScanCommandInput;
            constructor(input: StartImageScanCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRClientResolvedConfig, options?: __HttpHandlerOptions): Handler<StartImageScanCommandInput, StartImageScanCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/StartLifecyclePolicyPreviewCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/ECRClient";
    import { StartLifecyclePolicyPreviewRequest, StartLifecyclePolicyPreviewResponse } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/models/models_0";
    export interface StartLifecyclePolicyPreviewCommandInput extends StartLifecyclePolicyPreviewRequest {
    }
    export interface StartLifecyclePolicyPreviewCommandOutput extends StartLifecyclePolicyPreviewResponse, __MetadataBearer {
    }
    /**
        * <p>Starts a preview of a lifecycle policy for the specified repository. This allows you
        *             to see the results before associating the lifecycle policy with the repository.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRClient, StartLifecyclePolicyPreviewCommand } from "@aws-sdk/client-ecr"; // ES Modules import
        * // const { ECRClient, StartLifecyclePolicyPreviewCommand } = require("@aws-sdk/client-ecr"); // CommonJS import
        * const client = new ECRClient(config);
        * const command = new StartLifecyclePolicyPreviewCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link StartLifecyclePolicyPreviewCommandInput} for command's `input` shape.
        * @see {@link StartLifecyclePolicyPreviewCommandOutput} for command's `response` shape.
        * @see {@link ECRClientResolvedConfig | config} for ECRClient's `config` shape.
        *
        */
    export class StartLifecyclePolicyPreviewCommand extends $Command<StartLifecyclePolicyPreviewCommandInput, StartLifecyclePolicyPreviewCommandOutput, ECRClientResolvedConfig> {
            readonly input: StartLifecyclePolicyPreviewCommandInput;
            constructor(input: StartLifecyclePolicyPreviewCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRClientResolvedConfig, options?: __HttpHandlerOptions): Handler<StartLifecyclePolicyPreviewCommandInput, StartLifecyclePolicyPreviewCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/TagResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/ECRClient";
    import { TagResourceRequest, TagResourceResponse } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/models/models_0";
    export interface TagResourceCommandInput extends TagResourceRequest {
    }
    export interface TagResourceCommandOutput extends TagResourceResponse, __MetadataBearer {
    }
    /**
        * <p>Adds specified tags to a resource with the specified ARN. Existing tags on a resource
        *             are not changed if they are not specified in the request parameters.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRClient, TagResourceCommand } from "@aws-sdk/client-ecr"; // ES Modules import
        * // const { ECRClient, TagResourceCommand } = require("@aws-sdk/client-ecr"); // CommonJS import
        * const client = new ECRClient(config);
        * const command = new TagResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link TagResourceCommandInput} for command's `input` shape.
        * @see {@link TagResourceCommandOutput} for command's `response` shape.
        * @see {@link ECRClientResolvedConfig | config} for ECRClient's `config` shape.
        *
        */
    export class TagResourceCommand extends $Command<TagResourceCommandInput, TagResourceCommandOutput, ECRClientResolvedConfig> {
            readonly input: TagResourceCommandInput;
            constructor(input: TagResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRClientResolvedConfig, options?: __HttpHandlerOptions): Handler<TagResourceCommandInput, TagResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/UntagResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/ECRClient";
    import { UntagResourceRequest, UntagResourceResponse } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/models/models_0";
    export interface UntagResourceCommandInput extends UntagResourceRequest {
    }
    export interface UntagResourceCommandOutput extends UntagResourceResponse, __MetadataBearer {
    }
    /**
        * <p>Deletes specified tags from a resource.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRClient, UntagResourceCommand } from "@aws-sdk/client-ecr"; // ES Modules import
        * // const { ECRClient, UntagResourceCommand } = require("@aws-sdk/client-ecr"); // CommonJS import
        * const client = new ECRClient(config);
        * const command = new UntagResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UntagResourceCommandInput} for command's `input` shape.
        * @see {@link UntagResourceCommandOutput} for command's `response` shape.
        * @see {@link ECRClientResolvedConfig | config} for ECRClient's `config` shape.
        *
        */
    export class UntagResourceCommand extends $Command<UntagResourceCommandInput, UntagResourceCommandOutput, ECRClientResolvedConfig> {
            readonly input: UntagResourceCommandInput;
            constructor(input: UntagResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UntagResourceCommandInput, UntagResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/UploadLayerPartCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ECRClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/ECRClient";
    import { UploadLayerPartRequest, UploadLayerPartResponse } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/models/models_0";
    export interface UploadLayerPartCommandInput extends UploadLayerPartRequest {
    }
    export interface UploadLayerPartCommandOutput extends UploadLayerPartResponse, __MetadataBearer {
    }
    /**
        * <p>Uploads an image layer part to Amazon ECR.</p>
        *         <p>When an image is pushed, each new image layer is uploaded in parts. The maximum size
        *             of each image layer part can be 20971520 bytes (or about 20MB). The UploadLayerPart API
        *             is called once per each new image layer part.</p>
        *         <note>
        *             <p>This operation is used by the Amazon ECR proxy and is not generally used by
        *         customers for pulling and pushing images. In most cases, you should use the <code>docker</code> CLI to pull, tag, and push images.</p>
        *          </note>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { ECRClient, UploadLayerPartCommand } from "@aws-sdk/client-ecr"; // ES Modules import
        * // const { ECRClient, UploadLayerPartCommand } = require("@aws-sdk/client-ecr"); // CommonJS import
        * const client = new ECRClient(config);
        * const command = new UploadLayerPartCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UploadLayerPartCommandInput} for command's `input` shape.
        * @see {@link UploadLayerPartCommandOutput} for command's `response` shape.
        * @see {@link ECRClientResolvedConfig | config} for ECRClient's `config` shape.
        *
        */
    export class UploadLayerPartCommand extends $Command<UploadLayerPartCommandInput, UploadLayerPartCommandOutput, ECRClientResolvedConfig> {
            readonly input: UploadLayerPartCommandInput;
            constructor(input: UploadLayerPartCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: ECRClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UploadLayerPartCommandInput, UploadLayerPartCommandOutput>;
    }
}

declare module '@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/ECRClient' {
    import { EndpointsInputConfig, EndpointsResolvedConfig, RegionInputConfig, RegionResolvedConfig } from "@aws-sdk/config-resolver";
    import { HostHeaderInputConfig, HostHeaderResolvedConfig } from "@aws-sdk/middleware-host-header";
    import { RetryInputConfig, RetryResolvedConfig } from "@aws-sdk/middleware-retry";
    import { AwsAuthInputConfig, AwsAuthResolvedConfig } from "@aws-sdk/middleware-signing";
    import { UserAgentInputConfig, UserAgentResolvedConfig } from "@aws-sdk/middleware-user-agent";
    import { HttpHandler as __HttpHandler } from "@aws-sdk/protocol-http";
    import { Client as __Client, DefaultsMode, SmithyConfiguration as __SmithyConfiguration, SmithyResolvedConfiguration as __SmithyResolvedConfiguration } from "@aws-sdk/smithy-client";
    import { BodyLengthCalculator as __BodyLengthCalculator, Credentials as __Credentials, Decoder as __Decoder, Encoder as __Encoder, HashConstructor as __HashConstructor, HttpHandlerOptions as __HttpHandlerOptions, Logger as __Logger, Provider as __Provider, Provider, RegionInfoProvider, StreamCollector as __StreamCollector, UrlParser as __UrlParser, UserAgent as __UserAgent } from "@aws-sdk/types";
    import { BatchCheckLayerAvailabilityCommandInput, BatchCheckLayerAvailabilityCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/BatchCheckLayerAvailabilityCommand";
    import { BatchDeleteImageCommandInput, BatchDeleteImageCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/BatchDeleteImageCommand";
    import { BatchGetImageCommandInput, BatchGetImageCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/BatchGetImageCommand";
    import { BatchGetRepositoryScanningConfigurationCommandInput, BatchGetRepositoryScanningConfigurationCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/BatchGetRepositoryScanningConfigurationCommand";
    import { CompleteLayerUploadCommandInput, CompleteLayerUploadCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/CompleteLayerUploadCommand";
    import { CreatePullThroughCacheRuleCommandInput, CreatePullThroughCacheRuleCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/CreatePullThroughCacheRuleCommand";
    import { CreateRepositoryCommandInput, CreateRepositoryCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/CreateRepositoryCommand";
    import { DeleteLifecyclePolicyCommandInput, DeleteLifecyclePolicyCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/DeleteLifecyclePolicyCommand";
    import { DeletePullThroughCacheRuleCommandInput, DeletePullThroughCacheRuleCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/DeletePullThroughCacheRuleCommand";
    import { DeleteRegistryPolicyCommandInput, DeleteRegistryPolicyCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/DeleteRegistryPolicyCommand";
    import { DeleteRepositoryCommandInput, DeleteRepositoryCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/DeleteRepositoryCommand";
    import { DeleteRepositoryPolicyCommandInput, DeleteRepositoryPolicyCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/DeleteRepositoryPolicyCommand";
    import { DescribeImageReplicationStatusCommandInput, DescribeImageReplicationStatusCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/DescribeImageReplicationStatusCommand";
    import { DescribeImageScanFindingsCommandInput, DescribeImageScanFindingsCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/DescribeImageScanFindingsCommand";
    import { DescribeImagesCommandInput, DescribeImagesCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/DescribeImagesCommand";
    import { DescribePullThroughCacheRulesCommandInput, DescribePullThroughCacheRulesCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/DescribePullThroughCacheRulesCommand";
    import { DescribeRegistryCommandInput, DescribeRegistryCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/DescribeRegistryCommand";
    import { DescribeRepositoriesCommandInput, DescribeRepositoriesCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/DescribeRepositoriesCommand";
    import { GetAuthorizationTokenCommandInput, GetAuthorizationTokenCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/GetAuthorizationTokenCommand";
    import { GetDownloadUrlForLayerCommandInput, GetDownloadUrlForLayerCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/GetDownloadUrlForLayerCommand";
    import { GetLifecyclePolicyCommandInput, GetLifecyclePolicyCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/GetLifecyclePolicyCommand";
    import { GetLifecyclePolicyPreviewCommandInput, GetLifecyclePolicyPreviewCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/GetLifecyclePolicyPreviewCommand";
    import { GetRegistryPolicyCommandInput, GetRegistryPolicyCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/GetRegistryPolicyCommand";
    import { GetRegistryScanningConfigurationCommandInput, GetRegistryScanningConfigurationCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/GetRegistryScanningConfigurationCommand";
    import { GetRepositoryPolicyCommandInput, GetRepositoryPolicyCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/GetRepositoryPolicyCommand";
    import { InitiateLayerUploadCommandInput, InitiateLayerUploadCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/InitiateLayerUploadCommand";
    import { ListImagesCommandInput, ListImagesCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/ListImagesCommand";
    import { ListTagsForResourceCommandInput, ListTagsForResourceCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/ListTagsForResourceCommand";
    import { PutImageCommandInput, PutImageCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/PutImageCommand";
    import { PutImageScanningConfigurationCommandInput, PutImageScanningConfigurationCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/PutImageScanningConfigurationCommand";
    import { PutImageTagMutabilityCommandInput, PutImageTagMutabilityCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/PutImageTagMutabilityCommand";
    import { PutLifecyclePolicyCommandInput, PutLifecyclePolicyCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/PutLifecyclePolicyCommand";
    import { PutRegistryPolicyCommandInput, PutRegistryPolicyCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/PutRegistryPolicyCommand";
    import { PutRegistryScanningConfigurationCommandInput, PutRegistryScanningConfigurationCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/PutRegistryScanningConfigurationCommand";
    import { PutReplicationConfigurationCommandInput, PutReplicationConfigurationCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/PutReplicationConfigurationCommand";
    import { SetRepositoryPolicyCommandInput, SetRepositoryPolicyCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/SetRepositoryPolicyCommand";
    import { StartImageScanCommandInput, StartImageScanCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/StartImageScanCommand";
    import { StartLifecyclePolicyPreviewCommandInput, StartLifecyclePolicyPreviewCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/StartLifecyclePolicyPreviewCommand";
    import { TagResourceCommandInput, TagResourceCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/TagResourceCommand";
    import { UntagResourceCommandInput, UntagResourceCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/UntagResourceCommand";
    import { UploadLayerPartCommandInput, UploadLayerPartCommandOutput } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/commands/UploadLayerPartCommand";
    export type ServiceInputTypes = BatchCheckLayerAvailabilityCommandInput | BatchDeleteImageCommandInput | BatchGetImageCommandInput | BatchGetRepositoryScanningConfigurationCommandInput | CompleteLayerUploadCommandInput | CreatePullThroughCacheRuleCommandInput | CreateRepositoryCommandInput | DeleteLifecyclePolicyCommandInput | DeletePullThroughCacheRuleCommandInput | DeleteRegistryPolicyCommandInput | DeleteRepositoryCommandInput | DeleteRepositoryPolicyCommandInput | DescribeImageReplicationStatusCommandInput | DescribeImageScanFindingsCommandInput | DescribeImagesCommandInput | DescribePullThroughCacheRulesCommandInput | DescribeRegistryCommandInput | DescribeRepositoriesCommandInput | GetAuthorizationTokenCommandInput | GetDownloadUrlForLayerCommandInput | GetLifecyclePolicyCommandInput | GetLifecyclePolicyPreviewCommandInput | GetRegistryPolicyCommandInput | GetRegistryScanningConfigurationCommandInput | GetRepositoryPolicyCommandInput | InitiateLayerUploadCommandInput | ListImagesCommandInput | ListTagsForResourceCommandInput | PutImageCommandInput | PutImageScanningConfigurationCommandInput | PutImageTagMutabilityCommandInput | PutLifecyclePolicyCommandInput | PutRegistryPolicyCommandInput | PutRegistryScanningConfigurationCommandInput | PutReplicationConfigurationCommandInput | SetRepositoryPolicyCommandInput | StartImageScanCommandInput | StartLifecyclePolicyPreviewCommandInput | TagResourceCommandInput | UntagResourceCommandInput | UploadLayerPartCommandInput;
    export type ServiceOutputTypes = BatchCheckLayerAvailabilityCommandOutput | BatchDeleteImageCommandOutput | BatchGetImageCommandOutput | BatchGetRepositoryScanningConfigurationCommandOutput | CompleteLayerUploadCommandOutput | CreatePullThroughCacheRuleCommandOutput | CreateRepositoryCommandOutput | DeleteLifecyclePolicyCommandOutput | DeletePullThroughCacheRuleCommandOutput | DeleteRegistryPolicyCommandOutput | DeleteRepositoryCommandOutput | DeleteRepositoryPolicyCommandOutput | DescribeImageReplicationStatusCommandOutput | DescribeImageScanFindingsCommandOutput | DescribeImagesCommandOutput | DescribePullThroughCacheRulesCommandOutput | DescribeRegistryCommandOutput | DescribeRepositoriesCommandOutput | GetAuthorizationTokenCommandOutput | GetDownloadUrlForLayerCommandOutput | GetLifecyclePolicyCommandOutput | GetLifecyclePolicyPreviewCommandOutput | GetRegistryPolicyCommandOutput | GetRegistryScanningConfigurationCommandOutput | GetRepositoryPolicyCommandOutput | InitiateLayerUploadCommandOutput | ListImagesCommandOutput | ListTagsForResourceCommandOutput | PutImageCommandOutput | PutImageScanningConfigurationCommandOutput | PutImageTagMutabilityCommandOutput | PutLifecyclePolicyCommandOutput | PutRegistryPolicyCommandOutput | PutRegistryScanningConfigurationCommandOutput | PutReplicationConfigurationCommandOutput | SetRepositoryPolicyCommandOutput | StartImageScanCommandOutput | StartLifecyclePolicyPreviewCommandOutput | TagResourceCommandOutput | UntagResourceCommandOutput | UploadLayerPartCommandOutput;
    export interface ClientDefaults extends Partial<__SmithyResolvedConfiguration<__HttpHandlerOptions>> {
            /**
                * The HTTP handler to use. Fetch in browser and Https in Nodejs.
                */
            requestHandler?: __HttpHandler;
            /**
                * A constructor for a class implementing the {@link __Hash} interface
                * that computes the SHA-256 HMAC or checksum of a string or binary buffer.
                * @internal
                */
            sha256?: __HashConstructor;
            /**
                * The function that will be used to convert strings into HTTP endpoints.
                * @internal
                */
            urlParser?: __UrlParser;
            /**
                * A function that can calculate the length of a request body.
                * @internal
                */
            bodyLengthChecker?: __BodyLengthCalculator;
            /**
                * A function that converts a stream into an array of bytes.
                * @internal
                */
            streamCollector?: __StreamCollector;
            /**
                * The function that will be used to convert a base64-encoded string to a byte array.
                * @internal
                */
            base64Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a base64-encoded string.
                * @internal
                */
            base64Encoder?: __Encoder;
            /**
                * The function that will be used to convert a UTF8-encoded string to a byte array.
                * @internal
                */
            utf8Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a UTF-8 encoded string.
                * @internal
                */
            utf8Encoder?: __Encoder;
            /**
                * The runtime environment.
                * @internal
                */
            runtime?: string;
            /**
                * Disable dyanamically changing the endpoint of the client based on the hostPrefix
                * trait of an operation.
                */
            disableHostPrefix?: boolean;
            /**
                * Value for how many times a request will be made at most in case of retry.
                */
            maxAttempts?: number | __Provider<number>;
            /**
                * Specifies which retry algorithm to use.
                */
            retryMode?: string | __Provider<string>;
            /**
                * Optional logger for logging debug/info/warn/error.
                */
            logger?: __Logger;
            /**
                * Enables IPv6/IPv4 dualstack endpoint.
                */
            useDualstackEndpoint?: boolean | __Provider<boolean>;
            /**
                * Enables FIPS compatible endpoints.
                */
            useFipsEndpoint?: boolean | __Provider<boolean>;
            /**
                * Unique service identifier.
                * @internal
                */
            serviceId?: string;
            /**
                * The AWS region to which this client will send requests
                */
            region?: string | __Provider<string>;
            /**
                * Default credentials provider; Not available in browser runtime.
                * @internal
                */
            credentialDefaultProvider?: (input: any) => __Provider<__Credentials>;
            /**
                * Fetch related hostname, signing name or signing region with given region.
                * @internal
                */
            regionInfoProvider?: RegionInfoProvider;
            /**
                * The provider populating default tracking information to be sent with `user-agent`, `x-amz-user-agent` header
                * @internal
                */
            defaultUserAgentProvider?: Provider<__UserAgent>;
            /**
                * The {@link DefaultsMode} that will be used to determine how certain default configuration options are resolved in the SDK.
                */
            defaultsMode?: DefaultsMode | Provider<DefaultsMode>;
    }
    type ECRClientConfigType = Partial<__SmithyConfiguration<__HttpHandlerOptions>> & ClientDefaults & RegionInputConfig & EndpointsInputConfig & RetryInputConfig & HostHeaderInputConfig & AwsAuthInputConfig & UserAgentInputConfig;
    /**
        * The configuration interface of ECRClient class constructor that set the region, credentials and other options.
        */
    export interface ECRClientConfig extends ECRClientConfigType {
    }
    type ECRClientResolvedConfigType = __SmithyResolvedConfiguration<__HttpHandlerOptions> & Required<ClientDefaults> & RegionResolvedConfig & EndpointsResolvedConfig & RetryResolvedConfig & HostHeaderResolvedConfig & AwsAuthResolvedConfig & UserAgentResolvedConfig;
    /**
        * The resolved configuration interface of ECRClient class. This is resolved and normalized from the {@link ECRClientConfig | constructor configuration interface}.
        */
    export interface ECRClientResolvedConfig extends ECRClientResolvedConfigType {
    }
    /**
        * <fullname>Amazon Elastic Container Registry</fullname>
        *         <p>Amazon Elastic Container Registry (Amazon ECR) is a managed container image registry service. Customers can use the
        *             familiar Docker CLI, or their preferred client, to push, pull, and manage images. Amazon ECR
        *             provides a secure, scalable, and reliable registry for your Docker or Open Container
        *             Initiative (OCI) images. Amazon ECR supports private repositories with resource-based
        *             permissions using IAM so that specific users or Amazon EC2 instances can access
        *             repositories and images.</p>
        *         <p>Amazon ECR has service endpoints in each supported Region. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/ecr.html">Amazon ECR endpoints</a> in the
        *                 <i>Amazon Web Services General Reference</i>.</p>
        */
    export class ECRClient extends __Client<__HttpHandlerOptions, ServiceInputTypes, ServiceOutputTypes, ECRClientResolvedConfig> {
            /**
                * The resolved configuration of ECRClient class. This is resolved and normalized from the {@link ECRClientConfig | constructor configuration interface}.
                */
            readonly config: ECRClientResolvedConfig;
            constructor(configuration: ECRClientConfig);
            /**
                * Destroy underlying resources, like sockets. It's usually not necessary to do this.
                * However in Node.js, it's best to explicitly shut down the client's agent when it is no longer needed.
                * Otherwise, sockets might stay open for quite a long time before the server terminates them.
                */
            destroy(): void;
    }
    export {};
}

declare module '@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/models/models_0' {
    import { ExceptionOptionType as __ExceptionOptionType } from "@aws-sdk/smithy-client";
    import { ECRServiceException as __BaseException } from "@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/models/ECRServiceException";
    export interface BatchCheckLayerAvailabilityRequest {
            /**
                * <p>The Amazon Web Services account ID associated with the registry that contains the image layers to
                *             check. If you do not specify a registry, the default registry is assumed.</p>
                */
            registryId?: string;
            /**
                * <p>The name of the repository that is associated with the image layers to check.</p>
                */
            repositoryName: string | undefined;
            /**
                * <p>The digests of the image layers to check.</p>
                */
            layerDigests: string[] | undefined;
    }
    export namespace BatchCheckLayerAvailabilityRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchCheckLayerAvailabilityRequest) => any;
    }
    export enum LayerFailureCode {
            InvalidLayerDigest = "InvalidLayerDigest",
            MissingLayerDigest = "MissingLayerDigest"
    }
    /**
        * <p>An object representing an Amazon ECR image layer failure.</p>
        */
    export interface LayerFailure {
            /**
                * <p>The layer digest associated with the failure.</p>
                */
            layerDigest?: string;
            /**
                * <p>The failure code associated with the failure.</p>
                */
            failureCode?: LayerFailureCode | string;
            /**
                * <p>The reason for the failure.</p>
                */
            failureReason?: string;
    }
    export namespace LayerFailure {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: LayerFailure) => any;
    }
    export enum LayerAvailability {
            AVAILABLE = "AVAILABLE",
            UNAVAILABLE = "UNAVAILABLE"
    }
    /**
        * <p>An object representing an Amazon ECR image layer.</p>
        */
    export interface Layer {
            /**
                * <p>The <code>sha256</code> digest of the image layer.</p>
                */
            layerDigest?: string;
            /**
                * <p>The availability status of the image layer.</p>
                */
            layerAvailability?: LayerAvailability | string;
            /**
                * <p>The size, in bytes, of the image layer.</p>
                */
            layerSize?: number;
            /**
                * <p>The media type of the layer, such as
                *                 <code>application/vnd.docker.image.rootfs.diff.tar.gzip</code> or
                *                 <code>application/vnd.oci.image.layer.v1.tar+gzip</code>.</p>
                */
            mediaType?: string;
    }
    export namespace Layer {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Layer) => any;
    }
    export interface BatchCheckLayerAvailabilityResponse {
            /**
                * <p>A list of image layer objects corresponding to the image layer references in the
                *             request.</p>
                */
            layers?: Layer[];
            /**
                * <p>Any failures associated with the call.</p>
                */
            failures?: LayerFailure[];
    }
    export namespace BatchCheckLayerAvailabilityResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchCheckLayerAvailabilityResponse) => any;
    }
    /**
        * <p>The specified parameter is invalid. Review the available parameters for the API
        *             request.</p>
        */
    export class InvalidParameterException extends __BaseException {
            readonly name: "InvalidParameterException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidParameterException, __BaseException>);
    }
    /**
        * <p>The specified repository could not be found. Check the spelling of the specified
        *             repository and ensure that you are performing operations on the correct registry.</p>
        */
    export class RepositoryNotFoundException extends __BaseException {
            readonly name: "RepositoryNotFoundException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<RepositoryNotFoundException, __BaseException>);
    }
    /**
        * <p>These errors are usually caused by a server-side issue.</p>
        */
    export class ServerException extends __BaseException {
            readonly name: "ServerException";
            readonly $fault: "server";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ServerException, __BaseException>);
    }
    /**
        * <p>An object with identifying information for an image in an Amazon ECR repository.</p>
        */
    export interface ImageIdentifier {
            /**
                * <p>The <code>sha256</code> digest of the image manifest.</p>
                */
            imageDigest?: string;
            /**
                * <p>The tag used for the image.</p>
                */
            imageTag?: string;
    }
    export namespace ImageIdentifier {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ImageIdentifier) => any;
    }
    /**
        * <p>Deletes specified images within a specified repository. Images are specified with
        *             either the <code>imageTag</code> or <code>imageDigest</code>.</p>
        */
    export interface BatchDeleteImageRequest {
            /**
                * <p>The Amazon Web Services account ID associated with the registry that contains the image to delete.
                *             If you do not specify a registry, the default registry is assumed.</p>
                */
            registryId?: string;
            /**
                * <p>The repository that contains the image to delete.</p>
                */
            repositoryName: string | undefined;
            /**
                * <p>A list of image ID references that correspond to images to delete. The format of the
                *                 <code>imageIds</code> reference is <code>imageTag=tag</code> or
                *                 <code>imageDigest=digest</code>.</p>
                */
            imageIds: ImageIdentifier[] | undefined;
    }
    export namespace BatchDeleteImageRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchDeleteImageRequest) => any;
    }
    export enum ImageFailureCode {
            ImageNotFound = "ImageNotFound",
            ImageReferencedByManifestList = "ImageReferencedByManifestList",
            ImageTagDoesNotMatchDigest = "ImageTagDoesNotMatchDigest",
            InvalidImageDigest = "InvalidImageDigest",
            InvalidImageTag = "InvalidImageTag",
            KmsError = "KmsError",
            MissingDigestAndTag = "MissingDigestAndTag"
    }
    /**
        * <p>An object representing an Amazon ECR image failure.</p>
        */
    export interface ImageFailure {
            /**
                * <p>The image ID associated with the failure.</p>
                */
            imageId?: ImageIdentifier;
            /**
                * <p>The code associated with the failure.</p>
                */
            failureCode?: ImageFailureCode | string;
            /**
                * <p>The reason for the failure.</p>
                */
            failureReason?: string;
    }
    export namespace ImageFailure {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ImageFailure) => any;
    }
    export interface BatchDeleteImageResponse {
            /**
                * <p>The image IDs of the deleted images.</p>
                */
            imageIds?: ImageIdentifier[];
            /**
                * <p>Any failures associated with the call.</p>
                */
            failures?: ImageFailure[];
    }
    export namespace BatchDeleteImageResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchDeleteImageResponse) => any;
    }
    export interface BatchGetImageRequest {
            /**
                * <p>The Amazon Web Services account ID associated with the registry that contains the images to
                *             describe. If you do not specify a registry, the default registry is assumed.</p>
                */
            registryId?: string;
            /**
                * <p>The repository that contains the images to describe.</p>
                */
            repositoryName: string | undefined;
            /**
                * <p>A list of image ID references that correspond to images to describe. The format of the
                *                 <code>imageIds</code> reference is <code>imageTag=tag</code> or
                *                 <code>imageDigest=digest</code>.</p>
                */
            imageIds: ImageIdentifier[] | undefined;
            /**
                * <p>The accepted media types for the request.</p>
                *         <p>Valid values: <code>application/vnd.docker.distribution.manifest.v1+json</code> |
                *                 <code>application/vnd.docker.distribution.manifest.v2+json</code> |
                *                 <code>application/vnd.oci.image.manifest.v1+json</code>
                *          </p>
                */
            acceptedMediaTypes?: string[];
    }
    export namespace BatchGetImageRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchGetImageRequest) => any;
    }
    /**
        * <p>An object representing an Amazon ECR image.</p>
        */
    export interface Image {
            /**
                * <p>The Amazon Web Services account ID associated with the registry containing the image.</p>
                */
            registryId?: string;
            /**
                * <p>The name of the repository associated with the image.</p>
                */
            repositoryName?: string;
            /**
                * <p>An object containing the image tag and image digest associated with an image.</p>
                */
            imageId?: ImageIdentifier;
            /**
                * <p>The image manifest associated with the image.</p>
                */
            imageManifest?: string;
            /**
                * <p>The manifest media type of the image.</p>
                */
            imageManifestMediaType?: string;
    }
    export namespace Image {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Image) => any;
    }
    export interface BatchGetImageResponse {
            /**
                * <p>A list of image objects corresponding to the image references in the request.</p>
                */
            images?: Image[];
            /**
                * <p>Any failures associated with the call.</p>
                */
            failures?: ImageFailure[];
    }
    export namespace BatchGetImageResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchGetImageResponse) => any;
    }
    export interface BatchGetRepositoryScanningConfigurationRequest {
            /**
                * <p>One or more repository names to get the scanning configuration for.</p>
                */
            repositoryNames: string[] | undefined;
    }
    export namespace BatchGetRepositoryScanningConfigurationRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchGetRepositoryScanningConfigurationRequest) => any;
    }
    export enum ScanningConfigurationFailureCode {
            REPOSITORY_NOT_FOUND = "REPOSITORY_NOT_FOUND"
    }
    /**
        * <p>The details about any failures associated with the scanning configuration of a
        *             repository.</p>
        */
    export interface RepositoryScanningConfigurationFailure {
            /**
                * <p>The name of the repository.</p>
                */
            repositoryName?: string;
            /**
                * <p>The failure code.</p>
                */
            failureCode?: ScanningConfigurationFailureCode | string;
            /**
                * <p>The reason for the failure.</p>
                */
            failureReason?: string;
    }
    export namespace RepositoryScanningConfigurationFailure {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RepositoryScanningConfigurationFailure) => any;
    }
    export enum ScanningRepositoryFilterType {
            WILDCARD = "WILDCARD"
    }
    /**
        * <p>The details of a scanning repository filter. For more information on how to use
        *             filters, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/image-scanning.html#image-scanning-filters">Using
        *                 filters</a> in the <i>Amazon Elastic Container Registry User Guide</i>.</p>
        */
    export interface ScanningRepositoryFilter {
            /**
                * <p>The filter to use when scanning.</p>
                */
            filter: string | undefined;
            /**
                * <p>The type associated with the filter.</p>
                */
            filterType: ScanningRepositoryFilterType | string | undefined;
    }
    export namespace ScanningRepositoryFilter {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ScanningRepositoryFilter) => any;
    }
    export enum ScanFrequency {
            CONTINUOUS_SCAN = "CONTINUOUS_SCAN",
            MANUAL = "MANUAL",
            SCAN_ON_PUSH = "SCAN_ON_PUSH"
    }
    /**
        * <p>The details of the scanning configuration for a repository.</p>
        */
    export interface RepositoryScanningConfiguration {
            /**
                * <p>The ARN of the repository.</p>
                */
            repositoryArn?: string;
            /**
                * <p>The name of the repository.</p>
                */
            repositoryName?: string;
            /**
                * <p>Whether or not scan on push is configured for the repository.</p>
                */
            scanOnPush?: boolean;
            /**
                * <p>The scan frequency for the repository.</p>
                */
            scanFrequency?: ScanFrequency | string;
            /**
                * <p>The scan filters applied to the repository.</p>
                */
            appliedScanFilters?: ScanningRepositoryFilter[];
    }
    export namespace RepositoryScanningConfiguration {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RepositoryScanningConfiguration) => any;
    }
    export interface BatchGetRepositoryScanningConfigurationResponse {
            /**
                * <p>The scanning configuration for the requested repositories.</p>
                */
            scanningConfigurations?: RepositoryScanningConfiguration[];
            /**
                * <p>Any failures associated with the call.</p>
                */
            failures?: RepositoryScanningConfigurationFailure[];
    }
    export namespace BatchGetRepositoryScanningConfigurationResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchGetRepositoryScanningConfigurationResponse) => any;
    }
    /**
        * <p>There was an exception validating this request.</p>
        */
    export class ValidationException extends __BaseException {
            readonly name: "ValidationException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ValidationException, __BaseException>);
    }
    export interface CompleteLayerUploadRequest {
            /**
                * <p>The Amazon Web Services account ID associated with the registry to which to upload layers.
                *             If you do not specify a registry, the default registry is assumed.</p>
                */
            registryId?: string;
            /**
                * <p>The name of the repository to associate with the image layer.</p>
                */
            repositoryName: string | undefined;
            /**
                * <p>The upload ID from a previous <a>InitiateLayerUpload</a> operation to
                *             associate with the image layer.</p>
                */
            uploadId: string | undefined;
            /**
                * <p>The <code>sha256</code> digest of the image layer.</p>
                */
            layerDigests: string[] | undefined;
    }
    export namespace CompleteLayerUploadRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CompleteLayerUploadRequest) => any;
    }
    export interface CompleteLayerUploadResponse {
            /**
                * <p>The registry ID associated with the request.</p>
                */
            registryId?: string;
            /**
                * <p>The repository name associated with the request.</p>
                */
            repositoryName?: string;
            /**
                * <p>The upload ID associated with the layer.</p>
                */
            uploadId?: string;
            /**
                * <p>The <code>sha256</code> digest of the image layer.</p>
                */
            layerDigest?: string;
    }
    export namespace CompleteLayerUploadResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CompleteLayerUploadResponse) => any;
    }
    /**
        * <p>The specified layer upload does not contain any layer parts.</p>
        */
    export class EmptyUploadException extends __BaseException {
            readonly name: "EmptyUploadException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<EmptyUploadException, __BaseException>);
    }
    /**
        * <p>The layer digest calculation performed by Amazon ECR upon receipt of the image layer does
        *             not match the digest specified.</p>
        */
    export class InvalidLayerException extends __BaseException {
            readonly name: "InvalidLayerException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidLayerException, __BaseException>);
    }
    /**
        * <p>The operation failed due to a KMS exception.</p>
        */
    export class KmsException extends __BaseException {
            readonly name: "KmsException";
            readonly $fault: "client";
            /**
                * <p>The error code returned by KMS.</p>
                */
            kmsError?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<KmsException, __BaseException>);
    }
    /**
        * <p>The image layer already exists in the associated repository.</p>
        */
    export class LayerAlreadyExistsException extends __BaseException {
            readonly name: "LayerAlreadyExistsException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<LayerAlreadyExistsException, __BaseException>);
    }
    /**
        * <p>Layer parts must be at least 5 MiB in size.</p>
        */
    export class LayerPartTooSmallException extends __BaseException {
            readonly name: "LayerPartTooSmallException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<LayerPartTooSmallException, __BaseException>);
    }
    /**
        * <p>The upload could not be found, or the specified upload ID is not valid for this
        *             repository.</p>
        */
    export class UploadNotFoundException extends __BaseException {
            readonly name: "UploadNotFoundException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<UploadNotFoundException, __BaseException>);
    }
    export interface CreatePullThroughCacheRuleRequest {
            /**
                * <p>The repository name prefix to use when caching images from the source registry.</p>
                */
            ecrRepositoryPrefix: string | undefined;
            /**
                * <p>The registry URL of the upstream public registry to use as the source for the pull
                *             through cache rule.</p>
                */
            upstreamRegistryUrl: string | undefined;
            /**
                * <p>The Amazon Web Services account ID associated with the registry to create the pull through cache
                *             rule for. If you do not specify a registry, the default registry is assumed.</p>
                */
            registryId?: string;
    }
    export namespace CreatePullThroughCacheRuleRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreatePullThroughCacheRuleRequest) => any;
    }
    export interface CreatePullThroughCacheRuleResponse {
            /**
                * <p>The Amazon ECR repository prefix associated with the pull through cache rule.</p>
                */
            ecrRepositoryPrefix?: string;
            /**
                * <p>The upstream registry URL associated with the pull through cache rule.</p>
                */
            upstreamRegistryUrl?: string;
            /**
                * <p>The date and time, in JavaScript date format, when the pull through cache rule was
                *             created.</p>
                */
            createdAt?: Date;
            /**
                * <p>The registry ID associated with the request.</p>
                */
            registryId?: string;
    }
    export namespace CreatePullThroughCacheRuleResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreatePullThroughCacheRuleResponse) => any;
    }
    /**
        * <p>The operation did not succeed because it would have exceeded a service limit for your
        *             account. For more information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/service-quotas.html">Amazon ECR service quotas</a> in
        *             the Amazon Elastic Container Registry User Guide.</p>
        */
    export class LimitExceededException extends __BaseException {
            readonly name: "LimitExceededException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<LimitExceededException, __BaseException>);
    }
    /**
        * <p>A pull through cache rule with these settings already exists for the private
        *             registry.</p>
        */
    export class PullThroughCacheRuleAlreadyExistsException extends __BaseException {
            readonly name: "PullThroughCacheRuleAlreadyExistsException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<PullThroughCacheRuleAlreadyExistsException, __BaseException>);
    }
    /**
        * <p>The specified upstream registry isn't supported.</p>
        */
    export class UnsupportedUpstreamRegistryException extends __BaseException {
            readonly name: "UnsupportedUpstreamRegistryException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<UnsupportedUpstreamRegistryException, __BaseException>);
    }
    export enum EncryptionType {
            AES256 = "AES256",
            KMS = "KMS"
    }
    /**
        * <p>The encryption configuration for the repository. This determines how the contents of
        *             your repository are encrypted at rest.</p>
        *         <p>By default, when no encryption configuration is set or the <code>AES256</code>
        *             encryption type is used, Amazon ECR uses server-side encryption with Amazon S3-managed encryption
        *             keys which encrypts your data at rest using an AES-256 encryption algorithm. This does
        *             not require any action on your part.</p>
        *         <p>For more control over the encryption of the contents of your repository, you can use
        *             server-side encryption with Key Management Service key stored in Key Management Service (KMS) to encrypt your
        *             images. For more information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/encryption-at-rest.html">Amazon ECR encryption at
        *                 rest</a> in the <i>Amazon Elastic Container Registry User Guide</i>.</p>
        */
    export interface EncryptionConfiguration {
            /**
                * <p>The encryption type to use.</p>
                *         <p>If you use the <code>KMS</code> encryption type, the contents of the repository will
                *             be encrypted using server-side encryption with Key Management Service key stored in KMS. When you
                *             use KMS to encrypt your data, you can either use the default Amazon Web Services managed KMS key
                *             for Amazon ECR, or specify your own KMS key, which you already created. For more
                *             information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingKMSEncryption.html">Protecting data using server-side
                *                 encryption with an KMS key stored in Key Management Service (SSE-KMS)</a> in the
                *                 <i>Amazon Simple Storage Service Console Developer Guide</i>.</p>
                *         <p>If you use the <code>AES256</code> encryption type, Amazon ECR uses server-side encryption
                *             with Amazon S3-managed encryption keys which encrypts the images in the repository using an
                *             AES-256 encryption algorithm. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingServerSideEncryption.html">Protecting data using
                *                 server-side encryption with Amazon S3-managed encryption keys (SSE-S3)</a> in the
                *                 <i>Amazon Simple Storage Service Console Developer Guide</i>.</p>
                */
            encryptionType: EncryptionType | string | undefined;
            /**
                * <p>If you use the <code>KMS</code> encryption type, specify the KMS key to use for
                *             encryption. The alias, key ID, or full ARN of the KMS key can be specified. The key
                *             must exist in the same Region as the repository. If no key is specified, the default
                *             Amazon Web Services managed KMS key for Amazon ECR will be used.</p>
                */
            kmsKey?: string;
    }
    export namespace EncryptionConfiguration {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: EncryptionConfiguration) => any;
    }
    /**
        * <p>The image scanning configuration for a repository.</p>
        */
    export interface ImageScanningConfiguration {
            /**
                * <p>The setting that determines whether images are scanned after being pushed to a
                *             repository. If set to <code>true</code>, images will be scanned after being pushed. If
                *             this parameter is not specified, it will default to <code>false</code> and images will
                *             not be scanned unless a scan is manually started with the <a href="https://docs.aws.amazon.com/AmazonECR/latest/APIReference/API_StartImageScan.html">API_StartImageScan</a> API.</p>
                */
            scanOnPush?: boolean;
    }
    export namespace ImageScanningConfiguration {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ImageScanningConfiguration) => any;
    }
    export enum ImageTagMutability {
            IMMUTABLE = "IMMUTABLE",
            MUTABLE = "MUTABLE"
    }
    /**
        * <p>The metadata to apply to a resource to help you categorize and organize them. Each tag
        *             consists of a key and a value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have
        *             a maximum length of 256 characters.</p>
        */
    export interface Tag {
            /**
                * <p>One part of a key-value pair that make up a tag. A <code>key</code> is a general label
                *             that acts like a category for more specific tag values.</p>
                */
            Key?: string;
            /**
                * <p>A <code>value</code> acts as a descriptor within a tag category (key).</p>
                */
            Value?: string;
    }
    export namespace Tag {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Tag) => any;
    }
    export interface CreateRepositoryRequest {
            /**
                * <p>The Amazon Web Services account ID associated with the registry to create the repository.
                *             If you do not specify a registry, the default registry is assumed.</p>
                */
            registryId?: string;
            /**
                * <p>The name to use for the repository. The repository name may be specified on its own
                *             (such as <code>nginx-web-app</code>) or it can be prepended with a namespace to group
                *             the repository into a category (such as <code>project-a/nginx-web-app</code>).</p>
                */
            repositoryName: string | undefined;
            /**
                * <p>The metadata that you apply to the repository to help you categorize and organize
                *             them. Each tag consists of a key and an optional value, both of which you define.
                *             Tag keys can have a maximum character length of 128 characters, and tag values can have
                *             a maximum length of 256 characters.</p>
                */
            tags?: Tag[];
            /**
                * <p>The tag mutability setting for the repository. If this parameter is omitted, the
                *             default setting of <code>MUTABLE</code> will be used which will allow image tags to be
                *             overwritten. If <code>IMMUTABLE</code> is specified, all image tags within the
                *             repository will be immutable which will prevent them from being overwritten.</p>
                */
            imageTagMutability?: ImageTagMutability | string;
            /**
                * <p>The image scanning configuration for the repository. This determines whether images
                *             are scanned for known vulnerabilities after being pushed to the repository.</p>
                */
            imageScanningConfiguration?: ImageScanningConfiguration;
            /**
                * <p>The encryption configuration for the repository. This determines how the contents of
                *             your repository are encrypted at rest.</p>
                */
            encryptionConfiguration?: EncryptionConfiguration;
    }
    export namespace CreateRepositoryRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateRepositoryRequest) => any;
    }
    /**
        * <p>An object representing a repository.</p>
        */
    export interface Repository {
            /**
                * <p>The Amazon Resource Name (ARN) that identifies the repository. The ARN contains the <code>arn:aws:ecr</code> namespace, followed by the region of the
                *     repository, Amazon Web Services account ID of the repository owner, repository namespace, and repository name.
                *     For example, <code>arn:aws:ecr:region:012345678910:repository/test</code>.</p>
                */
            repositoryArn?: string;
            /**
                * <p>The Amazon Web Services account ID associated with the registry that contains the repository.</p>
                */
            registryId?: string;
            /**
                * <p>The name of the repository.</p>
                */
            repositoryName?: string;
            /**
                * <p>The URI for the repository. You can use this URI for container image <code>push</code>
                *             and <code>pull</code> operations.</p>
                */
            repositoryUri?: string;
            /**
                * <p>The date and time, in JavaScript date format, when the repository was created.</p>
                */
            createdAt?: Date;
            /**
                * <p>The tag mutability setting for the repository.</p>
                */
            imageTagMutability?: ImageTagMutability | string;
            /**
                * <p>The image scanning configuration for a repository.</p>
                */
            imageScanningConfiguration?: ImageScanningConfiguration;
            /**
                * <p>The encryption configuration for the repository. This determines how the contents of
                *             your repository are encrypted at rest.</p>
                */
            encryptionConfiguration?: EncryptionConfiguration;
    }
    export namespace Repository {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Repository) => any;
    }
    export interface CreateRepositoryResponse {
            /**
                * <p>The repository that was created.</p>
                */
            repository?: Repository;
    }
    export namespace CreateRepositoryResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateRepositoryResponse) => any;
    }
    /**
        * <p>An invalid parameter has been specified. Tag keys can have a maximum character length of 128 characters, and tag values can have
        *             a maximum length of 256 characters.</p>
        */
    export class InvalidTagParameterException extends __BaseException {
            readonly name: "InvalidTagParameterException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidTagParameterException, __BaseException>);
    }
    /**
        * <p>The specified repository already exists in the specified registry.</p>
        */
    export class RepositoryAlreadyExistsException extends __BaseException {
            readonly name: "RepositoryAlreadyExistsException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<RepositoryAlreadyExistsException, __BaseException>);
    }
    /**
        * <p>The list of tags on the repository is over the limit. The maximum number of tags that
        *             can be applied to a repository is 50.</p>
        */
    export class TooManyTagsException extends __BaseException {
            readonly name: "TooManyTagsException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyTagsException, __BaseException>);
    }
    export interface DeleteLifecyclePolicyRequest {
            /**
                * <p>The Amazon Web Services account ID associated with the registry that contains the repository.
                *             If you do not specify a registry, the default registry is assumed.</p>
                */
            registryId?: string;
            /**
                * <p>The name of the repository.</p>
                */
            repositoryName: string | undefined;
    }
    export namespace DeleteLifecyclePolicyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteLifecyclePolicyRequest) => any;
    }
    export interface DeleteLifecyclePolicyResponse {
            /**
                * <p>The registry ID associated with the request.</p>
                */
            registryId?: string;
            /**
                * <p>The repository name associated with the request.</p>
                */
            repositoryName?: string;
            /**
                * <p>The JSON lifecycle policy text.</p>
                */
            lifecyclePolicyText?: string;
            /**
                * <p>The time stamp of the last time that the lifecycle policy was run.</p>
                */
            lastEvaluatedAt?: Date;
    }
    export namespace DeleteLifecyclePolicyResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteLifecyclePolicyResponse) => any;
    }
    /**
        * <p>The lifecycle policy could not be found, and no policy is set to the
        *             repository.</p>
        */
    export class LifecyclePolicyNotFoundException extends __BaseException {
            readonly name: "LifecyclePolicyNotFoundException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<LifecyclePolicyNotFoundException, __BaseException>);
    }
    export interface DeletePullThroughCacheRuleRequest {
            /**
                * <p>The Amazon ECR repository prefix associated with the pull through cache rule to
                *             delete.</p>
                */
            ecrRepositoryPrefix: string | undefined;
            /**
                * <p>The Amazon Web Services account ID associated with the registry that contains the pull through cache
                *             rule. If you do not specify a registry, the default registry is assumed.</p>
                */
            registryId?: string;
    }
    export namespace DeletePullThroughCacheRuleRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeletePullThroughCacheRuleRequest) => any;
    }
    export interface DeletePullThroughCacheRuleResponse {
            /**
                * <p>The Amazon ECR repository prefix associated with the request.</p>
                */
            ecrRepositoryPrefix?: string;
            /**
                * <p>The upstream registry URL associated with the pull through cache rule.</p>
                */
            upstreamRegistryUrl?: string;
            /**
                * <p>The timestamp associated with the pull through cache rule.</p>
                */
            createdAt?: Date;
            /**
                * <p>The registry ID associated with the request.</p>
                */
            registryId?: string;
    }
    export namespace DeletePullThroughCacheRuleResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeletePullThroughCacheRuleResponse) => any;
    }
    /**
        * <p>The pull through cache rule was not found. Specify a valid pull through cache rule and
        *             try again.</p>
        */
    export class PullThroughCacheRuleNotFoundException extends __BaseException {
            readonly name: "PullThroughCacheRuleNotFoundException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<PullThroughCacheRuleNotFoundException, __BaseException>);
    }
    export interface DeleteRegistryPolicyRequest {
    }
    export namespace DeleteRegistryPolicyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteRegistryPolicyRequest) => any;
    }
    export interface DeleteRegistryPolicyResponse {
            /**
                * <p>The registry ID associated with the request.</p>
                */
            registryId?: string;
            /**
                * <p>The contents of the registry permissions policy that was deleted.</p>
                */
            policyText?: string;
    }
    export namespace DeleteRegistryPolicyResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteRegistryPolicyResponse) => any;
    }
    /**
        * <p>The registry doesn't have an associated registry policy.</p>
        */
    export class RegistryPolicyNotFoundException extends __BaseException {
            readonly name: "RegistryPolicyNotFoundException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<RegistryPolicyNotFoundException, __BaseException>);
    }
    export interface DeleteRepositoryRequest {
            /**
                * <p>The Amazon Web Services account ID associated with the registry that contains the repository to
                *             delete. If you do not specify a registry, the default registry is assumed.</p>
                */
            registryId?: string;
            /**
                * <p>The name of the repository to delete.</p>
                */
            repositoryName: string | undefined;
            /**
                * <p> If a repository contains images, forces the deletion.</p>
                */
            force?: boolean;
    }
    export namespace DeleteRepositoryRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteRepositoryRequest) => any;
    }
    export interface DeleteRepositoryResponse {
            /**
                * <p>The repository that was deleted.</p>
                */
            repository?: Repository;
    }
    export namespace DeleteRepositoryResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteRepositoryResponse) => any;
    }
    /**
        * <p>The specified repository contains images. To delete a repository that contains images,
        *             you must force the deletion with the <code>force</code> parameter.</p>
        */
    export class RepositoryNotEmptyException extends __BaseException {
            readonly name: "RepositoryNotEmptyException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<RepositoryNotEmptyException, __BaseException>);
    }
    export interface DeleteRepositoryPolicyRequest {
            /**
                * <p>The Amazon Web Services account ID associated with the registry that contains the repository policy
                *             to delete. If you do not specify a registry, the default registry is assumed.</p>
                */
            registryId?: string;
            /**
                * <p>The name of the repository that is associated with the repository policy to
                *             delete.</p>
                */
            repositoryName: string | undefined;
    }
    export namespace DeleteRepositoryPolicyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteRepositoryPolicyRequest) => any;
    }
    export interface DeleteRepositoryPolicyResponse {
            /**
                * <p>The registry ID associated with the request.</p>
                */
            registryId?: string;
            /**
                * <p>The repository name associated with the request.</p>
                */
            repositoryName?: string;
            /**
                * <p>The JSON repository policy that was deleted from the repository.</p>
                */
            policyText?: string;
    }
    export namespace DeleteRepositoryPolicyResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteRepositoryPolicyResponse) => any;
    }
    /**
        * <p>The specified repository and registry combination does not have an associated
        *             repository policy.</p>
        */
    export class RepositoryPolicyNotFoundException extends __BaseException {
            readonly name: "RepositoryPolicyNotFoundException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<RepositoryPolicyNotFoundException, __BaseException>);
    }
    export interface DescribeImageReplicationStatusRequest {
            /**
                * <p>The name of the repository that the image is in.</p>
                */
            repositoryName: string | undefined;
            /**
                * <p>An object with identifying information for an image in an Amazon ECR repository.</p>
                */
            imageId: ImageIdentifier | undefined;
            /**
                * <p>The Amazon Web Services account ID associated with the registry. If you do not specify a registry, the default registry is assumed.</p>
                */
            registryId?: string;
    }
    export namespace DescribeImageReplicationStatusRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeImageReplicationStatusRequest) => any;
    }
    export enum ReplicationStatus {
            COMPLETE = "COMPLETE",
            FAILED = "FAILED",
            IN_PROGRESS = "IN_PROGRESS"
    }
    /**
        * <p>The status of the replication process for an image.</p>
        */
    export interface ImageReplicationStatus {
            /**
                * <p>The destination Region for the image replication.</p>
                */
            region?: string;
            /**
                * <p>The Amazon Web Services account ID associated with the registry to which the image belongs.</p>
                */
            registryId?: string;
            /**
                * <p>The image replication status.</p>
                */
            status?: ReplicationStatus | string;
            /**
                * <p>The failure code for a replication that has failed.</p>
                */
            failureCode?: string;
    }
    export namespace ImageReplicationStatus {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ImageReplicationStatus) => any;
    }
    export interface DescribeImageReplicationStatusResponse {
            /**
                * <p>The repository name associated with the request.</p>
                */
            repositoryName?: string;
            /**
                * <p>An object with identifying information for an image in an Amazon ECR repository.</p>
                */
            imageId?: ImageIdentifier;
            /**
                * <p>The replication status details for the images in the specified repository.</p>
                */
            replicationStatuses?: ImageReplicationStatus[];
    }
    export namespace DescribeImageReplicationStatusResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeImageReplicationStatusResponse) => any;
    }
    /**
        * <p>The image requested does not exist in the specified repository.</p>
        */
    export class ImageNotFoundException extends __BaseException {
            readonly name: "ImageNotFoundException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ImageNotFoundException, __BaseException>);
    }
    export enum TagStatus {
            ANY = "ANY",
            TAGGED = "TAGGED",
            UNTAGGED = "UNTAGGED"
    }
    /**
        * <p>An object representing a filter on a <a>DescribeImages</a>
        *             operation.</p>
        */
    export interface DescribeImagesFilter {
            /**
                * <p>The tag status with which to filter your <a>DescribeImages</a> results. You
                *             can filter results based on whether they are <code>TAGGED</code> or
                *                 <code>UNTAGGED</code>.</p>
                */
            tagStatus?: TagStatus | string;
    }
    export namespace DescribeImagesFilter {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeImagesFilter) => any;
    }
    export interface DescribeImagesRequest {
            /**
                * <p>The Amazon Web Services account ID associated with the registry that contains the repository in
                *             which to describe images. If you do not specify a registry, the default registry is assumed.</p>
                */
            registryId?: string;
            /**
                * <p>The repository that contains the images to describe.</p>
                */
            repositoryName: string | undefined;
            /**
                * <p>The list of image IDs for the requested repository.</p>
                */
            imageIds?: ImageIdentifier[];
            /**
                * <p>The <code>nextToken</code> value returned from a previous paginated
                *                 <code>DescribeImages</code> request where <code>maxResults</code> was used and the
                *             results exceeded the value of that parameter. Pagination continues from the end of the
                *             previous results that returned the <code>nextToken</code> value. This value is
                *                 <code>null</code> when there are no more results to return. This option cannot be
                *             used when you specify images with <code>imageIds</code>.</p>
                */
            nextToken?: string;
            /**
                * <p>The maximum number of repository results returned by <code>DescribeImages</code> in
                *             paginated output. When this parameter is used, <code>DescribeImages</code> only returns
                *                 <code>maxResults</code> results in a single page along with a <code>nextToken</code>
                *             response element. The remaining results of the initial request can be seen by sending
                *             another <code>DescribeImages</code> request with the returned <code>nextToken</code>
                *             value. This value can be between 1 and 1000. If this
                *             parameter is not used, then <code>DescribeImages</code> returns up to
                *             100 results and a <code>nextToken</code> value, if applicable. This
                *             option cannot be used when you specify images with <code>imageIds</code>.</p>
                */
            maxResults?: number;
            /**
                * <p>The filter key and value with which to filter your <code>DescribeImages</code>
                *             results.</p>
                */
            filter?: DescribeImagesFilter;
    }
    export namespace DescribeImagesRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeImagesRequest) => any;
    }
    export enum FindingSeverity {
            CRITICAL = "CRITICAL",
            HIGH = "HIGH",
            INFORMATIONAL = "INFORMATIONAL",
            LOW = "LOW",
            MEDIUM = "MEDIUM",
            UNDEFINED = "UNDEFINED"
    }
    /**
        * <p>A summary of the last completed image scan.</p>
        */
    export interface ImageScanFindingsSummary {
            /**
                * <p>The time of the last completed image scan.</p>
                */
            imageScanCompletedAt?: Date;
            /**
                * <p>The time when the vulnerability data was last scanned.</p>
                */
            vulnerabilitySourceUpdatedAt?: Date;
            /**
                * <p>The image vulnerability counts, sorted by severity.</p>
                */
            findingSeverityCounts?: Record<string, number>;
    }
    export namespace ImageScanFindingsSummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ImageScanFindingsSummary) => any;
    }
    export enum ScanStatus {
            ACTIVE = "ACTIVE",
            COMPLETE = "COMPLETE",
            FAILED = "FAILED",
            FINDINGS_UNAVAILABLE = "FINDINGS_UNAVAILABLE",
            IN_PROGRESS = "IN_PROGRESS",
            PENDING = "PENDING",
            SCAN_ELIGIBILITY_EXPIRED = "SCAN_ELIGIBILITY_EXPIRED",
            UNSUPPORTED_IMAGE = "UNSUPPORTED_IMAGE"
    }
    /**
        * <p>The current status of an image scan.</p>
        */
    export interface ImageScanStatus {
            /**
                * <p>The current state of an image scan.</p>
                */
            status?: ScanStatus | string;
            /**
                * <p>The description of the image scan status.</p>
                */
            description?: string;
    }
    export namespace ImageScanStatus {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ImageScanStatus) => any;
    }
    /**
        * <p>An object that describes an image returned by a <a>DescribeImages</a>
        *             operation.</p>
        */
    export interface ImageDetail {
            /**
                * <p>The Amazon Web Services account ID associated with the registry to which this image belongs.</p>
                */
            registryId?: string;
            /**
                * <p>The name of the repository to which this image belongs.</p>
                */
            repositoryName?: string;
            /**
                * <p>The <code>sha256</code> digest of the image manifest.</p>
                */
            imageDigest?: string;
            /**
                * <p>The list of tags associated with this image.</p>
                */
            imageTags?: string[];
            /**
                * <p>The size, in bytes, of the image in the repository.</p>
                *         <p>If the image is a manifest list, this will be the max size of all manifests in the
                *             list.</p>
                *         <note>
                *             <p>Beginning with Docker version 1.9, the Docker client compresses image layers
                *                 before pushing them to a V2 Docker registry. The output of the <code>docker
                *                     images</code> command shows the uncompressed image size, so it may return a
                *                 larger image size than the image sizes returned by <a>DescribeImages</a>.</p>
                *         </note>
                */
            imageSizeInBytes?: number;
            /**
                * <p>The date and time, expressed in standard JavaScript date format, at which the current
                *             image was pushed to the repository. </p>
                */
            imagePushedAt?: Date;
            /**
                * <p>The current state of the scan.</p>
                */
            imageScanStatus?: ImageScanStatus;
            /**
                * <p>A summary of the last completed image scan.</p>
                */
            imageScanFindingsSummary?: ImageScanFindingsSummary;
            /**
                * <p>The media type of the image manifest.</p>
                */
            imageManifestMediaType?: string;
            /**
                * <p>The artifact media type of the image.</p>
                */
            artifactMediaType?: string;
            /**
                * <p>The date and time, expressed in standard JavaScript date format, when Amazon ECR recorded
                *             the last image pull.</p>
                *         <note>
                *             <p>Amazon ECR refreshes the last image pull timestamp at least once every 24 hours. For
                *                 example, if you pull an image once a day then the <code>lastRecordedPullTime</code>
                *                 timestamp will indicate the exact time that the image was last pulled. However, if
                *                 you pull an image once an hour, because Amazon ECR refreshes the
                *                     <code>lastRecordedPullTime</code> timestamp at least once every 24 hours, the
                *                 result may not be the exact time that the image was last pulled.</p>
                *         </note>
                */
            lastRecordedPullTime?: Date;
    }
    export namespace ImageDetail {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ImageDetail) => any;
    }
    export interface DescribeImagesResponse {
            /**
                * <p>A list of <a>ImageDetail</a> objects that contain data about the
                *             image.</p>
                */
            imageDetails?: ImageDetail[];
            /**
                * <p>The <code>nextToken</code> value to include in a future <code>DescribeImages</code>
                *             request. When the results of a <code>DescribeImages</code> request exceed
                *                 <code>maxResults</code>, this value can be used to retrieve the next page of
                *             results. This value is <code>null</code> when there are no more results to
                *             return.</p>
                */
            nextToken?: string;
    }
    export namespace DescribeImagesResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeImagesResponse) => any;
    }
    export interface DescribeImageScanFindingsRequest {
            /**
                * <p>The Amazon Web Services account ID associated with the registry that contains the repository in
                *             which to describe the image scan findings for. If you do not specify a registry, the default registry is assumed.</p>
                */
            registryId?: string;
            /**
                * <p>The repository for the image for which to describe the scan findings.</p>
                */
            repositoryName: string | undefined;
            /**
                * <p>An object with identifying information for an image in an Amazon ECR repository.</p>
                */
            imageId: ImageIdentifier | undefined;
            /**
                * <p>The <code>nextToken</code> value returned from a previous paginated
                *                 <code>DescribeImageScanFindings</code> request where <code>maxResults</code> was
                *             used and the results exceeded the value of that parameter. Pagination continues from the
                *             end of the previous results that returned the <code>nextToken</code> value. This value
                *             is null when there are no more results to return.</p>
                */
            nextToken?: string;
            /**
                * <p>The maximum number of image scan results returned by
                *                 <code>DescribeImageScanFindings</code> in paginated output. When this parameter is
                *             used, <code>DescribeImageScanFindings</code> only returns <code>maxResults</code>
                *             results in a single page along with a <code>nextToken</code> response element. The
                *             remaining results of the initial request can be seen by sending another
                *                 <code>DescribeImageScanFindings</code> request with the returned
                *                 <code>nextToken</code> value. This value can be between 1 and 1000. If this
                *             parameter is not used, then <code>DescribeImageScanFindings</code> returns up to 100
                *             results and a <code>nextToken</code> value, if applicable.</p>
                */
            maxResults?: number;
    }
    export namespace DescribeImageScanFindingsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeImageScanFindingsRequest) => any;
    }
    /**
        * <p>The CVSS score for a finding.</p>
        */
    export interface CvssScore {
            /**
                * <p>The base CVSS score used for the finding.</p>
                */
            baseScore?: number;
            /**
                * <p>The vector string of the CVSS score.</p>
                */
            scoringVector?: string;
            /**
                * <p>The source of the CVSS score.</p>
                */
            source?: string;
            /**
                * <p>The version of CVSS used for the score.</p>
                */
            version?: string;
    }
    export namespace CvssScore {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CvssScore) => any;
    }
    /**
        * <p>Information on the vulnerable package identified by a finding.</p>
        */
    export interface VulnerablePackage {
            /**
                * <p>The architecture of the vulnerable package.</p>
                */
            arch?: string;
            /**
                * <p>The epoch of the vulnerable package.</p>
                */
            epoch?: number;
            /**
                * <p>The file path of the vulnerable package.</p>
                */
            filePath?: string;
            /**
                * <p>The name of the vulnerable package.</p>
                */
            name?: string;
            /**
                * <p>The package manager of the vulnerable package.</p>
                */
            packageManager?: string;
            /**
                * <p>The release of the vulnerable package.</p>
                */
            release?: string;
            /**
                * <p>The source layer hash of the vulnerable package.</p>
                */
            sourceLayerHash?: string;
            /**
                * <p>The version of the vulnerable package.</p>
                */
            version?: string;
    }
    export namespace VulnerablePackage {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: VulnerablePackage) => any;
    }
    /**
        * <p>Information about a package vulnerability finding.</p>
        */
    export interface PackageVulnerabilityDetails {
            /**
                * <p>An object that contains details about the CVSS score of a finding.</p>
                */
            cvss?: CvssScore[];
            /**
                * <p>One or more URLs that contain details about this vulnerability type.</p>
                */
            referenceUrls?: string[];
            /**
                * <p>One or more vulnerabilities related to the one identified in this finding.</p>
                */
            relatedVulnerabilities?: string[];
            /**
                * <p>The source of the vulnerability information.</p>
                */
            source?: string;
            /**
                * <p>A URL to the source of the vulnerability information.</p>
                */
            sourceUrl?: string;
            /**
                * <p>The date and time that this vulnerability was first added to the vendor's
                *             database.</p>
                */
            vendorCreatedAt?: Date;
            /**
                * <p>The severity the vendor has given to this vulnerability type.</p>
                */
            vendorSeverity?: string;
            /**
                * <p>The date and time the vendor last updated this vulnerability in their database.</p>
                */
            vendorUpdatedAt?: Date;
            /**
                * <p>The ID given to this vulnerability.</p>
                */
            vulnerabilityId?: string;
            /**
                * <p>The packages impacted by this vulnerability.</p>
                */
            vulnerablePackages?: VulnerablePackage[];
    }
    export namespace PackageVulnerabilityDetails {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PackageVulnerabilityDetails) => any;
    }
    /**
        * <p>Details about the recommended course of action to remediate the finding.</p>
        */
    export interface Recommendation {
            /**
                * <p>The URL address to the CVE remediation recommendations.</p>
                */
            url?: string;
            /**
                * <p>The recommended course of action to remediate the finding.</p>
                */
            text?: string;
    }
    export namespace Recommendation {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Recommendation) => any;
    }
    /**
        * <p>Information on how to remediate a finding.</p>
        */
    export interface Remediation {
            /**
                * <p>An object that contains information about the recommended course of action to
                *             remediate the finding.</p>
                */
            recommendation?: Recommendation;
    }
    export namespace Remediation {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Remediation) => any;
    }
    /**
        * <p>The image details of the Amazon ECR container image.</p>
        */
    export interface AwsEcrContainerImageDetails {
            /**
                * <p>The architecture of the Amazon ECR container image.</p>
                */
            architecture?: string;
            /**
                * <p>The image author of the Amazon ECR container image.</p>
                */
            author?: string;
            /**
                * <p>The image hash of the Amazon ECR container image.</p>
                */
            imageHash?: string;
            /**
                * <p>The image tags attached to the Amazon ECR container image.</p>
                */
            imageTags?: string[];
            /**
                * <p>The platform of the Amazon ECR container image.</p>
                */
            platform?: string;
            /**
                * <p>The date and time the Amazon ECR container image was pushed.</p>
                */
            pushedAt?: Date;
            /**
                * <p>The registry the Amazon ECR container image belongs to.</p>
                */
            registry?: string;
            /**
                * <p>The name of the repository the Amazon ECR container image resides in.</p>
                */
            repositoryName?: string;
    }
    export namespace AwsEcrContainerImageDetails {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AwsEcrContainerImageDetails) => any;
    }
    /**
        * <p>Contains details about the resource involved in the finding.</p>
        */
    export interface ResourceDetails {
            /**
                * <p>An object that contains details about the Amazon ECR container image involved in the
                *             finding.</p>
                */
            awsEcrContainerImage?: AwsEcrContainerImageDetails;
    }
    export namespace ResourceDetails {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ResourceDetails) => any;
    }
    /**
        * <p>Details about the resource involved in a finding.</p>
        */
    export interface Resource {
            /**
                * <p>An object that contains details about the resource involved in a finding.</p>
                */
            details?: ResourceDetails;
            /**
                * <p>The ID of the resource.</p>
                */
            id?: string;
            /**
                * <p>The tags attached to the resource.</p>
                */
            tags?: Record<string, string>;
            /**
                * <p>The type of resource.</p>
                */
            type?: string;
    }
    export namespace Resource {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Resource) => any;
    }
    /**
        * <p>Details on adjustments Amazon Inspector made to the CVSS score for a finding.</p>
        */
    export interface CvssScoreAdjustment {
            /**
                * <p>The metric used to adjust the CVSS score.</p>
                */
            metric?: string;
            /**
                * <p>The reason the CVSS score has been adjustment.</p>
                */
            reason?: string;
    }
    export namespace CvssScoreAdjustment {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CvssScoreAdjustment) => any;
    }
    /**
        * <p>Information about the CVSS score.</p>
        */
    export interface CvssScoreDetails {
            /**
                * <p>An object that contains details about adjustment Amazon Inspector made to the CVSS score.</p>
                */
            adjustments?: CvssScoreAdjustment[];
            /**
                * <p>The CVSS score.</p>
                */
            score?: number;
            /**
                * <p>The source for the CVSS score.</p>
                */
            scoreSource?: string;
            /**
                * <p>The vector for the CVSS score.</p>
                */
            scoringVector?: string;
            /**
                * <p>The CVSS version used in scoring.</p>
                */
            version?: string;
    }
    export namespace CvssScoreDetails {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CvssScoreDetails) => any;
    }
    /**
        * <p>Information about the Amazon Inspector score given to a finding.</p>
        */
    export interface ScoreDetails {
            /**
                * <p>An object that contains details about the CVSS score given to a finding.</p>
                */
            cvss?: CvssScoreDetails;
    }
    export namespace ScoreDetails {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ScoreDetails) => any;
    }
    /**
        * <p>The details of an enhanced image scan. This is returned when enhanced scanning is
        *             enabled for your private registry.</p>
        */
    export interface EnhancedImageScanFinding {
            /**
                * <p>The Amazon Web Services account ID associated with the image.</p>
                */
            awsAccountId?: string;
            /**
                * <p>The description of the finding.</p>
                */
            description?: string;
            /**
                * <p>The Amazon Resource Number (ARN) of the finding.</p>
                */
            findingArn?: string;
            /**
                * <p>The date and time that the finding was first observed.</p>
                */
            firstObservedAt?: Date;
            /**
                * <p>The date and time that the finding was last observed.</p>
                */
            lastObservedAt?: Date;
            /**
                * <p>An object that contains the details of a package vulnerability finding.</p>
                */
            packageVulnerabilityDetails?: PackageVulnerabilityDetails;
            /**
                * <p>An object that contains the details about how to remediate a finding.</p>
                */
            remediation?: Remediation;
            /**
                * <p>Contains information on the resources involved in a finding.</p>
                */
            resources?: Resource[];
            /**
                * <p>The Amazon Inspector score given to the finding.</p>
                */
            score?: number;
            /**
                * <p>An object that contains details of the Amazon Inspector score.</p>
                */
            scoreDetails?: ScoreDetails;
            /**
                * <p>The severity of the finding.</p>
                */
            severity?: string;
            /**
                * <p>The status of the finding.</p>
                */
            status?: string;
            /**
                * <p>The title of the finding.</p>
                */
            title?: string;
            /**
                * <p>The type of the finding.</p>
                */
            type?: string;
            /**
                * <p>The date and time the finding was last updated at.</p>
                */
            updatedAt?: Date;
    }
    export namespace EnhancedImageScanFinding {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: EnhancedImageScanFinding) => any;
    }
    /**
        * <p>This data type is used in the <a>ImageScanFinding</a> data type.</p>
        */
    export interface Attribute {
            /**
                * <p>The attribute key.</p>
                */
            key: string | undefined;
            /**
                * <p>The value assigned to the attribute key.</p>
                */
            value?: string;
    }
    export namespace Attribute {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Attribute) => any;
    }
    /**
        * <p>Contains information about an image scan finding.</p>
        */
    export interface ImageScanFinding {
            /**
                * <p>The name associated with the finding, usually a CVE number.</p>
                */
            name?: string;
            /**
                * <p>The description of the finding.</p>
                */
            description?: string;
            /**
                * <p>A link containing additional details about the security vulnerability.</p>
                */
            uri?: string;
            /**
                * <p>The finding severity.</p>
                */
            severity?: FindingSeverity | string;
            /**
                * <p>A collection of attributes of the host from which the finding is generated.</p>
                */
            attributes?: Attribute[];
    }
    export namespace ImageScanFinding {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ImageScanFinding) => any;
    }
    /**
        * <p>The details of an image scan.</p>
        */
    export interface ImageScanFindings {
            /**
                * <p>The time of the last completed image scan.</p>
                */
            imageScanCompletedAt?: Date;
            /**
                * <p>The time when the vulnerability data was last scanned.</p>
                */
            vulnerabilitySourceUpdatedAt?: Date;
            /**
                * <p>The image vulnerability counts, sorted by severity.</p>
                */
            findingSeverityCounts?: Record<string, number>;
            /**
                * <p>The findings from the image scan.</p>
                */
            findings?: ImageScanFinding[];
            /**
                * <p>Details about the enhanced scan findings from Amazon Inspector.</p>
                */
            enhancedFindings?: EnhancedImageScanFinding[];
    }
    export namespace ImageScanFindings {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ImageScanFindings) => any;
    }
    export interface DescribeImageScanFindingsResponse {
            /**
                * <p>The registry ID associated with the request.</p>
                */
            registryId?: string;
            /**
                * <p>The repository name associated with the request.</p>
                */
            repositoryName?: string;
            /**
                * <p>An object with identifying information for an image in an Amazon ECR repository.</p>
                */
            imageId?: ImageIdentifier;
            /**
                * <p>The current state of the scan.</p>
                */
            imageScanStatus?: ImageScanStatus;
            /**
                * <p>The information contained in the image scan findings.</p>
                */
            imageScanFindings?: ImageScanFindings;
            /**
                * <p>The <code>nextToken</code> value to include in a future
                *                 <code>DescribeImageScanFindings</code> request. When the results of a
                *                 <code>DescribeImageScanFindings</code> request exceed <code>maxResults</code>, this
                *             value can be used to retrieve the next page of results. This value is null when there
                *             are no more results to return.</p>
                */
            nextToken?: string;
    }
    export namespace DescribeImageScanFindingsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeImageScanFindingsResponse) => any;
    }
    /**
        * <p>The specified image scan could not be found. Ensure that image scanning is enabled on
        *             the repository and try again.</p>
        */
    export class ScanNotFoundException extends __BaseException {
            readonly name: "ScanNotFoundException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ScanNotFoundException, __BaseException>);
    }
    export interface DescribePullThroughCacheRulesRequest {
            /**
                * <p>The Amazon Web Services account ID associated with the registry to return the pull through cache
                *             rules for. If you do not specify a registry, the default registry is assumed.</p>
                */
            registryId?: string;
            /**
                * <p>The Amazon ECR repository prefixes associated with the pull through cache rules to return.
                *             If no repository prefix value is specified, all pull through cache rules are
                *             returned.</p>
                */
            ecrRepositoryPrefixes?: string[];
            /**
                * <p>The <code>nextToken</code> value returned from a previous paginated
                *                 <code>DescribePullThroughCacheRulesRequest</code> request where
                *                 <code>maxResults</code> was used and the results exceeded the value of that
                *             parameter. Pagination continues from the end of the previous results that returned the
                *                 <code>nextToken</code> value. This value is null when there are no more results to
                *             return.</p>
                */
            nextToken?: string;
            /**
                * <p>The maximum number of pull through cache rules returned by
                *                 <code>DescribePullThroughCacheRulesRequest</code> in paginated output. When this
                *             parameter is used, <code>DescribePullThroughCacheRulesRequest</code> only returns
                *                 <code>maxResults</code> results in a single page along with a <code>nextToken</code>
                *             response element. The remaining results of the initial request can be seen by sending
                *             another <code>DescribePullThroughCacheRulesRequest</code> request with the returned
                *                 <code>nextToken</code> value. This value can be between 1 and 1000. If this
                *             parameter is not used, then <code>DescribePullThroughCacheRulesRequest</code> returns up
                *             to 100 results and a <code>nextToken</code> value, if applicable.</p>
                */
            maxResults?: number;
    }
    export namespace DescribePullThroughCacheRulesRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribePullThroughCacheRulesRequest) => any;
    }
    /**
        * <p>The details of a pull through cache rule.</p>
        */
    export interface PullThroughCacheRule {
            /**
                * <p>The Amazon ECR repository prefix associated with the pull through cache rule.</p>
                */
            ecrRepositoryPrefix?: string;
            /**
                * <p>The upstream registry URL associated with the pull through cache rule.</p>
                */
            upstreamRegistryUrl?: string;
            /**
                * <p>The date and time the pull through cache was created.</p>
                */
            createdAt?: Date;
            /**
                * <p>The Amazon Web Services account ID associated with the registry the pull through cache rule is
                *             associated with.</p>
                */
            registryId?: string;
    }
    export namespace PullThroughCacheRule {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PullThroughCacheRule) => any;
    }
    export interface DescribePullThroughCacheRulesResponse {
            /**
                * <p>The details of the pull through cache rules.</p>
                */
            pullThroughCacheRules?: PullThroughCacheRule[];
            /**
                * <p>The <code>nextToken</code> value to include in a future
                *                 <code>DescribePullThroughCacheRulesRequest</code> request. When the results of a
                *                 <code>DescribePullThroughCacheRulesRequest</code> request exceed
                *                 <code>maxResults</code>, this value can be used to retrieve the next page of
                *             results. This value is null when there are no more results to return.</p>
                */
            nextToken?: string;
    }
    export namespace DescribePullThroughCacheRulesResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribePullThroughCacheRulesResponse) => any;
    }
    export interface DescribeRegistryRequest {
    }
    export namespace DescribeRegistryRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeRegistryRequest) => any;
    }
    /**
        * <p>An array of objects representing the destination for a replication rule.</p>
        */
    export interface ReplicationDestination {
            /**
                * <p>The Region to replicate to.</p>
                */
            region: string | undefined;
            /**
                * <p>The Amazon Web Services account ID of the Amazon ECR private registry to replicate to. When configuring
                *             cross-Region replication within your own registry, specify your own account ID.</p>
                */
            registryId: string | undefined;
    }
    export namespace ReplicationDestination {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ReplicationDestination) => any;
    }
    export enum RepositoryFilterType {
            PREFIX_MATCH = "PREFIX_MATCH"
    }
    /**
        * <p>The filter settings used with image replication. Specifying a repository filter to a
        *             replication rule provides a method for controlling which repositories in a private
        *             registry are replicated. If no repository filter is specified, all images in the
        *             repository are replicated.</p>
        */
    export interface RepositoryFilter {
            /**
                * <p>The repository filter details. When the <code>PREFIX_MATCH</code> filter type is
                *             specified, this value is required and should be the repository name prefix to configure
                *             replication for.</p>
                */
            filter: string | undefined;
            /**
                * <p>The repository filter type. The only supported value is <code>PREFIX_MATCH</code>,
                *             which is a repository name prefix specified with the <code>filter</code>
                *             parameter.</p>
                */
            filterType: RepositoryFilterType | string | undefined;
    }
    export namespace RepositoryFilter {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RepositoryFilter) => any;
    }
    /**
        * <p>An array of objects representing the replication destinations and repository filters
        *             for a replication configuration.</p>
        */
    export interface ReplicationRule {
            /**
                * <p>An array of objects representing the destination for a replication rule.</p>
                */
            destinations: ReplicationDestination[] | undefined;
            /**
                * <p>An array of objects representing the filters for a replication rule. Specifying a
                *             repository filter for a replication rule provides a method for controlling which
                *             repositories in a private registry are replicated.</p>
                */
            repositoryFilters?: RepositoryFilter[];
    }
    export namespace ReplicationRule {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ReplicationRule) => any;
    }
    /**
        * <p>The replication configuration for a registry.</p>
        */
    export interface ReplicationConfiguration {
            /**
                * <p>An array of objects representing the replication destinations and repository filters
                *             for a replication configuration.</p>
                */
            rules: ReplicationRule[] | undefined;
    }
    export namespace ReplicationConfiguration {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ReplicationConfiguration) => any;
    }
    export interface DescribeRegistryResponse {
            /**
                * <p>The ID of the registry.</p>
                */
            registryId?: string;
            /**
                * <p>The replication configuration for the registry.</p>
                */
            replicationConfiguration?: ReplicationConfiguration;
    }
    export namespace DescribeRegistryResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeRegistryResponse) => any;
    }
    export interface DescribeRepositoriesRequest {
            /**
                * <p>The Amazon Web Services account ID associated with the registry that contains the repositories to be
                *             described. If you do not specify a registry, the default registry is assumed.</p>
                */
            registryId?: string;
            /**
                * <p>A list of repositories to describe. If this parameter is omitted, then all
                *             repositories in a registry are described.</p>
                */
            repositoryNames?: string[];
            /**
                * <p>The <code>nextToken</code> value returned from a previous paginated
                *                 <code>DescribeRepositories</code> request where <code>maxResults</code> was used and
                *             the results exceeded the value of that parameter. Pagination continues from the end of
                *             the previous results that returned the <code>nextToken</code> value. This value is
                *                 <code>null</code> when there are no more results to return. This option cannot be
                *             used when you specify repositories with <code>repositoryNames</code>.</p>
                *         <note>
                *             <p>This token should be treated as an opaque identifier that is only used to
                *                 retrieve the next items in a list and not for other programmatic purposes.</p>
                *         </note>
                */
            nextToken?: string;
            /**
                * <p>The maximum number of repository results returned by <code>DescribeRepositories</code>
                *             in paginated output. When this parameter is used, <code>DescribeRepositories</code> only
                *             returns <code>maxResults</code> results in a single page along with a
                *                 <code>nextToken</code> response element. The remaining results of the initial
                *             request can be seen by sending another <code>DescribeRepositories</code> request with
                *             the returned <code>nextToken</code> value. This value can be between 1
                *             and 1000. If this parameter is not used, then
                *                 <code>DescribeRepositories</code> returns up to 100 results and a
                *                 <code>nextToken</code> value, if applicable. This option cannot be used when you
                *             specify repositories with <code>repositoryNames</code>.</p>
                */
            maxResults?: number;
    }
    export namespace DescribeRepositoriesRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeRepositoriesRequest) => any;
    }
    export interface DescribeRepositoriesResponse {
            /**
                * <p>A list of repository objects corresponding to valid repositories.</p>
                */
            repositories?: Repository[];
            /**
                * <p>The <code>nextToken</code> value to include in a future
                *                 <code>DescribeRepositories</code> request. When the results of a
                *                 <code>DescribeRepositories</code> request exceed <code>maxResults</code>, this value
                *             can be used to retrieve the next page of results. This value is <code>null</code> when
                *             there are no more results to return.</p>
                */
            nextToken?: string;
    }
    export namespace DescribeRepositoriesResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeRepositoriesResponse) => any;
    }
    export interface GetAuthorizationTokenRequest {
            /**
                * @deprecated
                *
                * <p>A list of Amazon Web Services account IDs that are associated with the registries for which to get
                *             AuthorizationData objects. If you do not specify a registry, the default registry is assumed.</p>
                */
            registryIds?: string[];
    }
    export namespace GetAuthorizationTokenRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetAuthorizationTokenRequest) => any;
    }
    /**
        * <p>An object representing authorization data for an Amazon ECR registry.</p>
        */
    export interface AuthorizationData {
            /**
                * <p>A base64-encoded string that contains authorization data for the specified Amazon ECR
                *             registry. When the string is decoded, it is presented in the format
                *                 <code>user:password</code> for private registry authentication using <code>docker
                *                 login</code>.</p>
                */
            authorizationToken?: string;
            /**
                * <p>The Unix time in seconds and milliseconds when the authorization token expires.
                *             Authorization tokens are valid for 12 hours.</p>
                */
            expiresAt?: Date;
            /**
                * <p>The registry URL to use for this authorization token in a <code>docker login</code>
                *             command. The Amazon ECR registry URL format is
                *         <code>https://aws_account_id.dkr.ecr.region.amazonaws.com</code>. For example,
                *         <code>https://012345678910.dkr.ecr.us-east-1.amazonaws.com</code>.. </p>
                */
            proxyEndpoint?: string;
    }
    export namespace AuthorizationData {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AuthorizationData) => any;
    }
    export interface GetAuthorizationTokenResponse {
            /**
                * <p>A list of authorization token data objects that correspond to the
                *                 <code>registryIds</code> values in the request.</p>
                */
            authorizationData?: AuthorizationData[];
    }
    export namespace GetAuthorizationTokenResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetAuthorizationTokenResponse) => any;
    }
    export interface GetDownloadUrlForLayerRequest {
            /**
                * <p>The Amazon Web Services account ID associated with the registry that contains the image layer to
                *             download. If you do not specify a registry, the default registry is assumed.</p>
                */
            registryId?: string;
            /**
                * <p>The name of the repository that is associated with the image layer to download.</p>
                */
            repositoryName: string | undefined;
            /**
                * <p>The digest of the image layer to download.</p>
                */
            layerDigest: string | undefined;
    }
    export namespace GetDownloadUrlForLayerRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetDownloadUrlForLayerRequest) => any;
    }
    export interface GetDownloadUrlForLayerResponse {
            /**
                * <p>The pre-signed Amazon S3 download URL for the requested layer.</p>
                */
            downloadUrl?: string;
            /**
                * <p>The digest of the image layer to download.</p>
                */
            layerDigest?: string;
    }
    export namespace GetDownloadUrlForLayerResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetDownloadUrlForLayerResponse) => any;
    }
    /**
        * <p>The specified layer is not available because it is not associated with an image.
        *             Unassociated image layers may be cleaned up at any time.</p>
        */
    export class LayerInaccessibleException extends __BaseException {
            readonly name: "LayerInaccessibleException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<LayerInaccessibleException, __BaseException>);
    }
    /**
        * <p>The specified layers could not be found, or the specified layer is not valid for this
        *             repository.</p>
        */
    export class LayersNotFoundException extends __BaseException {
            readonly name: "LayersNotFoundException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<LayersNotFoundException, __BaseException>);
    }
    export interface GetLifecyclePolicyRequest {
            /**
                * <p>The Amazon Web Services account ID associated with the registry that contains the repository.
                *             If you do not specify a registry, the default registry is assumed.</p>
                */
            registryId?: string;
            /**
                * <p>The name of the repository.</p>
                */
            repositoryName: string | undefined;
    }
    export namespace GetLifecyclePolicyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetLifecyclePolicyRequest) => any;
    }
    export interface GetLifecyclePolicyResponse {
            /**
                * <p>The registry ID associated with the request.</p>
                */
            registryId?: string;
            /**
                * <p>The repository name associated with the request.</p>
                */
            repositoryName?: string;
            /**
                * <p>The JSON lifecycle policy text.</p>
                */
            lifecyclePolicyText?: string;
            /**
                * <p>The time stamp of the last time that the lifecycle policy was run.</p>
                */
            lastEvaluatedAt?: Date;
    }
    export namespace GetLifecyclePolicyResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetLifecyclePolicyResponse) => any;
    }
    /**
        * <p>The filter for the lifecycle policy preview.</p>
        */
    export interface LifecyclePolicyPreviewFilter {
            /**
                * <p>The tag status of the image.</p>
                */
            tagStatus?: TagStatus | string;
    }
    export namespace LifecyclePolicyPreviewFilter {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: LifecyclePolicyPreviewFilter) => any;
    }
    export interface GetLifecyclePolicyPreviewRequest {
            /**
                * <p>The Amazon Web Services account ID associated with the registry that contains the repository.
                *             If you do not specify a registry, the default registry is assumed.</p>
                */
            registryId?: string;
            /**
                * <p>The name of the repository.</p>
                */
            repositoryName: string | undefined;
            /**
                * <p>The list of imageIDs to be included.</p>
                */
            imageIds?: ImageIdentifier[];
            /**
                * <p>The <code>nextToken</code> value returned from a previous paginated
                *                 <code>GetLifecyclePolicyPreviewRequest</code> request where <code>maxResults</code>
                *             was used and the
         results exceeded the value of that parameter. Pagination continues
                *             from the end of the
         previous results that returned the <code>nextToken</code> value.
                *             This value is
         <code>null</code> when there are no more results to return. This option
                *             cannot be used when you specify images with <code>imageIds</code>.</p>
                */
            nextToken?: string;
            /**
                * <p>The maximum number of repository results returned by
                *                 <code>GetLifecyclePolicyPreviewRequest</code> in
         paginated output. When this
                *             parameter is used, <code>GetLifecyclePolicyPreviewRequest</code> only returns
                *                 <code>maxResults</code> results in a single page along with a
                *             <code>nextToken</code>
         response element. The remaining results of the initial request
                *             can be seen by sending
         another <code>GetLifecyclePolicyPreviewRequest</code> request
                *             with the returned <code>nextToken</code>
         value. This value can be between
                *             1 and 1000. If this
         parameter is not used, then
                *                 <code>GetLifecyclePolicyPreviewRequest</code> returns up to
         100
                *             results and a <code>nextToken</code> value, if
         applicable. This option cannot be used
                *             when you specify images with <code>imageIds</code>.</p>
                */
            maxResults?: number;
            /**
                * <p>An optional parameter that filters results based on image tag status and all tags, if
                *             tagged.</p>
                */
            filter?: LifecyclePolicyPreviewFilter;
    }
    export namespace GetLifecyclePolicyPreviewRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetLifecyclePolicyPreviewRequest) => any;
    }
    export enum ImageActionType {
            EXPIRE = "EXPIRE"
    }
    /**
        * <p>The type of action to be taken.</p>
        */
    export interface LifecyclePolicyRuleAction {
            /**
                * <p>The type of action to be taken.</p>
                */
            type?: ImageActionType | string;
    }
    export namespace LifecyclePolicyRuleAction {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: LifecyclePolicyRuleAction) => any;
    }
    /**
        * <p>The result of the lifecycle policy preview.</p>
        */
    export interface LifecyclePolicyPreviewResult {
            /**
                * <p>The list of tags associated with this image.</p>
                */
            imageTags?: string[];
            /**
                * <p>The <code>sha256</code> digest of the image manifest.</p>
                */
            imageDigest?: string;
            /**
                * <p>The date and time, expressed in standard JavaScript date format, at which the current
                *             image was pushed to the repository.</p>
                */
            imagePushedAt?: Date;
            /**
                * <p>The type of action to be taken.</p>
                */
            action?: LifecyclePolicyRuleAction;
            /**
                * <p>The priority of the applied rule.</p>
                */
            appliedRulePriority?: number;
    }
    export namespace LifecyclePolicyPreviewResult {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: LifecyclePolicyPreviewResult) => any;
    }
    export enum LifecyclePolicyPreviewStatus {
            COMPLETE = "COMPLETE",
            EXPIRED = "EXPIRED",
            FAILED = "FAILED",
            IN_PROGRESS = "IN_PROGRESS"
    }
    /**
        * <p>The summary of the lifecycle policy preview request.</p>
        */
    export interface LifecyclePolicyPreviewSummary {
            /**
                * <p>The number of expiring images.</p>
                */
            expiringImageTotalCount?: number;
    }
    export namespace LifecyclePolicyPreviewSummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: LifecyclePolicyPreviewSummary) => any;
    }
    export interface GetLifecyclePolicyPreviewResponse {
            /**
                * <p>The registry ID associated with the request.</p>
                */
            registryId?: string;
            /**
                * <p>The repository name associated with the request.</p>
                */
            repositoryName?: string;
            /**
                * <p>The JSON lifecycle policy text.</p>
                */
            lifecyclePolicyText?: string;
            /**
                * <p>The status of the lifecycle policy preview request.</p>
                */
            status?: LifecyclePolicyPreviewStatus | string;
            /**
                * <p>The <code>nextToken</code> value to include in a future
                *                 <code>GetLifecyclePolicyPreview</code> request. When the results of a
                *                 <code>GetLifecyclePolicyPreview</code> request exceed <code>maxResults</code>, this
                *             value can be used to retrieve the next page of results. This value is <code>null</code>
                *             when there are no more results to return.</p>
                */
            nextToken?: string;
            /**
                * <p>The results of the lifecycle policy preview request.</p>
                */
            previewResults?: LifecyclePolicyPreviewResult[];
            /**
                * <p>The list of images that is returned as a result of the action.</p>
                */
            summary?: LifecyclePolicyPreviewSummary;
    }
    export namespace GetLifecyclePolicyPreviewResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetLifecyclePolicyPreviewResponse) => any;
    }
    /**
        * <p>There is no dry run for this repository.</p>
        */
    export class LifecyclePolicyPreviewNotFoundException extends __BaseException {
            readonly name: "LifecyclePolicyPreviewNotFoundException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<LifecyclePolicyPreviewNotFoundException, __BaseException>);
    }
    export interface GetRegistryPolicyRequest {
    }
    export namespace GetRegistryPolicyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetRegistryPolicyRequest) => any;
    }
    export interface GetRegistryPolicyResponse {
            /**
                * <p>The ID of the registry.</p>
                */
            registryId?: string;
            /**
                * <p>The JSON text of the permissions policy for a registry.</p>
                */
            policyText?: string;
    }
    export namespace GetRegistryPolicyResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetRegistryPolicyResponse) => any;
    }
    export interface GetRegistryScanningConfigurationRequest {
    }
    export namespace GetRegistryScanningConfigurationRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetRegistryScanningConfigurationRequest) => any;
    }
    /**
        * <p>The details of a scanning rule for a private registry.</p>
        */
    export interface RegistryScanningRule {
            /**
                * <p>The frequency that scans are performed at for a private registry. When the
                *                 <code>ENHANCED</code> scan type is specified, the supported scan frequencies are
                *                 <code>CONTINUOUS_SCAN</code> and <code>SCAN_ON_PUSH</code>. When the
                *                 <code>BASIC</code> scan type is specified, the <code>SCAN_ON_PUSH</code> and
                *                 <code>MANUAL</code> scan frequencies are supported.</p>
                */
            scanFrequency: ScanFrequency | string | undefined;
            /**
                * <p>The repository filters associated with the scanning configuration for a private
                *             registry.</p>
                */
            repositoryFilters: ScanningRepositoryFilter[] | undefined;
    }
    export namespace RegistryScanningRule {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RegistryScanningRule) => any;
    }
    export enum ScanType {
            BASIC = "BASIC",
            ENHANCED = "ENHANCED"
    }
    /**
        * <p>The scanning configuration for a private registry.</p>
        */
    export interface RegistryScanningConfiguration {
            /**
                * <p>The type of scanning configured for the registry.</p>
                */
            scanType?: ScanType | string;
            /**
                * <p>The scanning rules associated with the registry.</p>
                */
            rules?: RegistryScanningRule[];
    }
    export namespace RegistryScanningConfiguration {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RegistryScanningConfiguration) => any;
    }
    export interface GetRegistryScanningConfigurationResponse {
            /**
                * <p>The ID of the registry.</p>
                */
            registryId?: string;
            /**
                * <p>The scanning configuration for the registry.</p>
                */
            scanningConfiguration?: RegistryScanningConfiguration;
    }
    export namespace GetRegistryScanningConfigurationResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetRegistryScanningConfigurationResponse) => any;
    }
    export interface GetRepositoryPolicyRequest {
            /**
                * <p>The Amazon Web Services account ID associated with the registry that contains the repository.
                *             If you do not specify a registry, the default registry is assumed.</p>
                */
            registryId?: string;
            /**
                * <p>The name of the repository with the policy to retrieve.</p>
                */
            repositoryName: string | undefined;
    }
    export namespace GetRepositoryPolicyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetRepositoryPolicyRequest) => any;
    }
    export interface GetRepositoryPolicyResponse {
            /**
                * <p>The registry ID associated with the request.</p>
                */
            registryId?: string;
            /**
                * <p>The repository name associated with the request.</p>
                */
            repositoryName?: string;
            /**
                * <p>The JSON repository policy text associated with the repository.</p>
                */
            policyText?: string;
    }
    export namespace GetRepositoryPolicyResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetRepositoryPolicyResponse) => any;
    }
    export interface InitiateLayerUploadRequest {
            /**
                * <p>The Amazon Web Services account ID associated with the registry to which you intend to upload
                *             layers. If you do not specify a registry, the default registry is assumed.</p>
                */
            registryId?: string;
            /**
                * <p>The name of the repository to which you intend to upload layers.</p>
                */
            repositoryName: string | undefined;
    }
    export namespace InitiateLayerUploadRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: InitiateLayerUploadRequest) => any;
    }
    export interface InitiateLayerUploadResponse {
            /**
                * <p>The upload ID for the layer upload. This parameter is passed to further <a>UploadLayerPart</a> and <a>CompleteLayerUpload</a>
                *             operations.</p>
                */
            uploadId?: string;
            /**
                * <p>The size, in bytes, that Amazon ECR expects future layer part uploads to be.</p>
                */
            partSize?: number;
    }
    export namespace InitiateLayerUploadResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: InitiateLayerUploadResponse) => any;
    }
    /**
        * <p>An object representing a filter on a <a>ListImages</a> operation.</p>
        */
    export interface ListImagesFilter {
            /**
                * <p>The tag status with which to filter your <a>ListImages</a> results. You can
                *             filter results based on whether they are <code>TAGGED</code> or
                *             <code>UNTAGGED</code>.</p>
                */
            tagStatus?: TagStatus | string;
    }
    export namespace ListImagesFilter {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListImagesFilter) => any;
    }
    export interface ListImagesRequest {
            /**
                * <p>The Amazon Web Services account ID associated with the registry that contains the repository in
                *             which to list images. If you do not specify a registry, the default registry is assumed.</p>
                */
            registryId?: string;
            /**
                * <p>The repository with image IDs to be listed.</p>
                */
            repositoryName: string | undefined;
            /**
                * <p>The <code>nextToken</code> value returned from a previous paginated
                *                 <code>ListImages</code> request where <code>maxResults</code> was used and the
                *             results exceeded the value of that parameter. Pagination continues from the end of the
                *             previous results that returned the <code>nextToken</code> value. This value is
                *                 <code>null</code> when there are no more results to return.</p>
                *         <note>
                *             <p>This token should be treated as an opaque identifier that is only used to
                *                 retrieve the next items in a list and not for other programmatic purposes.</p>
                *         </note>
                */
            nextToken?: string;
            /**
                * <p>The maximum number of image results returned by <code>ListImages</code> in paginated
                *             output. When this parameter is used, <code>ListImages</code> only returns
                *                 <code>maxResults</code> results in a single page along with a <code>nextToken</code>
                *             response element. The remaining results of the initial request can be seen by sending
                *             another <code>ListImages</code> request with the returned <code>nextToken</code> value.
                *             This value can be between 1 and 1000. If this parameter is
                *             not used, then <code>ListImages</code> returns up to 100 results and a
                *                 <code>nextToken</code> value, if applicable.</p>
                */
            maxResults?: number;
            /**
                * <p>The filter key and value with which to filter your <code>ListImages</code>
                *             results.</p>
                */
            filter?: ListImagesFilter;
    }
    export namespace ListImagesRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListImagesRequest) => any;
    }
    export interface ListImagesResponse {
            /**
                * <p>The list of image IDs for the requested repository.</p>
                */
            imageIds?: ImageIdentifier[];
            /**
                * <p>The <code>nextToken</code> value to include in a future <code>ListImages</code>
                *             request. When the results of a <code>ListImages</code> request exceed
                *                 <code>maxResults</code>, this value can be used to retrieve the next page of
                *             results. This value is <code>null</code> when there are no more results to
                *             return.</p>
                */
            nextToken?: string;
    }
    export namespace ListImagesResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListImagesResponse) => any;
    }
    export interface ListTagsForResourceRequest {
            /**
                * <p>The Amazon Resource Name (ARN) that identifies the resource for which to list the tags. Currently, the
                *             only supported resource is an Amazon ECR repository.</p>
                */
            resourceArn: string | undefined;
    }
    export namespace ListTagsForResourceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTagsForResourceRequest) => any;
    }
    export interface ListTagsForResourceResponse {
            /**
                * <p>The tags for the resource.</p>
                */
            tags?: Tag[];
    }
    export namespace ListTagsForResourceResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTagsForResourceResponse) => any;
    }
    /**
        * <p>The specified image has already been pushed, and there were no changes to the manifest
        *             or image tag after the last push.</p>
        */
    export class ImageAlreadyExistsException extends __BaseException {
            readonly name: "ImageAlreadyExistsException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ImageAlreadyExistsException, __BaseException>);
    }
    /**
        * <p>The specified image digest does not match the digest that Amazon ECR calculated for the
        *             image.</p>
        */
    export class ImageDigestDoesNotMatchException extends __BaseException {
            readonly name: "ImageDigestDoesNotMatchException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ImageDigestDoesNotMatchException, __BaseException>);
    }
    /**
        * <p>The specified image is tagged with a tag that already exists. The repository is
        *             configured for tag immutability.</p>
        */
    export class ImageTagAlreadyExistsException extends __BaseException {
            readonly name: "ImageTagAlreadyExistsException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ImageTagAlreadyExistsException, __BaseException>);
    }
    export interface PutImageRequest {
            /**
                * <p>The Amazon Web Services account ID associated with the registry that contains the repository in
                *             which to put the image. If you do not specify a registry, the default registry is assumed.</p>
                */
            registryId?: string;
            /**
                * <p>The name of the repository in which to put the image.</p>
                */
            repositoryName: string | undefined;
            /**
                * <p>The image manifest corresponding to the image to be uploaded.</p>
                */
            imageManifest: string | undefined;
            /**
                * <p>The media type of the image manifest. If you push an image manifest that does not
                *             contain the <code>mediaType</code> field, you must specify the
                *                 <code>imageManifestMediaType</code> in the request.</p>
                */
            imageManifestMediaType?: string;
            /**
                * <p>The tag to associate with the image. This parameter is required for images that use
                *             the Docker Image Manifest V2 Schema 2 or Open Container Initiative (OCI) formats.</p>
                */
            imageTag?: string;
            /**
                * <p>The image digest of the image manifest corresponding to the image.</p>
                */
            imageDigest?: string;
    }
    export namespace PutImageRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutImageRequest) => any;
    }
    export interface PutImageResponse {
            /**
                * <p>Details of the image uploaded.</p>
                */
            image?: Image;
    }
    export namespace PutImageResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutImageResponse) => any;
    }
    /**
        * <p>The manifest list is referencing an image that does not exist.</p>
        */
    export class ReferencedImagesNotFoundException extends __BaseException {
            readonly name: "ReferencedImagesNotFoundException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ReferencedImagesNotFoundException, __BaseException>);
    }
    export interface PutImageScanningConfigurationRequest {
            /**
                * <p>The Amazon Web Services account ID associated with the registry that contains the repository in
                *             which to update the image scanning configuration setting.
                *             If you do not specify a registry, the default registry is assumed.</p>
                */
            registryId?: string;
            /**
                * <p>The name of the repository in which to update the image scanning configuration
                *             setting.</p>
                */
            repositoryName: string | undefined;
            /**
                * <p>The image scanning configuration for the repository. This setting determines whether
                *             images are scanned for known vulnerabilities after being pushed to the
                *             repository.</p>
                */
            imageScanningConfiguration: ImageScanningConfiguration | undefined;
    }
    export namespace PutImageScanningConfigurationRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutImageScanningConfigurationRequest) => any;
    }
    export interface PutImageScanningConfigurationResponse {
            /**
                * <p>The registry ID associated with the request.</p>
                */
            registryId?: string;
            /**
                * <p>The repository name associated with the request.</p>
                */
            repositoryName?: string;
            /**
                * <p>The image scanning configuration setting for the repository.</p>
                */
            imageScanningConfiguration?: ImageScanningConfiguration;
    }
    export namespace PutImageScanningConfigurationResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutImageScanningConfigurationResponse) => any;
    }
    export interface PutImageTagMutabilityRequest {
            /**
                * <p>The Amazon Web Services account ID associated with the registry that contains the repository in
                *             which to update the image tag mutability settings. If you do not specify a registry, the default registry is assumed.</p>
                */
            registryId?: string;
            /**
                * <p>The name of the repository in which to update the image tag mutability
                *             settings.</p>
                */
            repositoryName: string | undefined;
            /**
                * <p>The tag mutability setting for the repository. If <code>MUTABLE</code> is specified,
                *             image tags can be overwritten. If <code>IMMUTABLE</code> is specified, all image tags
                *             within the repository will be immutable which will prevent them from being
                *             overwritten.</p>
                */
            imageTagMutability: ImageTagMutability | string | undefined;
    }
    export namespace PutImageTagMutabilityRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutImageTagMutabilityRequest) => any;
    }
    export interface PutImageTagMutabilityResponse {
            /**
                * <p>The registry ID associated with the request.</p>
                */
            registryId?: string;
            /**
                * <p>The repository name associated with the request.</p>
                */
            repositoryName?: string;
            /**
                * <p>The image tag mutability setting for the repository.</p>
                */
            imageTagMutability?: ImageTagMutability | string;
    }
    export namespace PutImageTagMutabilityResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutImageTagMutabilityResponse) => any;
    }
    export interface PutLifecyclePolicyRequest {
            /**
                * <p>The Amazon Web Services account ID associated with the registry that contains the repository. If you
                *             do
         not specify a registry, the default registry is assumed.</p>
                */
            registryId?: string;
            /**
                * <p>The name of the repository to receive the policy.</p>
                */
            repositoryName: string | undefined;
            /**
                * <p>The JSON repository policy text to apply to the repository.</p>
                */
            lifecyclePolicyText: string | undefined;
    }
    export namespace PutLifecyclePolicyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutLifecyclePolicyRequest) => any;
    }
    export interface PutLifecyclePolicyResponse {
            /**
                * <p>The registry ID associated with the request.</p>
                */
            registryId?: string;
            /**
                * <p>The repository name associated with the request.</p>
                */
            repositoryName?: string;
            /**
                * <p>The JSON repository policy text.</p>
                */
            lifecyclePolicyText?: string;
    }
    export namespace PutLifecyclePolicyResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutLifecyclePolicyResponse) => any;
    }
    export interface PutRegistryPolicyRequest {
            /**
                * <p>The JSON policy text to apply to your registry. The policy text follows the same
                *             format as IAM policy text. For more information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/registry-permissions.html">Registry
                *                 permissions</a> in the <i>Amazon Elastic Container Registry User Guide</i>.</p>
                */
            policyText: string | undefined;
    }
    export namespace PutRegistryPolicyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutRegistryPolicyRequest) => any;
    }
    export interface PutRegistryPolicyResponse {
            /**
                * <p>The registry ID.</p>
                */
            registryId?: string;
            /**
                * <p>The JSON policy text for your registry.</p>
                */
            policyText?: string;
    }
    export namespace PutRegistryPolicyResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutRegistryPolicyResponse) => any;
    }
    export interface PutRegistryScanningConfigurationRequest {
            /**
                * <p>The scanning type to set for the registry.</p>
                *         <p>When a registry scanning configuration is not defined, by default the
                *                 <code>BASIC</code> scan type is used. When basic scanning is used, you may specify
                *             filters to determine which individual repositories, or all repositories, are scanned
                *             when new images are pushed to those repositories. Alternatively, you can do manual scans
                *             of images with basic scanning.</p>
                *         <p>When the <code>ENHANCED</code> scan type is set, Amazon Inspector provides automated
                *             vulnerability scanning. You may choose between continuous scanning or scan on push and
                *             you may specify filters to determine which individual repositories, or all repositories,
                *             are scanned.</p>
                */
            scanType?: ScanType | string;
            /**
                * <p>The scanning rules to use for the registry. A scanning rule is used to determine which
                *             repository filters are used and at what frequency scanning will occur.</p>
                */
            rules?: RegistryScanningRule[];
    }
    export namespace PutRegistryScanningConfigurationRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutRegistryScanningConfigurationRequest) => any;
    }
    export interface PutRegistryScanningConfigurationResponse {
            /**
                * <p>The scanning configuration for your registry.</p>
                */
            registryScanningConfiguration?: RegistryScanningConfiguration;
    }
    export namespace PutRegistryScanningConfigurationResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutRegistryScanningConfigurationResponse) => any;
    }
    export interface PutReplicationConfigurationRequest {
            /**
                * <p>An object representing the replication configuration for a registry.</p>
                */
            replicationConfiguration: ReplicationConfiguration | undefined;
    }
    export namespace PutReplicationConfigurationRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutReplicationConfigurationRequest) => any;
    }
    export interface PutReplicationConfigurationResponse {
            /**
                * <p>The contents of the replication configuration for the registry.</p>
                */
            replicationConfiguration?: ReplicationConfiguration;
    }
    export namespace PutReplicationConfigurationResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutReplicationConfigurationResponse) => any;
    }
    export interface SetRepositoryPolicyRequest {
            /**
                * <p>The Amazon Web Services account ID associated with the registry that contains the repository.
                *             If you do not specify a registry, the default registry is assumed.</p>
                */
            registryId?: string;
            /**
                * <p>The name of the repository to receive the policy.</p>
                */
            repositoryName: string | undefined;
            /**
                * <p>The JSON repository policy text to apply to the repository. For more information, see
                *                 <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/repository-policy-examples.html">Amazon ECR repository
                *                 policies</a> in the <i>Amazon Elastic Container Registry User Guide</i>.</p>
                */
            policyText: string | undefined;
            /**
                * <p>If the policy you are attempting to set on a repository policy would prevent you from
                *             setting another policy in the future, you must force the <a>SetRepositoryPolicy</a> operation. This is intended to prevent accidental
                *             repository lock outs.</p>
                */
            force?: boolean;
    }
    export namespace SetRepositoryPolicyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SetRepositoryPolicyRequest) => any;
    }
    export interface SetRepositoryPolicyResponse {
            /**
                * <p>The registry ID associated with the request.</p>
                */
            registryId?: string;
            /**
                * <p>The repository name associated with the request.</p>
                */
            repositoryName?: string;
            /**
                * <p>The JSON repository policy text applied to the repository.</p>
                */
            policyText?: string;
    }
    export namespace SetRepositoryPolicyResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SetRepositoryPolicyResponse) => any;
    }
    export interface StartImageScanRequest {
            /**
                * <p>The Amazon Web Services account ID associated with the registry that contains the repository in
                *             which to start an image scan request. If you do not specify a registry, the default registry is assumed.</p>
                */
            registryId?: string;
            /**
                * <p>The name of the repository that contains the images to scan.</p>
                */
            repositoryName: string | undefined;
            /**
                * <p>An object with identifying information for an image in an Amazon ECR repository.</p>
                */
            imageId: ImageIdentifier | undefined;
    }
    export namespace StartImageScanRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StartImageScanRequest) => any;
    }
    export interface StartImageScanResponse {
            /**
                * <p>The registry ID associated with the request.</p>
                */
            registryId?: string;
            /**
                * <p>The repository name associated with the request.</p>
                */
            repositoryName?: string;
            /**
                * <p>An object with identifying information for an image in an Amazon ECR repository.</p>
                */
            imageId?: ImageIdentifier;
            /**
                * <p>The current state of the scan.</p>
                */
            imageScanStatus?: ImageScanStatus;
    }
    export namespace StartImageScanResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StartImageScanResponse) => any;
    }
    /**
        * <p>The image is of a type that cannot be scanned.</p>
        */
    export class UnsupportedImageTypeException extends __BaseException {
            readonly name: "UnsupportedImageTypeException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<UnsupportedImageTypeException, __BaseException>);
    }
    /**
        * <p>The previous lifecycle policy preview request has not completed. Wait and try
        *             again.</p>
        */
    export class LifecyclePolicyPreviewInProgressException extends __BaseException {
            readonly name: "LifecyclePolicyPreviewInProgressException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<LifecyclePolicyPreviewInProgressException, __BaseException>);
    }
    export interface StartLifecyclePolicyPreviewRequest {
            /**
                * <p>The Amazon Web Services account ID associated with the registry that contains the repository.
                *             If you do not specify a registry, the default registry is assumed.</p>
                */
            registryId?: string;
            /**
                * <p>The name of the repository to be evaluated.</p>
                */
            repositoryName: string | undefined;
            /**
                * <p>The policy to be evaluated against. If you do not specify a policy, the current policy
                *             for the repository is used.</p>
                */
            lifecyclePolicyText?: string;
    }
    export namespace StartLifecyclePolicyPreviewRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StartLifecyclePolicyPreviewRequest) => any;
    }
    export interface StartLifecyclePolicyPreviewResponse {
            /**
                * <p>The registry ID associated with the request.</p>
                */
            registryId?: string;
            /**
                * <p>The repository name associated with the request.</p>
                */
            repositoryName?: string;
            /**
                * <p>The JSON repository policy text.</p>
                */
            lifecyclePolicyText?: string;
            /**
                * <p>The status of the lifecycle policy preview request.</p>
                */
            status?: LifecyclePolicyPreviewStatus | string;
    }
    export namespace StartLifecyclePolicyPreviewResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StartLifecyclePolicyPreviewResponse) => any;
    }
    export interface TagResourceRequest {
            /**
                * <p>The Amazon Resource Name (ARN) of the the resource to which to add tags. Currently, the only supported
                *             resource is an Amazon ECR repository.</p>
                */
            resourceArn: string | undefined;
            /**
                * <p>The tags to add to the resource. A tag is an array of key-value pairs.
                *             Tag keys can have a maximum character length of 128 characters, and tag values can have
                *             a maximum length of 256 characters.</p>
                */
            tags: Tag[] | undefined;
    }
    export namespace TagResourceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TagResourceRequest) => any;
    }
    export interface TagResourceResponse {
    }
    export namespace TagResourceResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TagResourceResponse) => any;
    }
    export interface UntagResourceRequest {
            /**
                * <p>The Amazon Resource Name (ARN) of the resource from which to remove tags. Currently, the only supported
                *             resource is an Amazon ECR repository.</p>
                */
            resourceArn: string | undefined;
            /**
                * <p>The keys of the tags to be removed.</p>
                */
            tagKeys: string[] | undefined;
    }
    export namespace UntagResourceRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UntagResourceRequest) => any;
    }
    export interface UntagResourceResponse {
    }
    export namespace UntagResourceResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UntagResourceResponse) => any;
    }
    /**
        * <p>The layer part size is not valid, or the first byte specified is not consecutive to
        *             the last byte of a previous layer part upload.</p>
        */
    export class InvalidLayerPartException extends __BaseException {
            readonly name: "InvalidLayerPartException";
            readonly $fault: "client";
            /**
                * <p>The registry ID associated with the exception.</p>
                */
            registryId?: string;
            /**
                * <p>The repository name associated with the exception.</p>
                */
            repositoryName?: string;
            /**
                * <p>The upload ID associated with the exception.</p>
                */
            uploadId?: string;
            /**
                * <p>The last valid byte received from the layer part upload that is associated with the
                *             exception.</p>
                */
            lastValidByteReceived?: number;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidLayerPartException, __BaseException>);
    }
    export interface UploadLayerPartRequest {
            /**
                * <p>The Amazon Web Services account ID associated with the registry to which you are uploading layer
                *             parts. If you do not specify a registry, the default registry is assumed.</p>
                */
            registryId?: string;
            /**
                * <p>The name of the repository to which you are uploading layer parts.</p>
                */
            repositoryName: string | undefined;
            /**
                * <p>The upload ID from a previous <a>InitiateLayerUpload</a> operation to
                *             associate with the layer part upload.</p>
                */
            uploadId: string | undefined;
            /**
                * <p>The position of the first byte of the layer part witin the overall image layer.</p>
                */
            partFirstByte: number | undefined;
            /**
                * <p>The position of the last byte of the layer part within the overall image layer.</p>
                */
            partLastByte: number | undefined;
            /**
                * <p>The base64-encoded layer part payload.</p>
                */
            layerPartBlob: Uint8Array | undefined;
    }
    export namespace UploadLayerPartRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UploadLayerPartRequest) => any;
    }
    export interface UploadLayerPartResponse {
            /**
                * <p>The registry ID associated with the request.</p>
                */
            registryId?: string;
            /**
                * <p>The repository name associated with the request.</p>
                */
            repositoryName?: string;
            /**
                * <p>The upload ID associated with the request.</p>
                */
            uploadId?: string;
            /**
                * <p>The integer value of the last byte received in the request.</p>
                */
            lastByteReceived?: number;
    }
    export namespace UploadLayerPartResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UploadLayerPartResponse) => any;
    }
}

declare module '@aws-sdk/client-ecr/node_modules/@aws-sdk/client-ecr/dist-types/models/ECRServiceException' {
    import { ServiceException as __ServiceException, ServiceExceptionOptions as __ServiceExceptionOptions } from "@aws-sdk/smithy-client";
    /**
        * Base exception class for all service exceptions from ECR service.
        */
    export class ECRServiceException extends __ServiceException {
            /**
                * @internal
                */
            constructor(options: __ServiceExceptionOptions);
    }
}

