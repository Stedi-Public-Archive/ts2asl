// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   @aws-sdk/types
//   @aws-sdk/smithy-client
//   @aws-sdk/config-resolver
//   @aws-sdk/middleware-host-header
//   @aws-sdk/middleware-retry
//   @aws-sdk/middleware-signing
//   @aws-sdk/middleware-user-agent
//   @aws-sdk/protocol-http

declare module '@aws-sdk/client-translate' {
    import { HttpHandlerOptions as __HttpHandlerOptions } from "@aws-sdk/types";
    import { CreateParallelDataCommandInput, CreateParallelDataCommandOutput } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/commands/CreateParallelDataCommand";
    import { DeleteParallelDataCommandInput, DeleteParallelDataCommandOutput } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/commands/DeleteParallelDataCommand";
    import { DeleteTerminologyCommandInput, DeleteTerminologyCommandOutput } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/commands/DeleteTerminologyCommand";
    import { DescribeTextTranslationJobCommandInput, DescribeTextTranslationJobCommandOutput } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/commands/DescribeTextTranslationJobCommand";
    import { GetParallelDataCommandInput, GetParallelDataCommandOutput } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/commands/GetParallelDataCommand";
    import { GetTerminologyCommandInput, GetTerminologyCommandOutput } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/commands/GetTerminologyCommand";
    import { ImportTerminologyCommandInput, ImportTerminologyCommandOutput } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/commands/ImportTerminologyCommand";
    import { ListLanguagesCommandInput, ListLanguagesCommandOutput } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/commands/ListLanguagesCommand";
    import { ListParallelDataCommandInput, ListParallelDataCommandOutput } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/commands/ListParallelDataCommand";
    import { ListTerminologiesCommandInput, ListTerminologiesCommandOutput } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/commands/ListTerminologiesCommand";
    import { ListTextTranslationJobsCommandInput, ListTextTranslationJobsCommandOutput } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/commands/ListTextTranslationJobsCommand";
    import { StartTextTranslationJobCommandInput, StartTextTranslationJobCommandOutput } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/commands/StartTextTranslationJobCommand";
    import { StopTextTranslationJobCommandInput, StopTextTranslationJobCommandOutput } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/commands/StopTextTranslationJobCommand";
    import { TranslateTextCommandInput, TranslateTextCommandOutput } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/commands/TranslateTextCommand";
    import { UpdateParallelDataCommandInput, UpdateParallelDataCommandOutput } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/commands/UpdateParallelDataCommand";
    import { TranslateClient } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/TranslateClient";
    /**
        * <p>Provides translation between one source language and another of the same set of
        *       languages.</p>
        */
    export class Translate extends TranslateClient {
            /**
                * <p>Creates a parallel data resource in Amazon Translate by importing an input file from
                *       Amazon S3. Parallel data files contain examples that show how you want segments of text to be
                *       translated. By adding parallel data, you can influence the style, tone, and word choice in
                *       your translation output.</p>
                */
            createParallelData(args: CreateParallelDataCommandInput, options?: __HttpHandlerOptions): Promise<CreateParallelDataCommandOutput>;
            createParallelData(args: CreateParallelDataCommandInput, cb: (err: any, data?: CreateParallelDataCommandOutput) => void): void;
            createParallelData(args: CreateParallelDataCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateParallelDataCommandOutput) => void): void;
            /**
                * <p>Deletes a parallel data resource in Amazon Translate.</p>
                */
            deleteParallelData(args: DeleteParallelDataCommandInput, options?: __HttpHandlerOptions): Promise<DeleteParallelDataCommandOutput>;
            deleteParallelData(args: DeleteParallelDataCommandInput, cb: (err: any, data?: DeleteParallelDataCommandOutput) => void): void;
            deleteParallelData(args: DeleteParallelDataCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteParallelDataCommandOutput) => void): void;
            /**
                * <p>A synchronous action that deletes a custom terminology.</p>
                */
            deleteTerminology(args: DeleteTerminologyCommandInput, options?: __HttpHandlerOptions): Promise<DeleteTerminologyCommandOutput>;
            deleteTerminology(args: DeleteTerminologyCommandInput, cb: (err: any, data?: DeleteTerminologyCommandOutput) => void): void;
            deleteTerminology(args: DeleteTerminologyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteTerminologyCommandOutput) => void): void;
            /**
                * <p>Gets the properties associated with an asynchronous batch translation job including name,
                *       ID, status, source and target languages, input/output S3 buckets, and so on.</p>
                */
            describeTextTranslationJob(args: DescribeTextTranslationJobCommandInput, options?: __HttpHandlerOptions): Promise<DescribeTextTranslationJobCommandOutput>;
            describeTextTranslationJob(args: DescribeTextTranslationJobCommandInput, cb: (err: any, data?: DescribeTextTranslationJobCommandOutput) => void): void;
            describeTextTranslationJob(args: DescribeTextTranslationJobCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeTextTranslationJobCommandOutput) => void): void;
            /**
                * <p>Provides information about a parallel data resource.</p>
                */
            getParallelData(args: GetParallelDataCommandInput, options?: __HttpHandlerOptions): Promise<GetParallelDataCommandOutput>;
            getParallelData(args: GetParallelDataCommandInput, cb: (err: any, data?: GetParallelDataCommandOutput) => void): void;
            getParallelData(args: GetParallelDataCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetParallelDataCommandOutput) => void): void;
            /**
                * <p>Retrieves a custom terminology.</p>
                */
            getTerminology(args: GetTerminologyCommandInput, options?: __HttpHandlerOptions): Promise<GetTerminologyCommandOutput>;
            getTerminology(args: GetTerminologyCommandInput, cb: (err: any, data?: GetTerminologyCommandOutput) => void): void;
            getTerminology(args: GetTerminologyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetTerminologyCommandOutput) => void): void;
            /**
                * <p>Creates or updates a custom terminology, depending on whether one already exists for the
                *       given terminology name. Importing a terminology with the same name as an existing one will
                *       merge the terminologies based on the chosen merge strategy. The only supported merge strategy
                *       is OVERWRITE, where the imported terminology overwrites the existing terminology of the same
                *       name.</p>
                *          <p>If you import a terminology that overwrites an existing one, the new terminology takes up
                *       to 10 minutes to fully propagate. After that, translations have access to the new
                *       terminology.</p>
                */
            importTerminology(args: ImportTerminologyCommandInput, options?: __HttpHandlerOptions): Promise<ImportTerminologyCommandOutput>;
            importTerminology(args: ImportTerminologyCommandInput, cb: (err: any, data?: ImportTerminologyCommandOutput) => void): void;
            importTerminology(args: ImportTerminologyCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ImportTerminologyCommandOutput) => void): void;
            /**
                * <p>Provides a list of languages (RFC-5646 codes and names) that Amazon Translate supports.</p>
                */
            listLanguages(args: ListLanguagesCommandInput, options?: __HttpHandlerOptions): Promise<ListLanguagesCommandOutput>;
            listLanguages(args: ListLanguagesCommandInput, cb: (err: any, data?: ListLanguagesCommandOutput) => void): void;
            listLanguages(args: ListLanguagesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListLanguagesCommandOutput) => void): void;
            /**
                * <p>Provides a list of your parallel data resources in Amazon Translate.</p>
                */
            listParallelData(args: ListParallelDataCommandInput, options?: __HttpHandlerOptions): Promise<ListParallelDataCommandOutput>;
            listParallelData(args: ListParallelDataCommandInput, cb: (err: any, data?: ListParallelDataCommandOutput) => void): void;
            listParallelData(args: ListParallelDataCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListParallelDataCommandOutput) => void): void;
            /**
                * <p>Provides a list of custom terminologies associated with your account.</p>
                */
            listTerminologies(args: ListTerminologiesCommandInput, options?: __HttpHandlerOptions): Promise<ListTerminologiesCommandOutput>;
            listTerminologies(args: ListTerminologiesCommandInput, cb: (err: any, data?: ListTerminologiesCommandOutput) => void): void;
            listTerminologies(args: ListTerminologiesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListTerminologiesCommandOutput) => void): void;
            /**
                * <p>Gets a list of the batch translation jobs that you have submitted.</p>
                */
            listTextTranslationJobs(args: ListTextTranslationJobsCommandInput, options?: __HttpHandlerOptions): Promise<ListTextTranslationJobsCommandOutput>;
            listTextTranslationJobs(args: ListTextTranslationJobsCommandInput, cb: (err: any, data?: ListTextTranslationJobsCommandOutput) => void): void;
            listTextTranslationJobs(args: ListTextTranslationJobsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListTextTranslationJobsCommandOutput) => void): void;
            /**
                * <p>Starts an asynchronous batch translation job. Batch translation jobs can be used to
                *       translate large volumes of text across multiple documents at once. For more information, see
                *         <a>async</a>.</p>
                *
                *          <p>Batch translation jobs can be described with the <a>DescribeTextTranslationJob</a> operation, listed with the <a>ListTextTranslationJobs</a> operation, and stopped with the <a>StopTextTranslationJob</a> operation.</p>
                *          <note>
                *             <p>Amazon Translate does not support batch translation of multiple source languages at once.</p>
                *          </note>
                */
            startTextTranslationJob(args: StartTextTranslationJobCommandInput, options?: __HttpHandlerOptions): Promise<StartTextTranslationJobCommandOutput>;
            startTextTranslationJob(args: StartTextTranslationJobCommandInput, cb: (err: any, data?: StartTextTranslationJobCommandOutput) => void): void;
            startTextTranslationJob(args: StartTextTranslationJobCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: StartTextTranslationJobCommandOutput) => void): void;
            /**
                * <p>Stops an asynchronous batch translation job that is in progress.</p>
                *          <p>If the job's state is <code>IN_PROGRESS</code>, the job will be marked for termination and
                *       put into the <code>STOP_REQUESTED</code> state. If the job completes before it can be stopped,
                *       it is put into the <code>COMPLETED</code> state. Otherwise, the job is put into the
                *         <code>STOPPED</code> state.</p>
                *          <p>Asynchronous batch translation jobs are started with the <a>StartTextTranslationJob</a> operation. You can use the <a>DescribeTextTranslationJob</a> or <a>ListTextTranslationJobs</a>
                *       operations to get a batch translation job's <code>JobId</code>.</p>
                */
            stopTextTranslationJob(args: StopTextTranslationJobCommandInput, options?: __HttpHandlerOptions): Promise<StopTextTranslationJobCommandOutput>;
            stopTextTranslationJob(args: StopTextTranslationJobCommandInput, cb: (err: any, data?: StopTextTranslationJobCommandOutput) => void): void;
            stopTextTranslationJob(args: StopTextTranslationJobCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: StopTextTranslationJobCommandOutput) => void): void;
            /**
                * <p>Translates input text from the source language to the target language. For a list of
                *       available languages and language codes, see <a>what-is-languages</a>.</p>
                */
            translateText(args: TranslateTextCommandInput, options?: __HttpHandlerOptions): Promise<TranslateTextCommandOutput>;
            translateText(args: TranslateTextCommandInput, cb: (err: any, data?: TranslateTextCommandOutput) => void): void;
            translateText(args: TranslateTextCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: TranslateTextCommandOutput) => void): void;
            /**
                * <p>Updates a previously created parallel data resource by importing a new input file from
                *       Amazon S3.</p>
                */
            updateParallelData(args: UpdateParallelDataCommandInput, options?: __HttpHandlerOptions): Promise<UpdateParallelDataCommandOutput>;
            updateParallelData(args: UpdateParallelDataCommandInput, cb: (err: any, data?: UpdateParallelDataCommandOutput) => void): void;
            updateParallelData(args: UpdateParallelDataCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateParallelDataCommandOutput) => void): void;
    }
}

declare module '@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/commands/CreateParallelDataCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { CreateParallelDataRequest, CreateParallelDataResponse } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TranslateClientResolvedConfig } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/TranslateClient";
    export interface CreateParallelDataCommandInput extends CreateParallelDataRequest {
    }
    export interface CreateParallelDataCommandOutput extends CreateParallelDataResponse, __MetadataBearer {
    }
    /**
        * <p>Creates a parallel data resource in Amazon Translate by importing an input file from
        *       Amazon S3. Parallel data files contain examples that show how you want segments of text to be
        *       translated. By adding parallel data, you can influence the style, tone, and word choice in
        *       your translation output.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TranslateClient, CreateParallelDataCommand } from "@aws-sdk/client-translate"; // ES Modules import
        * // const { TranslateClient, CreateParallelDataCommand } = require("@aws-sdk/client-translate"); // CommonJS import
        * const client = new TranslateClient(config);
        * const command = new CreateParallelDataCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateParallelDataCommandInput} for command's `input` shape.
        * @see {@link CreateParallelDataCommandOutput} for command's `response` shape.
        * @see {@link TranslateClientResolvedConfig | config} for TranslateClient's `config` shape.
        *
        */
    export class CreateParallelDataCommand extends $Command<CreateParallelDataCommandInput, CreateParallelDataCommandOutput, TranslateClientResolvedConfig> {
            readonly input: CreateParallelDataCommandInput;
            constructor(input: CreateParallelDataCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TranslateClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateParallelDataCommandInput, CreateParallelDataCommandOutput>;
    }
}

declare module '@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/commands/DeleteParallelDataCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DeleteParallelDataRequest, DeleteParallelDataResponse } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TranslateClientResolvedConfig } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/TranslateClient";
    export interface DeleteParallelDataCommandInput extends DeleteParallelDataRequest {
    }
    export interface DeleteParallelDataCommandOutput extends DeleteParallelDataResponse, __MetadataBearer {
    }
    /**
        * <p>Deletes a parallel data resource in Amazon Translate.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TranslateClient, DeleteParallelDataCommand } from "@aws-sdk/client-translate"; // ES Modules import
        * // const { TranslateClient, DeleteParallelDataCommand } = require("@aws-sdk/client-translate"); // CommonJS import
        * const client = new TranslateClient(config);
        * const command = new DeleteParallelDataCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteParallelDataCommandInput} for command's `input` shape.
        * @see {@link DeleteParallelDataCommandOutput} for command's `response` shape.
        * @see {@link TranslateClientResolvedConfig | config} for TranslateClient's `config` shape.
        *
        */
    export class DeleteParallelDataCommand extends $Command<DeleteParallelDataCommandInput, DeleteParallelDataCommandOutput, TranslateClientResolvedConfig> {
            readonly input: DeleteParallelDataCommandInput;
            constructor(input: DeleteParallelDataCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TranslateClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteParallelDataCommandInput, DeleteParallelDataCommandOutput>;
    }
}

declare module '@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/commands/DeleteTerminologyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DeleteTerminologyRequest } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TranslateClientResolvedConfig } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/TranslateClient";
    export interface DeleteTerminologyCommandInput extends DeleteTerminologyRequest {
    }
    export interface DeleteTerminologyCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>A synchronous action that deletes a custom terminology.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TranslateClient, DeleteTerminologyCommand } from "@aws-sdk/client-translate"; // ES Modules import
        * // const { TranslateClient, DeleteTerminologyCommand } = require("@aws-sdk/client-translate"); // CommonJS import
        * const client = new TranslateClient(config);
        * const command = new DeleteTerminologyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteTerminologyCommandInput} for command's `input` shape.
        * @see {@link DeleteTerminologyCommandOutput} for command's `response` shape.
        * @see {@link TranslateClientResolvedConfig | config} for TranslateClient's `config` shape.
        *
        */
    export class DeleteTerminologyCommand extends $Command<DeleteTerminologyCommandInput, DeleteTerminologyCommandOutput, TranslateClientResolvedConfig> {
            readonly input: DeleteTerminologyCommandInput;
            constructor(input: DeleteTerminologyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TranslateClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteTerminologyCommandInput, DeleteTerminologyCommandOutput>;
    }
}

declare module '@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/commands/DescribeTextTranslationJobCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DescribeTextTranslationJobRequest, DescribeTextTranslationJobResponse } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TranslateClientResolvedConfig } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/TranslateClient";
    export interface DescribeTextTranslationJobCommandInput extends DescribeTextTranslationJobRequest {
    }
    export interface DescribeTextTranslationJobCommandOutput extends DescribeTextTranslationJobResponse, __MetadataBearer {
    }
    /**
        * <p>Gets the properties associated with an asynchronous batch translation job including name,
        *       ID, status, source and target languages, input/output S3 buckets, and so on.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TranslateClient, DescribeTextTranslationJobCommand } from "@aws-sdk/client-translate"; // ES Modules import
        * // const { TranslateClient, DescribeTextTranslationJobCommand } = require("@aws-sdk/client-translate"); // CommonJS import
        * const client = new TranslateClient(config);
        * const command = new DescribeTextTranslationJobCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeTextTranslationJobCommandInput} for command's `input` shape.
        * @see {@link DescribeTextTranslationJobCommandOutput} for command's `response` shape.
        * @see {@link TranslateClientResolvedConfig | config} for TranslateClient's `config` shape.
        *
        */
    export class DescribeTextTranslationJobCommand extends $Command<DescribeTextTranslationJobCommandInput, DescribeTextTranslationJobCommandOutput, TranslateClientResolvedConfig> {
            readonly input: DescribeTextTranslationJobCommandInput;
            constructor(input: DescribeTextTranslationJobCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TranslateClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeTextTranslationJobCommandInput, DescribeTextTranslationJobCommandOutput>;
    }
}

declare module '@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/commands/GetParallelDataCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { GetParallelDataRequest, GetParallelDataResponse } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TranslateClientResolvedConfig } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/TranslateClient";
    export interface GetParallelDataCommandInput extends GetParallelDataRequest {
    }
    export interface GetParallelDataCommandOutput extends GetParallelDataResponse, __MetadataBearer {
    }
    /**
        * <p>Provides information about a parallel data resource.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TranslateClient, GetParallelDataCommand } from "@aws-sdk/client-translate"; // ES Modules import
        * // const { TranslateClient, GetParallelDataCommand } = require("@aws-sdk/client-translate"); // CommonJS import
        * const client = new TranslateClient(config);
        * const command = new GetParallelDataCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetParallelDataCommandInput} for command's `input` shape.
        * @see {@link GetParallelDataCommandOutput} for command's `response` shape.
        * @see {@link TranslateClientResolvedConfig | config} for TranslateClient's `config` shape.
        *
        */
    export class GetParallelDataCommand extends $Command<GetParallelDataCommandInput, GetParallelDataCommandOutput, TranslateClientResolvedConfig> {
            readonly input: GetParallelDataCommandInput;
            constructor(input: GetParallelDataCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TranslateClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetParallelDataCommandInput, GetParallelDataCommandOutput>;
    }
}

declare module '@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/commands/GetTerminologyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { GetTerminologyRequest, GetTerminologyResponse } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TranslateClientResolvedConfig } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/TranslateClient";
    export interface GetTerminologyCommandInput extends GetTerminologyRequest {
    }
    export interface GetTerminologyCommandOutput extends GetTerminologyResponse, __MetadataBearer {
    }
    /**
        * <p>Retrieves a custom terminology.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TranslateClient, GetTerminologyCommand } from "@aws-sdk/client-translate"; // ES Modules import
        * // const { TranslateClient, GetTerminologyCommand } = require("@aws-sdk/client-translate"); // CommonJS import
        * const client = new TranslateClient(config);
        * const command = new GetTerminologyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetTerminologyCommandInput} for command's `input` shape.
        * @see {@link GetTerminologyCommandOutput} for command's `response` shape.
        * @see {@link TranslateClientResolvedConfig | config} for TranslateClient's `config` shape.
        *
        */
    export class GetTerminologyCommand extends $Command<GetTerminologyCommandInput, GetTerminologyCommandOutput, TranslateClientResolvedConfig> {
            readonly input: GetTerminologyCommandInput;
            constructor(input: GetTerminologyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TranslateClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetTerminologyCommandInput, GetTerminologyCommandOutput>;
    }
}

declare module '@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/commands/ImportTerminologyCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ImportTerminologyRequest, ImportTerminologyResponse } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TranslateClientResolvedConfig } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/TranslateClient";
    export interface ImportTerminologyCommandInput extends ImportTerminologyRequest {
    }
    export interface ImportTerminologyCommandOutput extends ImportTerminologyResponse, __MetadataBearer {
    }
    /**
        * <p>Creates or updates a custom terminology, depending on whether one already exists for the
        *       given terminology name. Importing a terminology with the same name as an existing one will
        *       merge the terminologies based on the chosen merge strategy. The only supported merge strategy
        *       is OVERWRITE, where the imported terminology overwrites the existing terminology of the same
        *       name.</p>
        *          <p>If you import a terminology that overwrites an existing one, the new terminology takes up
        *       to 10 minutes to fully propagate. After that, translations have access to the new
        *       terminology.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TranslateClient, ImportTerminologyCommand } from "@aws-sdk/client-translate"; // ES Modules import
        * // const { TranslateClient, ImportTerminologyCommand } = require("@aws-sdk/client-translate"); // CommonJS import
        * const client = new TranslateClient(config);
        * const command = new ImportTerminologyCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ImportTerminologyCommandInput} for command's `input` shape.
        * @see {@link ImportTerminologyCommandOutput} for command's `response` shape.
        * @see {@link TranslateClientResolvedConfig | config} for TranslateClient's `config` shape.
        *
        */
    export class ImportTerminologyCommand extends $Command<ImportTerminologyCommandInput, ImportTerminologyCommandOutput, TranslateClientResolvedConfig> {
            readonly input: ImportTerminologyCommandInput;
            constructor(input: ImportTerminologyCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TranslateClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ImportTerminologyCommandInput, ImportTerminologyCommandOutput>;
    }
}

declare module '@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/commands/ListLanguagesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ListLanguagesRequest, ListLanguagesResponse } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TranslateClientResolvedConfig } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/TranslateClient";
    export interface ListLanguagesCommandInput extends ListLanguagesRequest {
    }
    export interface ListLanguagesCommandOutput extends ListLanguagesResponse, __MetadataBearer {
    }
    /**
        * <p>Provides a list of languages (RFC-5646 codes and names) that Amazon Translate supports.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TranslateClient, ListLanguagesCommand } from "@aws-sdk/client-translate"; // ES Modules import
        * // const { TranslateClient, ListLanguagesCommand } = require("@aws-sdk/client-translate"); // CommonJS import
        * const client = new TranslateClient(config);
        * const command = new ListLanguagesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListLanguagesCommandInput} for command's `input` shape.
        * @see {@link ListLanguagesCommandOutput} for command's `response` shape.
        * @see {@link TranslateClientResolvedConfig | config} for TranslateClient's `config` shape.
        *
        */
    export class ListLanguagesCommand extends $Command<ListLanguagesCommandInput, ListLanguagesCommandOutput, TranslateClientResolvedConfig> {
            readonly input: ListLanguagesCommandInput;
            constructor(input: ListLanguagesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TranslateClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListLanguagesCommandInput, ListLanguagesCommandOutput>;
    }
}

declare module '@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/commands/ListParallelDataCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ListParallelDataRequest, ListParallelDataResponse } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TranslateClientResolvedConfig } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/TranslateClient";
    export interface ListParallelDataCommandInput extends ListParallelDataRequest {
    }
    export interface ListParallelDataCommandOutput extends ListParallelDataResponse, __MetadataBearer {
    }
    /**
        * <p>Provides a list of your parallel data resources in Amazon Translate.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TranslateClient, ListParallelDataCommand } from "@aws-sdk/client-translate"; // ES Modules import
        * // const { TranslateClient, ListParallelDataCommand } = require("@aws-sdk/client-translate"); // CommonJS import
        * const client = new TranslateClient(config);
        * const command = new ListParallelDataCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListParallelDataCommandInput} for command's `input` shape.
        * @see {@link ListParallelDataCommandOutput} for command's `response` shape.
        * @see {@link TranslateClientResolvedConfig | config} for TranslateClient's `config` shape.
        *
        */
    export class ListParallelDataCommand extends $Command<ListParallelDataCommandInput, ListParallelDataCommandOutput, TranslateClientResolvedConfig> {
            readonly input: ListParallelDataCommandInput;
            constructor(input: ListParallelDataCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TranslateClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListParallelDataCommandInput, ListParallelDataCommandOutput>;
    }
}

declare module '@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/commands/ListTerminologiesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ListTerminologiesRequest, ListTerminologiesResponse } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TranslateClientResolvedConfig } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/TranslateClient";
    export interface ListTerminologiesCommandInput extends ListTerminologiesRequest {
    }
    export interface ListTerminologiesCommandOutput extends ListTerminologiesResponse, __MetadataBearer {
    }
    /**
        * <p>Provides a list of custom terminologies associated with your account.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TranslateClient, ListTerminologiesCommand } from "@aws-sdk/client-translate"; // ES Modules import
        * // const { TranslateClient, ListTerminologiesCommand } = require("@aws-sdk/client-translate"); // CommonJS import
        * const client = new TranslateClient(config);
        * const command = new ListTerminologiesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListTerminologiesCommandInput} for command's `input` shape.
        * @see {@link ListTerminologiesCommandOutput} for command's `response` shape.
        * @see {@link TranslateClientResolvedConfig | config} for TranslateClient's `config` shape.
        *
        */
    export class ListTerminologiesCommand extends $Command<ListTerminologiesCommandInput, ListTerminologiesCommandOutput, TranslateClientResolvedConfig> {
            readonly input: ListTerminologiesCommandInput;
            constructor(input: ListTerminologiesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TranslateClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListTerminologiesCommandInput, ListTerminologiesCommandOutput>;
    }
}

declare module '@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/commands/ListTextTranslationJobsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { ListTextTranslationJobsRequest, ListTextTranslationJobsResponse } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TranslateClientResolvedConfig } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/TranslateClient";
    export interface ListTextTranslationJobsCommandInput extends ListTextTranslationJobsRequest {
    }
    export interface ListTextTranslationJobsCommandOutput extends ListTextTranslationJobsResponse, __MetadataBearer {
    }
    /**
        * <p>Gets a list of the batch translation jobs that you have submitted.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TranslateClient, ListTextTranslationJobsCommand } from "@aws-sdk/client-translate"; // ES Modules import
        * // const { TranslateClient, ListTextTranslationJobsCommand } = require("@aws-sdk/client-translate"); // CommonJS import
        * const client = new TranslateClient(config);
        * const command = new ListTextTranslationJobsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListTextTranslationJobsCommandInput} for command's `input` shape.
        * @see {@link ListTextTranslationJobsCommandOutput} for command's `response` shape.
        * @see {@link TranslateClientResolvedConfig | config} for TranslateClient's `config` shape.
        *
        */
    export class ListTextTranslationJobsCommand extends $Command<ListTextTranslationJobsCommandInput, ListTextTranslationJobsCommandOutput, TranslateClientResolvedConfig> {
            readonly input: ListTextTranslationJobsCommandInput;
            constructor(input: ListTextTranslationJobsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TranslateClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListTextTranslationJobsCommandInput, ListTextTranslationJobsCommandOutput>;
    }
}

declare module '@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/commands/StartTextTranslationJobCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { StartTextTranslationJobRequest, StartTextTranslationJobResponse } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TranslateClientResolvedConfig } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/TranslateClient";
    export interface StartTextTranslationJobCommandInput extends StartTextTranslationJobRequest {
    }
    export interface StartTextTranslationJobCommandOutput extends StartTextTranslationJobResponse, __MetadataBearer {
    }
    /**
        * <p>Starts an asynchronous batch translation job. Batch translation jobs can be used to
        *       translate large volumes of text across multiple documents at once. For more information, see
        *         <a>async</a>.</p>
        *
        *          <p>Batch translation jobs can be described with the <a>DescribeTextTranslationJob</a> operation, listed with the <a>ListTextTranslationJobs</a> operation, and stopped with the <a>StopTextTranslationJob</a> operation.</p>
        *          <note>
        *             <p>Amazon Translate does not support batch translation of multiple source languages at once.</p>
        *          </note>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TranslateClient, StartTextTranslationJobCommand } from "@aws-sdk/client-translate"; // ES Modules import
        * // const { TranslateClient, StartTextTranslationJobCommand } = require("@aws-sdk/client-translate"); // CommonJS import
        * const client = new TranslateClient(config);
        * const command = new StartTextTranslationJobCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link StartTextTranslationJobCommandInput} for command's `input` shape.
        * @see {@link StartTextTranslationJobCommandOutput} for command's `response` shape.
        * @see {@link TranslateClientResolvedConfig | config} for TranslateClient's `config` shape.
        *
        */
    export class StartTextTranslationJobCommand extends $Command<StartTextTranslationJobCommandInput, StartTextTranslationJobCommandOutput, TranslateClientResolvedConfig> {
            readonly input: StartTextTranslationJobCommandInput;
            constructor(input: StartTextTranslationJobCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TranslateClientResolvedConfig, options?: __HttpHandlerOptions): Handler<StartTextTranslationJobCommandInput, StartTextTranslationJobCommandOutput>;
    }
}

declare module '@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/commands/StopTextTranslationJobCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { StopTextTranslationJobRequest, StopTextTranslationJobResponse } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TranslateClientResolvedConfig } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/TranslateClient";
    export interface StopTextTranslationJobCommandInput extends StopTextTranslationJobRequest {
    }
    export interface StopTextTranslationJobCommandOutput extends StopTextTranslationJobResponse, __MetadataBearer {
    }
    /**
        * <p>Stops an asynchronous batch translation job that is in progress.</p>
        *          <p>If the job's state is <code>IN_PROGRESS</code>, the job will be marked for termination and
        *       put into the <code>STOP_REQUESTED</code> state. If the job completes before it can be stopped,
        *       it is put into the <code>COMPLETED</code> state. Otherwise, the job is put into the
        *         <code>STOPPED</code> state.</p>
        *          <p>Asynchronous batch translation jobs are started with the <a>StartTextTranslationJob</a> operation. You can use the <a>DescribeTextTranslationJob</a> or <a>ListTextTranslationJobs</a>
        *       operations to get a batch translation job's <code>JobId</code>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TranslateClient, StopTextTranslationJobCommand } from "@aws-sdk/client-translate"; // ES Modules import
        * // const { TranslateClient, StopTextTranslationJobCommand } = require("@aws-sdk/client-translate"); // CommonJS import
        * const client = new TranslateClient(config);
        * const command = new StopTextTranslationJobCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link StopTextTranslationJobCommandInput} for command's `input` shape.
        * @see {@link StopTextTranslationJobCommandOutput} for command's `response` shape.
        * @see {@link TranslateClientResolvedConfig | config} for TranslateClient's `config` shape.
        *
        */
    export class StopTextTranslationJobCommand extends $Command<StopTextTranslationJobCommandInput, StopTextTranslationJobCommandOutput, TranslateClientResolvedConfig> {
            readonly input: StopTextTranslationJobCommandInput;
            constructor(input: StopTextTranslationJobCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TranslateClientResolvedConfig, options?: __HttpHandlerOptions): Handler<StopTextTranslationJobCommandInput, StopTextTranslationJobCommandOutput>;
    }
}

declare module '@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/commands/TranslateTextCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { TranslateTextRequest, TranslateTextResponse } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TranslateClientResolvedConfig } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/TranslateClient";
    export interface TranslateTextCommandInput extends TranslateTextRequest {
    }
    export interface TranslateTextCommandOutput extends TranslateTextResponse, __MetadataBearer {
    }
    /**
        * <p>Translates input text from the source language to the target language. For a list of
        *       available languages and language codes, see <a>what-is-languages</a>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TranslateClient, TranslateTextCommand } from "@aws-sdk/client-translate"; // ES Modules import
        * // const { TranslateClient, TranslateTextCommand } = require("@aws-sdk/client-translate"); // CommonJS import
        * const client = new TranslateClient(config);
        * const command = new TranslateTextCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link TranslateTextCommandInput} for command's `input` shape.
        * @see {@link TranslateTextCommandOutput} for command's `response` shape.
        * @see {@link TranslateClientResolvedConfig | config} for TranslateClient's `config` shape.
        *
        */
    export class TranslateTextCommand extends $Command<TranslateTextCommandInput, TranslateTextCommandOutput, TranslateClientResolvedConfig> {
            readonly input: TranslateTextCommandInput;
            constructor(input: TranslateTextCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TranslateClientResolvedConfig, options?: __HttpHandlerOptions): Handler<TranslateTextCommandInput, TranslateTextCommandOutput>;
    }
}

declare module '@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/commands/UpdateParallelDataCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { UpdateParallelDataRequest, UpdateParallelDataResponse } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TranslateClientResolvedConfig } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/TranslateClient";
    export interface UpdateParallelDataCommandInput extends UpdateParallelDataRequest {
    }
    export interface UpdateParallelDataCommandOutput extends UpdateParallelDataResponse, __MetadataBearer {
    }
    /**
        * <p>Updates a previously created parallel data resource by importing a new input file from
        *       Amazon S3.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TranslateClient, UpdateParallelDataCommand } from "@aws-sdk/client-translate"; // ES Modules import
        * // const { TranslateClient, UpdateParallelDataCommand } = require("@aws-sdk/client-translate"); // CommonJS import
        * const client = new TranslateClient(config);
        * const command = new UpdateParallelDataCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateParallelDataCommandInput} for command's `input` shape.
        * @see {@link UpdateParallelDataCommandOutput} for command's `response` shape.
        * @see {@link TranslateClientResolvedConfig | config} for TranslateClient's `config` shape.
        *
        */
    export class UpdateParallelDataCommand extends $Command<UpdateParallelDataCommandInput, UpdateParallelDataCommandOutput, TranslateClientResolvedConfig> {
            readonly input: UpdateParallelDataCommandInput;
            constructor(input: UpdateParallelDataCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TranslateClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateParallelDataCommandInput, UpdateParallelDataCommandOutput>;
    }
}

declare module '@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/TranslateClient' {
    import { EndpointsInputConfig, EndpointsResolvedConfig, RegionInputConfig, RegionResolvedConfig } from "@aws-sdk/config-resolver";
    import { HostHeaderInputConfig, HostHeaderResolvedConfig } from "@aws-sdk/middleware-host-header";
    import { RetryInputConfig, RetryResolvedConfig } from "@aws-sdk/middleware-retry";
    import { AwsAuthInputConfig, AwsAuthResolvedConfig } from "@aws-sdk/middleware-signing";
    import { UserAgentInputConfig, UserAgentResolvedConfig } from "@aws-sdk/middleware-user-agent";
    import { HttpHandler as __HttpHandler } from "@aws-sdk/protocol-http";
    import { Client as __Client, DefaultsMode, SmithyConfiguration as __SmithyConfiguration, SmithyResolvedConfiguration as __SmithyResolvedConfiguration } from "@aws-sdk/smithy-client";
    import { BodyLengthCalculator as __BodyLengthCalculator, Credentials as __Credentials, Decoder as __Decoder, Encoder as __Encoder, HashConstructor as __HashConstructor, HttpHandlerOptions as __HttpHandlerOptions, Logger as __Logger, Provider as __Provider, Provider, RegionInfoProvider, StreamCollector as __StreamCollector, UrlParser as __UrlParser, UserAgent as __UserAgent } from "@aws-sdk/types";
    import { CreateParallelDataCommandInput, CreateParallelDataCommandOutput } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/commands/CreateParallelDataCommand";
    import { DeleteParallelDataCommandInput, DeleteParallelDataCommandOutput } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/commands/DeleteParallelDataCommand";
    import { DeleteTerminologyCommandInput, DeleteTerminologyCommandOutput } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/commands/DeleteTerminologyCommand";
    import { DescribeTextTranslationJobCommandInput, DescribeTextTranslationJobCommandOutput } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/commands/DescribeTextTranslationJobCommand";
    import { GetParallelDataCommandInput, GetParallelDataCommandOutput } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/commands/GetParallelDataCommand";
    import { GetTerminologyCommandInput, GetTerminologyCommandOutput } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/commands/GetTerminologyCommand";
    import { ImportTerminologyCommandInput, ImportTerminologyCommandOutput } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/commands/ImportTerminologyCommand";
    import { ListLanguagesCommandInput, ListLanguagesCommandOutput } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/commands/ListLanguagesCommand";
    import { ListParallelDataCommandInput, ListParallelDataCommandOutput } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/commands/ListParallelDataCommand";
    import { ListTerminologiesCommandInput, ListTerminologiesCommandOutput } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/commands/ListTerminologiesCommand";
    import { ListTextTranslationJobsCommandInput, ListTextTranslationJobsCommandOutput } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/commands/ListTextTranslationJobsCommand";
    import { StartTextTranslationJobCommandInput, StartTextTranslationJobCommandOutput } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/commands/StartTextTranslationJobCommand";
    import { StopTextTranslationJobCommandInput, StopTextTranslationJobCommandOutput } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/commands/StopTextTranslationJobCommand";
    import { TranslateTextCommandInput, TranslateTextCommandOutput } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/commands/TranslateTextCommand";
    import { UpdateParallelDataCommandInput, UpdateParallelDataCommandOutput } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/commands/UpdateParallelDataCommand";
    export type ServiceInputTypes = CreateParallelDataCommandInput | DeleteParallelDataCommandInput | DeleteTerminologyCommandInput | DescribeTextTranslationJobCommandInput | GetParallelDataCommandInput | GetTerminologyCommandInput | ImportTerminologyCommandInput | ListLanguagesCommandInput | ListParallelDataCommandInput | ListTerminologiesCommandInput | ListTextTranslationJobsCommandInput | StartTextTranslationJobCommandInput | StopTextTranslationJobCommandInput | TranslateTextCommandInput | UpdateParallelDataCommandInput;
    export type ServiceOutputTypes = CreateParallelDataCommandOutput | DeleteParallelDataCommandOutput | DeleteTerminologyCommandOutput | DescribeTextTranslationJobCommandOutput | GetParallelDataCommandOutput | GetTerminologyCommandOutput | ImportTerminologyCommandOutput | ListLanguagesCommandOutput | ListParallelDataCommandOutput | ListTerminologiesCommandOutput | ListTextTranslationJobsCommandOutput | StartTextTranslationJobCommandOutput | StopTextTranslationJobCommandOutput | TranslateTextCommandOutput | UpdateParallelDataCommandOutput;
    export interface ClientDefaults extends Partial<__SmithyResolvedConfiguration<__HttpHandlerOptions>> {
            /**
                * The HTTP handler to use. Fetch in browser and Https in Nodejs.
                */
            requestHandler?: __HttpHandler;
            /**
                * A constructor for a class implementing the {@link __Hash} interface
                * that computes the SHA-256 HMAC or checksum of a string or binary buffer.
                * @internal
                */
            sha256?: __HashConstructor;
            /**
                * The function that will be used to convert strings into HTTP endpoints.
                * @internal
                */
            urlParser?: __UrlParser;
            /**
                * A function that can calculate the length of a request body.
                * @internal
                */
            bodyLengthChecker?: __BodyLengthCalculator;
            /**
                * A function that converts a stream into an array of bytes.
                * @internal
                */
            streamCollector?: __StreamCollector;
            /**
                * The function that will be used to convert a base64-encoded string to a byte array.
                * @internal
                */
            base64Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a base64-encoded string.
                * @internal
                */
            base64Encoder?: __Encoder;
            /**
                * The function that will be used to convert a UTF8-encoded string to a byte array.
                * @internal
                */
            utf8Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a UTF-8 encoded string.
                * @internal
                */
            utf8Encoder?: __Encoder;
            /**
                * The runtime environment.
                * @internal
                */
            runtime?: string;
            /**
                * Disable dyanamically changing the endpoint of the client based on the hostPrefix
                * trait of an operation.
                */
            disableHostPrefix?: boolean;
            /**
                * Value for how many times a request will be made at most in case of retry.
                */
            maxAttempts?: number | __Provider<number>;
            /**
                * Specifies which retry algorithm to use.
                */
            retryMode?: string | __Provider<string>;
            /**
                * Optional logger for logging debug/info/warn/error.
                */
            logger?: __Logger;
            /**
                * Enables IPv6/IPv4 dualstack endpoint.
                */
            useDualstackEndpoint?: boolean | __Provider<boolean>;
            /**
                * Enables FIPS compatible endpoints.
                */
            useFipsEndpoint?: boolean | __Provider<boolean>;
            /**
                * Unique service identifier.
                * @internal
                */
            serviceId?: string;
            /**
                * The AWS region to which this client will send requests
                */
            region?: string | __Provider<string>;
            /**
                * Default credentials provider; Not available in browser runtime.
                * @internal
                */
            credentialDefaultProvider?: (input: any) => __Provider<__Credentials>;
            /**
                * Fetch related hostname, signing name or signing region with given region.
                * @internal
                */
            regionInfoProvider?: RegionInfoProvider;
            /**
                * The provider populating default tracking information to be sent with `user-agent`, `x-amz-user-agent` header
                * @internal
                */
            defaultUserAgentProvider?: Provider<__UserAgent>;
            /**
                * The {@link DefaultsMode} that will be used to determine how certain default configuration options are resolved in the SDK.
                */
            defaultsMode?: DefaultsMode | Provider<DefaultsMode>;
    }
    type TranslateClientConfigType = Partial<__SmithyConfiguration<__HttpHandlerOptions>> & ClientDefaults & RegionInputConfig & EndpointsInputConfig & RetryInputConfig & HostHeaderInputConfig & AwsAuthInputConfig & UserAgentInputConfig;
    /**
        * The configuration interface of TranslateClient class constructor that set the region, credentials and other options.
        */
    export interface TranslateClientConfig extends TranslateClientConfigType {
    }
    type TranslateClientResolvedConfigType = __SmithyResolvedConfiguration<__HttpHandlerOptions> & Required<ClientDefaults> & RegionResolvedConfig & EndpointsResolvedConfig & RetryResolvedConfig & HostHeaderResolvedConfig & AwsAuthResolvedConfig & UserAgentResolvedConfig;
    /**
        * The resolved configuration interface of TranslateClient class. This is resolved and normalized from the {@link TranslateClientConfig | constructor configuration interface}.
        */
    export interface TranslateClientResolvedConfig extends TranslateClientResolvedConfigType {
    }
    /**
        * <p>Provides translation between one source language and another of the same set of
        *       languages.</p>
        */
    export class TranslateClient extends __Client<__HttpHandlerOptions, ServiceInputTypes, ServiceOutputTypes, TranslateClientResolvedConfig> {
            /**
                * The resolved configuration of TranslateClient class. This is resolved and normalized from the {@link TranslateClientConfig | constructor configuration interface}.
                */
            readonly config: TranslateClientResolvedConfig;
            constructor(configuration: TranslateClientConfig);
            /**
                * Destroy underlying resources, like sockets. It's usually not necessary to do this.
                * However in Node.js, it's best to explicitly shut down the client's agent when it is no longer needed.
                * Otherwise, sockets might stay open for quite a long time before the server terminates them.
                */
            destroy(): void;
    }
    export {};
}

declare module '@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/models/models_0' {
    import { ExceptionOptionType as __ExceptionOptionType } from "@aws-sdk/smithy-client";
    import { TranslateServiceException as __BaseException } from "@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/models/TranslateServiceException";
    /**
        * <p>The term being translated by the custom terminology.</p>
        */
    export interface Term {
            /**
                * <p>The source text of the term being translated by the custom terminology.</p>
                */
            SourceText?: string;
            /**
                * <p>The target text of the term being translated by the custom terminology.</p>
                */
            TargetText?: string;
    }
    export namespace Term {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Term) => any;
    }
    /**
        * <p>The custom terminology applied to the input text by Amazon Translate for the translated text
        *       response. This is optional in the response and will only be present if you specified
        *       terminology input in the request. Currently, only one terminology can be applied per
        *       TranslateText request.</p>
        */
    export interface AppliedTerminology {
            /**
                * <p>The name of the custom terminology applied to the input text by Amazon Translate for the translated
                *       text response.</p>
                */
            Name?: string;
            /**
                * <p>The specific terms of the custom terminology applied to the input text by Amazon Translate for the
                *       translated text response. A maximum of 250 terms will be returned, and the specific terms
                *       applied will be the first 250 terms in the source text. </p>
                */
            Terms?: Term[];
    }
    export namespace AppliedTerminology {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AppliedTerminology) => any;
    }
    /**
        * <p>There was a conflict processing the request. Try your request again.</p>
        */
    export class ConflictException extends __BaseException {
            readonly name: "ConflictException";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ConflictException, __BaseException>);
    }
    export enum EncryptionKeyType {
            KMS = "KMS"
    }
    /**
        * <p>The encryption key used to encrypt this object.</p>
        */
    export interface EncryptionKey {
            /**
                * <p>The type of encryption key used by Amazon Translate to encrypt this object.</p>
                */
            Type: EncryptionKeyType | string | undefined;
            /**
                * <p>The Amazon Resource Name (ARN) of the encryption key being used to encrypt this object.</p>
                */
            Id: string | undefined;
    }
    export namespace EncryptionKey {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: EncryptionKey) => any;
    }
    export enum ParallelDataFormat {
            CSV = "CSV",
            TMX = "TMX",
            TSV = "TSV"
    }
    /**
        * <p>Specifies the format and S3 location of the parallel data input file.</p>
        */
    export interface ParallelDataConfig {
            /**
                * <p>The URI of the Amazon S3 folder that contains the parallel data input file. The folder
                *       must be in the same Region as the API endpoint you are calling.</p>
                */
            S3Uri: string | undefined;
            /**
                * <p>The format of the parallel data input file.</p>
                */
            Format: ParallelDataFormat | string | undefined;
    }
    export namespace ParallelDataConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ParallelDataConfig) => any;
    }
    export interface CreateParallelDataRequest {
            /**
                * <p>A custom name for the parallel data resource in Amazon Translate. You must assign a name
                *       that is unique in the account and region.</p>
                */
            Name: string | undefined;
            /**
                * <p>A custom description for the parallel data resource in Amazon Translate.</p>
                */
            Description?: string;
            /**
                * <p>Specifies the format and S3 location of the parallel data input file.</p>
                */
            ParallelDataConfig: ParallelDataConfig | undefined;
            /**
                * <p>The encryption key used to encrypt this object.</p>
                */
            EncryptionKey?: EncryptionKey;
            /**
                * <p>A unique identifier for the request. This token is automatically generated when you use
                *       Amazon Translate through an AWS SDK.</p>
                */
            ClientToken?: string;
    }
    export namespace CreateParallelDataRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateParallelDataRequest) => any;
    }
    export enum ParallelDataStatus {
            ACTIVE = "ACTIVE",
            CREATING = "CREATING",
            DELETING = "DELETING",
            FAILED = "FAILED",
            UPDATING = "UPDATING"
    }
    export interface CreateParallelDataResponse {
            /**
                * <p>The custom name that you assigned to the parallel data resource.</p>
                */
            Name?: string;
            /**
                * <p>The status of the parallel data resource. When the resource is ready for you to use, the
                *       status is <code>ACTIVE</code>.</p>
                */
            Status?: ParallelDataStatus | string;
    }
    export namespace CreateParallelDataResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateParallelDataResponse) => any;
    }
    /**
        * <p>An internal server error occurred. Retry your request.</p>
        */
    export class InternalServerException extends __BaseException {
            readonly name: "InternalServerException";
            readonly $fault: "server";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InternalServerException, __BaseException>);
    }
    /**
        * <p>The value of the parameter is not valid. Review the value of the parameter you are using
        *       to correct it, and then retry your operation.</p>
        */
    export class InvalidParameterValueException extends __BaseException {
            readonly name: "InvalidParameterValueException";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidParameterValueException, __BaseException>);
    }
    /**
        * <p> The request that you made is not valid. Check your request to determine why it's not
        *       valid and then retry the request. </p>
        */
    export class InvalidRequestException extends __BaseException {
            readonly name: "InvalidRequestException";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidRequestException, __BaseException>);
    }
    /**
        * <p>The specified limit has been exceeded. Review your request and retry it with a quantity
        *       below the stated limit.</p>
        */
    export class LimitExceededException extends __BaseException {
            readonly name: "LimitExceededException";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<LimitExceededException, __BaseException>);
    }
    /**
        * <p> You have made too many requests within a short period of time. Wait for a short time and
        *       then try your request again.</p>
        */
    export class TooManyRequestsException extends __BaseException {
            readonly name: "TooManyRequestsException";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TooManyRequestsException, __BaseException>);
    }
    /**
        * <p>Another modification is being made. That modification must complete before you can make
        *       your change.</p>
        */
    export class ConcurrentModificationException extends __BaseException {
            readonly name: "ConcurrentModificationException";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ConcurrentModificationException, __BaseException>);
    }
    export interface DeleteParallelDataRequest {
            /**
                * <p>The name of the parallel data resource that is being deleted.</p>
                */
            Name: string | undefined;
    }
    export namespace DeleteParallelDataRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteParallelDataRequest) => any;
    }
    export interface DeleteParallelDataResponse {
            /**
                * <p>The name of the parallel data resource that is being deleted.</p>
                */
            Name?: string;
            /**
                * <p>The status of the parallel data deletion.</p>
                */
            Status?: ParallelDataStatus | string;
    }
    export namespace DeleteParallelDataResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteParallelDataResponse) => any;
    }
    /**
        * <p>The resource you are looking for has not been found. Review the resource you're looking
        *       for and see if a different resource will accomplish your needs before retrying the revised
        *       request.</p>
        */
    export class ResourceNotFoundException extends __BaseException {
            readonly name: "ResourceNotFoundException";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ResourceNotFoundException, __BaseException>);
    }
    export interface DeleteTerminologyRequest {
            /**
                * <p>The name of the custom terminology being deleted. </p>
                */
            Name: string | undefined;
    }
    export namespace DeleteTerminologyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteTerminologyRequest) => any;
    }
    export interface DescribeTextTranslationJobRequest {
            /**
                * <p>The identifier that Amazon Translate generated for the job. The <a>StartTextTranslationJob</a> operation returns this identifier in its
                *       response.</p>
                */
            JobId: string | undefined;
    }
    export namespace DescribeTextTranslationJobRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeTextTranslationJobRequest) => any;
    }
    /**
        * <p>The input configuration properties for requesting a batch translation job.</p>
        */
    export interface InputDataConfig {
            /**
                * <p>The URI of the AWS S3 folder that contains the input files. Amazon Translate translates all the
                *       files in the folder. The folder must be in the same Region as the API endpoint you are
                *       calling.</p>
                *          <note>
                *             <p>The URI can also point to a single input document, or it can provide the prefix for a collection of
                *       input documents. For example. if you use the URI <code>S3://bucketName/prefix</code> and the
                *       prefix is a single file, Amazon Translate uses that files as input. If more than one file begins with the
                *       prefix, Amazon Translate uses all of them as input.</p>
                *          </note>
                */
            S3Uri: string | undefined;
            /**
                * <p>Describes the format of the data that you submit to Amazon Translate as input. You can
                *       specify one of the following multipurpose internet mail extension (MIME) types:</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <code>text/html</code>: The input data consists of one or more HTML files. Amazon
                *           Translate translates only the text that resides in the <code>html</code> element in each
                *           file.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>text/plain</code>: The input data consists of one or more unformatted text
                *           files. Amazon Translate translates every character in this type of input.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>application/vnd.openxmlformats-officedocument.wordprocessingml.document</code>:
                *           The input data consists of one or more Word documents (.docx).</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>application/vnd.openxmlformats-officedocument.presentationml.presentation</code>:
                *           The input data consists of one or more PowerPoint Presentation files (.pptx).</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>application/vnd.openxmlformats-officedocument.spreadsheetml.sheet</code>: The
                *           input data consists of one or more Excel Workbook files (.xlsx).</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>application/x-xliff+xml</code>: The input data consists of one or more XML
                *           Localization Interchange File Format (XLIFF) files (.xlf). Amazon Translate supports only
                *           XLIFF version 1.2.</p>
                *             </li>
                *          </ul>
                *          <important>
                *             <p>If you structure your input data as HTML, ensure that you set this parameter to
                *           <code>text/html</code>. By doing so, you cut costs by limiting the translation to the
                *         contents of the <code>html</code> element in each file. Otherwise, if you set this parameter
                *         to <code>text/plain</code>, your costs will cover the translation of every character.</p>
                *          </important>
                */
            ContentType: string | undefined;
    }
    export namespace InputDataConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: InputDataConfig) => any;
    }
    /**
        * <p>The number of documents successfully and unsuccessfully processed during a translation
        *       job.</p>
        */
    export interface JobDetails {
            /**
                * <p>The number of documents successfully processed during a translation job.</p>
                */
            TranslatedDocumentsCount?: number;
            /**
                * <p>The number of documents that could not be processed during a translation job.</p>
                */
            DocumentsWithErrorsCount?: number;
            /**
                * <p>The number of documents used as input in a translation job.</p>
                */
            InputDocumentsCount?: number;
    }
    export namespace JobDetails {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: JobDetails) => any;
    }
    export enum JobStatus {
            COMPLETED = "COMPLETED",
            COMPLETED_WITH_ERROR = "COMPLETED_WITH_ERROR",
            FAILED = "FAILED",
            IN_PROGRESS = "IN_PROGRESS",
            STOPPED = "STOPPED",
            STOP_REQUESTED = "STOP_REQUESTED",
            SUBMITTED = "SUBMITTED"
    }
    /**
        * <p>The output configuration properties for a batch translation job.</p>
        */
    export interface OutputDataConfig {
            /**
                * <p>The URI of the S3 folder that contains a translation job's output file. The folder must
                *       be in the same Region as the API endpoint that you are calling.</p>
                */
            S3Uri: string | undefined;
            /**
                * <p>The encryption key used to encrypt this object.</p>
                */
            EncryptionKey?: EncryptionKey;
    }
    export namespace OutputDataConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: OutputDataConfig) => any;
    }
    export enum Formality {
            FORMAL = "FORMAL",
            INFORMAL = "INFORMAL"
    }
    export enum Profanity {
            MASK = "MASK"
    }
    /**
        * <p>Settings that configure the translation output.</p>
        */
    export interface TranslationSettings {
            /**
                * <p>You can optionally specify the desired level of
                *        formality for real-time translations to supported target languages. The formality
                *       setting controls the level of formal language usage (also known as <a href="https://en.wikipedia.org/wiki/Register_(sociolinguistics)">register</a>) in the
                *       translation output.  You can set the value to informal or formal. If you don't specify a value for
                *       formality, or if the target language doesn't support formality, the translation will
                *       ignore the formality setting.</p>
                *          <p>Note that asynchronous translation jobs don't support formality. If you provide a value
                *       for formality, the <code>StartTextTranslationJob</code> API throws an exception (InvalidRequestException).</p>
                *          <p>For target languages that support formality, see <a href="https://docs.aws.amazon.com/translate/latest/dg/what-is.html">Supported
                *         Languages and Language Codes in the Amazon Translate Developer Guide</a>.</p>
                */
            Formality?: Formality | string;
            /**
                * <p>Enable the profanity setting if you want Amazon Translate to mask profane words and
                *       phrases in your translation output.</p>
                *          <p>To mask profane words and phrases, Amazon Translate replaces them with the grawlix string
                *       ?$#@$. This 5-character sequence is used for each profane word or phrase, regardless of the
                *       length or number of words.</p>
                *          <p>Amazon Translate doesn't detect profanity in all of its supported languages. For languages
                *       that support profanity detection, see <a href="https://docs.aws.amazon.com/translate/latest/dg/what-is.html">Supported
                *         Languages and Language Codes in the Amazon Translate Developer Guide</a>.</p>
                */
            Profanity?: Profanity | string;
    }
    export namespace TranslationSettings {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TranslationSettings) => any;
    }
    /**
        * <p>Provides information about a translation job.</p>
        */
    export interface TextTranslationJobProperties {
            /**
                * <p>The ID of the translation job.</p>
                */
            JobId?: string;
            /**
                * <p>The user-defined name of the translation job.</p>
                */
            JobName?: string;
            /**
                * <p>The status of the translation job.</p>
                */
            JobStatus?: JobStatus | string;
            /**
                * <p>The number of documents successfully and unsuccessfully processed during the translation
                *       job.</p>
                */
            JobDetails?: JobDetails;
            /**
                * <p>The language code of the language of the source text. The language must be a language
                *       supported by Amazon Translate.</p>
                */
            SourceLanguageCode?: string;
            /**
                * <p>The language code of the language of the target text. The language must be a language
                *       supported by Amazon Translate.</p>
                */
            TargetLanguageCodes?: string[];
            /**
                * <p>A list containing the names of the terminologies applied to a translation job. Only one
                *       terminology can be applied per <a>StartTextTranslationJob</a> request at this
                *       time.</p>
                */
            TerminologyNames?: string[];
            /**
                * <p>A list containing the names of the parallel data resources applied to the translation
                *       job.</p>
                */
            ParallelDataNames?: string[];
            /**
                * <p>An explanation of any errors that may have occurred during the translation job.</p>
                */
            Message?: string;
            /**
                * <p>The time at which the translation job was submitted.</p>
                */
            SubmittedTime?: Date;
            /**
                * <p>The time at which the translation job ended.</p>
                */
            EndTime?: Date;
            /**
                * <p>The input configuration properties that were specified when the job was requested.</p>
                */
            InputDataConfig?: InputDataConfig;
            /**
                * <p>The output configuration properties that were specified when the job was requested.</p>
                */
            OutputDataConfig?: OutputDataConfig;
            /**
                * <p>The Amazon Resource Name (ARN) of an AWS Identity Access and Management (IAM) role
                *       that granted Amazon Translate read access to the job's input data.</p>
                */
            DataAccessRoleArn?: string;
            /**
                * <p>Settings that configure the translation output.</p>
                */
            Settings?: TranslationSettings;
    }
    export namespace TextTranslationJobProperties {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TextTranslationJobProperties) => any;
    }
    export interface DescribeTextTranslationJobResponse {
            /**
                * <p>An object that contains the properties associated with an asynchronous batch translation
                *       job.</p>
                */
            TextTranslationJobProperties?: TextTranslationJobProperties;
    }
    export namespace DescribeTextTranslationJobResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeTextTranslationJobResponse) => any;
    }
    export interface GetParallelDataRequest {
            /**
                * <p>The name of the parallel data resource that is being retrieved.</p>
                */
            Name: string | undefined;
    }
    export namespace GetParallelDataRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetParallelDataRequest) => any;
    }
    /**
        * <p>The location of the most recent parallel data input file that was successfully imported
        *       into Amazon Translate.</p>
        */
    export interface ParallelDataDataLocation {
            /**
                * <p>Describes the repository that contains the parallel data input file.</p>
                */
            RepositoryType: string | undefined;
            /**
                * <p>The Amazon S3 location of the parallel data input file. The location is returned as a
                *       presigned URL to that has a 30-minute expiration.</p>
                *
                *          <important>
                *             <p>Amazon Translate doesn't scan all input files for the risk of CSV injection
                *         attacks. </p>
                *             <p>CSV injection occurs when a .csv or .tsv file is altered so that a record contains
                *         malicious code. The record begins with a special character, such as =, +, -, or @. When the
                *         file is opened in a spreadsheet program, the program might interpret the record as a formula
                *         and run the code within it.</p>
                *             <p>Before you download an input file from Amazon S3, ensure that you recognize the file and trust its creator.</p>
                *          </important>
                */
            Location: string | undefined;
    }
    export namespace ParallelDataDataLocation {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ParallelDataDataLocation) => any;
    }
    /**
        * <p>The properties of a parallel data resource.</p>
        */
    export interface ParallelDataProperties {
            /**
                * <p>The custom name assigned to the parallel data resource.</p>
                */
            Name?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of the parallel data resource.</p>
                */
            Arn?: string;
            /**
                * <p>The description assigned to the parallel data resource.</p>
                */
            Description?: string;
            /**
                * <p>The status of the parallel data resource. When the parallel data is ready for you to use,
                *       the status is <code>ACTIVE</code>.</p>
                */
            Status?: ParallelDataStatus | string;
            /**
                * <p>The source language of the translations in the parallel data file.</p>
                */
            SourceLanguageCode?: string;
            /**
                * <p>The language codes for the target languages available in the parallel data file. All
                *       possible target languages are returned as an array.</p>
                */
            TargetLanguageCodes?: string[];
            /**
                * <p>Specifies the format and S3 location of the parallel data input file.</p>
                */
            ParallelDataConfig?: ParallelDataConfig;
            /**
                * <p>Additional information from Amazon Translate about the parallel data resource. </p>
                */
            Message?: string;
            /**
                * <p>The number of UTF-8 characters that Amazon Translate imported from the parallel data input
                *       file. This number includes only the characters in your translation examples. It does not
                *       include characters that are used to format your file. For example, if you provided a
                *       Translation Memory Exchange (.tmx) file, this number does not include the tags.</p>
                */
            ImportedDataSize?: number;
            /**
                * <p>The number of records successfully imported from the parallel data input file.</p>
                */
            ImportedRecordCount?: number;
            /**
                * <p>The number of records unsuccessfully imported from the parallel data input file.</p>
                */
            FailedRecordCount?: number;
            /**
                * <p>The number of items in the input file that Amazon Translate skipped when you created or
                *       updated the parallel data resource. For example, Amazon Translate skips empty records, empty
                *       target texts, and empty lines.</p>
                */
            SkippedRecordCount?: number;
            /**
                * <p>The encryption key used to encrypt this object.</p>
                */
            EncryptionKey?: EncryptionKey;
            /**
                * <p>The time at which the parallel data resource was created.</p>
                */
            CreatedAt?: Date;
            /**
                * <p>The time at which the parallel data resource was last updated.</p>
                */
            LastUpdatedAt?: Date;
            /**
                * <p>The status of the most recent update attempt for the parallel data resource.</p>
                */
            LatestUpdateAttemptStatus?: ParallelDataStatus | string;
            /**
                * <p>The time that the most recent update was attempted.</p>
                */
            LatestUpdateAttemptAt?: Date;
    }
    export namespace ParallelDataProperties {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ParallelDataProperties) => any;
    }
    export interface GetParallelDataResponse {
            /**
                * <p>The properties of the parallel data resource that is being retrieved.</p>
                */
            ParallelDataProperties?: ParallelDataProperties;
            /**
                * <p>The Amazon S3 location of the most recent parallel data input file that was successfully
                *       imported into Amazon Translate. The location is returned as a presigned URL that has a
                *       30-minute expiration.</p>
                *
                *          <important>
                *             <p>Amazon Translate doesn't scan all input files for the risk of CSV injection
                *         attacks. </p>
                *             <p>CSV injection occurs when a .csv or .tsv file is altered so that a record contains
                *         malicious code. The record begins with a special character, such as =, +, -, or @. When the
                *         file is opened in a spreadsheet program, the program might interpret the record as a formula
                *         and run the code within it.</p>
                *             <p>Before you download an input file from Amazon S3, ensure that you recognize the file and trust its creator.</p>
                *          </important>
                */
            DataLocation?: ParallelDataDataLocation;
            /**
                * <p>The Amazon S3 location of a file that provides any errors or warnings that were produced
                *       by your input file. This file was created when Amazon Translate attempted to create a parallel
                *       data resource. The location is returned as a presigned URL to that has a 30-minute
                *       expiration.</p>
                */
            AuxiliaryDataLocation?: ParallelDataDataLocation;
            /**
                * <p>The Amazon S3 location of a file that provides any errors or warnings that were produced
                *       by your input file. This file was created when Amazon Translate attempted to update a parallel
                *       data resource. The location is returned as a presigned URL to that has a 30-minute
                *       expiration.</p>
                */
            LatestUpdateAttemptAuxiliaryDataLocation?: ParallelDataDataLocation;
    }
    export namespace GetParallelDataResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetParallelDataResponse) => any;
    }
    export enum TerminologyDataFormat {
            CSV = "CSV",
            TMX = "TMX",
            TSV = "TSV"
    }
    export interface GetTerminologyRequest {
            /**
                * <p>The name of the custom terminology being retrieved.</p>
                */
            Name: string | undefined;
            /**
                * <p>The data format of the custom terminology being retrieved.</p>
                *          <p>If you don't specify this parameter, Amazon Translate returns a file with the same format
                *       as the file that was imported to create the terminology. </p>
                *          <p>If you specify this parameter when you retrieve a multi-directional terminology resource,
                *       you must specify the same format as the input file that was imported to create it. Otherwise,
                *       Amazon Translate throws an error.</p>
                */
            TerminologyDataFormat?: TerminologyDataFormat | string;
    }
    export namespace GetTerminologyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetTerminologyRequest) => any;
    }
    /**
        * <p>The location of the custom terminology data.</p>
        */
    export interface TerminologyDataLocation {
            /**
                * <p>The repository type for the custom terminology data.</p>
                */
            RepositoryType: string | undefined;
            /**
                * <p>The Amazon S3 location of the most recent custom terminology input file that was
                *       successfully imported into Amazon Translate. The location is returned as a presigned URL that
                *       has a 30-minute expiration .</p>
                *
                *          <important>
                *             <p>Amazon Translate doesn't scan all input files for the risk of CSV injection
                *         attacks. </p>
                *             <p>CSV injection occurs when a .csv or .tsv file is altered so that a record contains
                *         malicious code. The record begins with a special character, such as =, +, -, or @. When the
                *         file is opened in a spreadsheet program, the program might interpret the record as a formula
                *         and run the code within it.</p>
                *             <p>Before you download an input file from Amazon S3, ensure that you recognize the file and trust its creator.</p>
                *          </important>
                */
            Location: string | undefined;
    }
    export namespace TerminologyDataLocation {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TerminologyDataLocation) => any;
    }
    export enum Directionality {
            MULTI = "MULTI",
            UNI = "UNI"
    }
    /**
        * <p>The properties of the custom terminology.</p>
        */
    export interface TerminologyProperties {
            /**
                * <p>The name of the custom terminology.</p>
                */
            Name?: string;
            /**
                * <p>The description of the custom terminology properties.</p>
                */
            Description?: string;
            /**
                * <p> The Amazon Resource Name (ARN) of the custom terminology. </p>
                */
            Arn?: string;
            /**
                * <p>The language code for the source text of the translation request for which the custom
                *       terminology is being used.</p>
                */
            SourceLanguageCode?: string;
            /**
                * <p>The language codes for the target languages available with the custom terminology
                *       resource. All possible target languages are returned in array.</p>
                */
            TargetLanguageCodes?: string[];
            /**
                * <p>The encryption key for the custom terminology.</p>
                */
            EncryptionKey?: EncryptionKey;
            /**
                * <p>The size of the file used when importing a custom terminology.</p>
                */
            SizeBytes?: number;
            /**
                * <p>The number of terms included in the custom terminology.</p>
                */
            TermCount?: number;
            /**
                * <p>The time at which the custom terminology was created, based on the timestamp.</p>
                */
            CreatedAt?: Date;
            /**
                * <p>The time at which the custom terminology was last update, based on the timestamp.</p>
                */
            LastUpdatedAt?: Date;
            /**
                * <p>The directionality of your terminology resource indicates whether it has one source
                *       language (uni-directional) or multiple (multi-directional). </p>
                *          <dl>
                *             <dt>UNI</dt>
                *             <dd>
                *                <p>The terminology resource has one source language (the first column in a CSV file),
                *             and all of its other languages are target languages.</p>
                *             </dd>
                *             <dt>MULTI</dt>
                *             <dd>
                *                <p>Any language in the terminology resource can be the source language.</p>
                *             </dd>
                *          </dl>
                */
            Directionality?: Directionality | string;
            /**
                * <p>Additional information from Amazon Translate about the terminology resource.</p>
                */
            Message?: string;
            /**
                * <p>The number of terms in the input file that Amazon Translate skipped when you created or
                *       updated the terminology resource.</p>
                */
            SkippedTermCount?: number;
            /**
                * <p>The format of the custom terminology input file.</p>
                */
            Format?: TerminologyDataFormat | string;
    }
    export namespace TerminologyProperties {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TerminologyProperties) => any;
    }
    export interface GetTerminologyResponse {
            /**
                * <p>The properties of the custom terminology being retrieved.</p>
                */
            TerminologyProperties?: TerminologyProperties;
            /**
                * <p>The Amazon S3 location of the most recent custom terminology input file that was
                *       successfully imported into Amazon Translate. The location is returned as a presigned URL that
                *       has a 30-minute expiration.</p>
                *
                *          <important>
                *             <p>Amazon Translate doesn't scan all input files for the risk of CSV injection
                *         attacks. </p>
                *             <p>CSV injection occurs when a .csv or .tsv file is altered so that a record contains
                *         malicious code. The record begins with a special character, such as =, +, -, or @. When the
                *         file is opened in a spreadsheet program, the program might interpret the record as a formula
                *         and run the code within it.</p>
                *             <p>Before you download an input file from Amazon S3, ensure that you recognize the file and trust its creator.</p>
                *          </important>
                */
            TerminologyDataLocation?: TerminologyDataLocation;
            /**
                * <p>The Amazon S3 location of a file that provides any errors or warnings that were produced
                *       by your input file. This file was created when Amazon Translate attempted to create a
                *       terminology resource. The location is returned as a presigned URL to that has a 30-minute
                *       expiration.</p>
                */
            AuxiliaryDataLocation?: TerminologyDataLocation;
    }
    export namespace GetTerminologyResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetTerminologyResponse) => any;
    }
    export enum MergeStrategy {
            OVERWRITE = "OVERWRITE"
    }
    /**
        * <p>The data associated with the custom terminology. For information about the custom terminology file, see <a href="https://docs.aws.amazon.com/translate/latest/dg/creating-custom-terminology.html">
        *       Creating a Custom Terminology</a>.</p>
        */
    export interface TerminologyData {
            /**
                * <p>The file containing the custom terminology data. Your version of the AWS SDK performs a
                *       Base64-encoding on this field before sending a request to the AWS service. Users of the SDK
                *       should not perform Base64-encoding themselves.</p>
                */
            File: Uint8Array | undefined;
            /**
                * <p>The data format of the custom terminology.</p>
                */
            Format: TerminologyDataFormat | string | undefined;
            /**
                * <p>The directionality of your terminology resource indicates whether it has one source
                *       language (uni-directional) or multiple (multi-directional).</p>
                *          <dl>
                *             <dt>UNI</dt>
                *             <dd>
                *                <p>The terminology resource has one source language (for example, the first column in a
                *             CSV file), and all of its other languages are target languages. </p>
                *             </dd>
                *             <dt>MULTI</dt>
                *             <dd>
                *                <p>Any language in the terminology resource can be the source language or a target
                *             language. A single multi-directional terminology resource can be used for jobs that
                *             translate different language pairs. For example, if the terminology contains English and
                *             Spanish terms, it can be used for jobs that translate English to Spanish and Spanish to
                *             English.</p>
                *             </dd>
                *          </dl>
                *          <p>When you create a custom terminology resource without specifying the directionality, it
                *       behaves as uni-directional terminology, although this parameter will have a null value.</p>
                */
            Directionality?: Directionality | string;
    }
    export namespace TerminologyData {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TerminologyData) => any;
    }
    export interface ImportTerminologyRequest {
            /**
                * <p>The name of the custom terminology being imported.</p>
                */
            Name: string | undefined;
            /**
                * <p>The merge strategy of the custom terminology being imported. Currently, only the OVERWRITE
                *       merge strategy is supported. In this case, the imported terminology will overwrite an existing
                *       terminology of the same name.</p>
                */
            MergeStrategy: MergeStrategy | string | undefined;
            /**
                * <p>The description of the custom terminology being imported.</p>
                */
            Description?: string;
            /**
                * <p>The terminology data for the custom terminology being imported.</p>
                */
            TerminologyData: TerminologyData | undefined;
            /**
                * <p>The encryption key for the custom terminology being imported.</p>
                */
            EncryptionKey?: EncryptionKey;
    }
    export namespace ImportTerminologyRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ImportTerminologyRequest) => any;
    }
    export interface ImportTerminologyResponse {
            /**
                * <p>The properties of the custom terminology being imported.</p>
                */
            TerminologyProperties?: TerminologyProperties;
            /**
                * <p>The Amazon S3 location of a file that provides any errors or warnings that were produced
                *       by your input file. This file was created when Amazon Translate attempted to create a
                *       terminology resource. The location is returned as a presigned URL to that has a 30 minute
                *       expiration.</p>
                */
            AuxiliaryDataLocation?: TerminologyDataLocation;
    }
    export namespace ImportTerminologyResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ImportTerminologyResponse) => any;
    }
    export enum DisplayLanguageCode {
            DE = "de",
            EN = "en",
            ES = "es",
            FR = "fr",
            IT = "it",
            JA = "ja",
            KO = "ko",
            PT = "pt",
            ZH = "zh",
            ZH_TW = "zh-TW"
    }
    export interface ListLanguagesRequest {
            /**
                * <p>The language code for the language to use to display the language names in the response.
                *       The language code is <code>en</code> by default. </p>
                */
            DisplayLanguageCode?: DisplayLanguageCode | string;
            /**
                * <p>Include the NextToken value to fetch the next group of supported languages. </p>
                */
            NextToken?: string;
            /**
                * <p>The maximum number of results to return in each response.</p>
                */
            MaxResults?: number;
    }
    export namespace ListLanguagesRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListLanguagesRequest) => any;
    }
    /**
        * <p>A supported language.</p>
        */
    export interface Language {
            /**
                * <p>Language name of the supported language.</p>
                */
            LanguageName: string | undefined;
            /**
                * <p>Language code for the supported language.</p>
                */
            LanguageCode: string | undefined;
    }
    export namespace Language {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Language) => any;
    }
    export interface ListLanguagesResponse {
            /**
                * <p>The list of supported languages.</p>
                */
            Languages?: Language[];
            /**
                * <p>The language code passed in with the request.</p>
                */
            DisplayLanguageCode?: DisplayLanguageCode | string;
            /**
                * <p> If the response does not include all remaining results, use the NextToken
                *       in the next request to fetch the next group of supported languages.</p>
                */
            NextToken?: string;
    }
    export namespace ListLanguagesResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListLanguagesResponse) => any;
    }
    /**
        * <p>Requested display language code is not supported.</p>
        */
    export class UnsupportedDisplayLanguageCodeException extends __BaseException {
            readonly name: "UnsupportedDisplayLanguageCodeException";
            readonly $fault: "client";
            Message?: string;
            /**
                * <p>Language code passed in with the request.</p>
                */
            DisplayLanguageCode?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<UnsupportedDisplayLanguageCodeException, __BaseException>);
    }
    export interface ListParallelDataRequest {
            /**
                * <p>A string that specifies the next page of results to return in a paginated response.</p>
                */
            NextToken?: string;
            /**
                * <p>The maximum number of parallel data resources returned for each request.</p>
                */
            MaxResults?: number;
    }
    export namespace ListParallelDataRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListParallelDataRequest) => any;
    }
    export interface ListParallelDataResponse {
            /**
                * <p>The properties of the parallel data resources returned by this request.</p>
                */
            ParallelDataPropertiesList?: ParallelDataProperties[];
            /**
                * <p>The string to use in a subsequent request to get the next page of results in a paginated
                *       response. This value is null if there are no additional pages.</p>
                */
            NextToken?: string;
    }
    export namespace ListParallelDataResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListParallelDataResponse) => any;
    }
    export interface ListTerminologiesRequest {
            /**
                * <p>If the result of the request to ListTerminologies was truncated, include the NextToken to
                *       fetch the next group of custom terminologies. </p>
                */
            NextToken?: string;
            /**
                * <p>The maximum number of custom terminologies returned per list request.</p>
                */
            MaxResults?: number;
    }
    export namespace ListTerminologiesRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTerminologiesRequest) => any;
    }
    export interface ListTerminologiesResponse {
            /**
                * <p>The properties list of the custom terminologies returned on the list request.</p>
                */
            TerminologyPropertiesList?: TerminologyProperties[];
            /**
                * <p> If the response to the ListTerminologies was truncated, the NextToken fetches the next
                *       group of custom terminologies.</p>
                */
            NextToken?: string;
    }
    export namespace ListTerminologiesResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTerminologiesResponse) => any;
    }
    /**
        * <p>The filter specified for the operation is not valid. Specify a different filter.</p>
        */
    export class InvalidFilterException extends __BaseException {
            readonly name: "InvalidFilterException";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidFilterException, __BaseException>);
    }
    /**
        * <p>Provides information for filtering a list of translation jobs. For more information, see
        *         <a>ListTextTranslationJobs</a>.</p>
        */
    export interface TextTranslationJobFilter {
            /**
                * <p>Filters the list of jobs by name.</p>
                */
            JobName?: string;
            /**
                * <p>Filters the list of jobs based by job status.</p>
                */
            JobStatus?: JobStatus | string;
            /**
                * <p>Filters the list of jobs based on the time that the job was submitted for processing and
                *       returns only the jobs submitted before the specified time. Jobs are returned in ascending
                *       order, oldest to newest.</p>
                */
            SubmittedBeforeTime?: Date;
            /**
                * <p>Filters the list of jobs based on the time that the job was submitted for processing and
                *       returns only the jobs submitted after the specified time. Jobs are returned in descending
                *       order, newest to oldest.</p>
                */
            SubmittedAfterTime?: Date;
    }
    export namespace TextTranslationJobFilter {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TextTranslationJobFilter) => any;
    }
    export interface ListTextTranslationJobsRequest {
            /**
                * <p>The parameters that specify which batch translation jobs to retrieve. Filters include job
                *       name, job status, and submission time. You can only set one filter at a time.</p>
                */
            Filter?: TextTranslationJobFilter;
            /**
                * <p>The token to request the next page of results.</p>
                */
            NextToken?: string;
            /**
                * <p>The maximum number of results to return in each page. The default value is 100.</p>
                */
            MaxResults?: number;
    }
    export namespace ListTextTranslationJobsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTextTranslationJobsRequest) => any;
    }
    export interface ListTextTranslationJobsResponse {
            /**
                * <p>A list containing the properties of each job that is returned.</p>
                */
            TextTranslationJobPropertiesList?: TextTranslationJobProperties[];
            /**
                * <p>The token to use to retrieve the next page of results. This value is <code>null</code>
                *       when there are no more results to return.</p>
                */
            NextToken?: string;
    }
    export namespace ListTextTranslationJobsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTextTranslationJobsResponse) => any;
    }
    export interface StartTextTranslationJobRequest {
            /**
                * <p>The name of the batch translation job to be performed.</p>
                */
            JobName?: string;
            /**
                * <p>Specifies the format and location of the input documents for the translation job.</p>
                */
            InputDataConfig: InputDataConfig | undefined;
            /**
                * <p>Specifies the S3 folder to which your job output will be saved.
                *       </p>
                */
            OutputDataConfig: OutputDataConfig | undefined;
            /**
                * <p>The Amazon Resource Name (ARN) of an AWS Identity Access and Management (IAM) role
                *       that grants Amazon Translate read access to your input data. For more information, see <a>identity-and-access-management</a>.</p>
                */
            DataAccessRoleArn: string | undefined;
            /**
                * <p>The language code of the input language. For a list of language codes, see <a>what-is-languages</a>.</p>
                *          <p>Amazon Translate does not automatically detect a source language during batch translation
                *       jobs.</p>
                */
            SourceLanguageCode: string | undefined;
            /**
                * <p>The language code of the output language.</p>
                */
            TargetLanguageCodes: string[] | undefined;
            /**
                * <p>The name of a custom terminology resource to add to the translation job. This resource
                *       lists examples source terms and the desired translation for each term.</p>
                *          <p>This parameter accepts only one custom terminology resource.</p>
                *          <p>For a list of available custom terminology resources, use the <a>ListTerminologies</a> operation.</p>
                *          <p>For more information, see <a>how-custom-terminology</a>.</p>
                */
            TerminologyNames?: string[];
            /**
                * <p>The name of a parallel data resource to add to the translation job. This resource consists
                *       of examples that show how you want segments of text to be translated. When you add parallel
                *       data to a translation job, you create an <i>Active Custom Translation</i> job. </p>
                *          <p>This parameter accepts only one parallel data resource.</p>
                *          <note>
                *             <p>Active Custom Translation jobs are priced at a higher rate than other jobs that don't
                *         use parallel data. For more information, see <a href="http://aws.amazon.com/translate/pricing/">Amazon Translate pricing</a>.</p>
                *          </note>
                *          <p>For a list of available parallel data resources, use the <a>ListParallelData</a> operation.</p>
                *          <p>For more information, see <a>customizing-translations-parallel-data</a>.</p>
                */
            ParallelDataNames?: string[];
            /**
                * <p>A unique identifier for the request. This token is generated for you when using the Amazon Translate
                *       SDK.</p>
                */
            ClientToken?: string;
            /**
                * <p>Settings to configure your translation output, including the option to mask profane words
                *       and phrases. <code>StartTextTranslationJob</code> does not support the formality setting.</p>
                */
            Settings?: TranslationSettings;
    }
    export namespace StartTextTranslationJobRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StartTextTranslationJobRequest) => any;
    }
    export interface StartTextTranslationJobResponse {
            /**
                * <p>The identifier generated for the job. To get the status of a job, use this ID with the
                *         <a>DescribeTextTranslationJob</a> operation.</p>
                */
            JobId?: string;
            /**
                * <p>The status of the job. Possible values include:</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <code>SUBMITTED</code> - The job has been received and is queued for
                *           processing.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>IN_PROGRESS</code> - Amazon Translate is processing the job.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>COMPLETED</code> - The job was successfully completed and the output is
                *           available.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>COMPLETED_WITH_ERROR</code> - The job was completed with errors. The errors can
                *           be analyzed in the job's output.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>FAILED</code> - The job did not complete. To get details, use the <a>DescribeTextTranslationJob</a> operation.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>STOP_REQUESTED</code> - The user who started the job has requested that it be
                *           stopped.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>STOPPED</code> - The job has been stopped.</p>
                *             </li>
                *          </ul>
                */
            JobStatus?: JobStatus | string;
    }
    export namespace StartTextTranslationJobResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StartTextTranslationJobResponse) => any;
    }
    /**
        * <p>Amazon Translate does not support translation from the language of the source text into the requested
        *       target language. For more information, see <a>how-to-error-msg</a>. </p>
        */
    export class UnsupportedLanguagePairException extends __BaseException {
            readonly name: "UnsupportedLanguagePairException";
            readonly $fault: "client";
            Message?: string;
            /**
                * <p>The language code for the language of the input text. </p>
                */
            SourceLanguageCode?: string;
            /**
                * <p>The language code for the language of the translated text. </p>
                */
            TargetLanguageCode?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<UnsupportedLanguagePairException, __BaseException>);
    }
    export interface StopTextTranslationJobRequest {
            /**
                * <p>The job ID of the job to be stopped.</p>
                */
            JobId: string | undefined;
    }
    export namespace StopTextTranslationJobRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StopTextTranslationJobRequest) => any;
    }
    export interface StopTextTranslationJobResponse {
            /**
                * <p>The job ID of the stopped batch translation job.</p>
                */
            JobId?: string;
            /**
                * <p>The status of the designated job. Upon successful completion, the job's status will be
                *         <code>STOPPED</code>.</p>
                */
            JobStatus?: JobStatus | string;
    }
    export namespace StopTextTranslationJobResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StopTextTranslationJobResponse) => any;
    }
    /**
        * <p>The confidence that Amazon Comprehend accurately detected the source language is low. If a
        *       low confidence level is acceptable for your application, you can use the language in the
        *       exception to call Amazon Translate again. For more information, see the <a href="https://docs.aws.amazon.com/comprehend/latest/dg/API_DetectDominantLanguage.html">DetectDominantLanguage</a> operation in the <i>Amazon Comprehend Developer
        *         Guide</i>. </p>
        */
    export class DetectedLanguageLowConfidenceException extends __BaseException {
            readonly name: "DetectedLanguageLowConfidenceException";
            readonly $fault: "client";
            Message?: string;
            /**
                * <p>The language code of the auto-detected language from Amazon Comprehend.</p>
                */
            DetectedLanguageCode?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<DetectedLanguageLowConfidenceException, __BaseException>);
    }
    /**
        * <p>The Amazon Translate service is temporarily unavailable. Wait a bit and then retry your
        *       request.</p>
        */
    export class ServiceUnavailableException extends __BaseException {
            readonly name: "ServiceUnavailableException";
            readonly $fault: "server";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ServiceUnavailableException, __BaseException>);
    }
    /**
        * <p> The size of the text you submitted exceeds the size limit. Reduce the size of the text or
        *       use a smaller document and then retry your request. </p>
        */
    export class TextSizeLimitExceededException extends __BaseException {
            readonly name: "TextSizeLimitExceededException";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TextSizeLimitExceededException, __BaseException>);
    }
    export interface TranslateTextRequest {
            /**
                * <p>The text to translate. The text string can be a maximum of 5,000 bytes long. Depending on
                *       your character set, this may be fewer than 5,000 characters.</p>
                */
            Text: string | undefined;
            /**
                * <p>The name of the terminology list file to be used in the TranslateText request. You can use
                *       1 terminology list at most in a <code>TranslateText</code> request. Terminology lists can
                *       contain a maximum of 256 terms.</p>
                */
            TerminologyNames?: string[];
            /**
                * <p>The language code for the language of the source text. The language must be a language
                *       supported by Amazon Translate. For a list of language codes, see <a>what-is-languages</a>.</p>
                *          <p>To have Amazon Translate determine the source language of your text, you can specify
                *         <code>auto</code> in the <code>SourceLanguageCode</code> field. If you specify
                *         <code>auto</code>, Amazon Translate will call <a href="https://docs.aws.amazon.com/comprehend/latest/dg/comprehend-general.html">Amazon
                *         Comprehend</a> to determine the source language.</p>
                *          <note>
                *             <p>If you specify <code>auto</code>, you must send the <code>TranslateText</code> request in a region that supports
                *           Amazon Comprehend. Otherwise, the request returns an error indicating that autodetect is not supported. </p>
                *          </note>
                */
            SourceLanguageCode: string | undefined;
            /**
                * <p>The language code requested for the language of the target text. The language must be a
                *       language supported by Amazon Translate.</p>
                */
            TargetLanguageCode: string | undefined;
            /**
                * <p>Settings to configure your translation output, including the option to set the formality
                *       level of the output text and the option to mask profane words and phrases.</p>
                */
            Settings?: TranslationSettings;
    }
    export namespace TranslateTextRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TranslateTextRequest) => any;
    }
    export interface TranslateTextResponse {
            /**
                * <p>The translated text.</p>
                */
            TranslatedText: string | undefined;
            /**
                * <p>The language code for the language of the source text.</p>
                */
            SourceLanguageCode: string | undefined;
            /**
                * <p>The language code for the language of the target text. </p>
                */
            TargetLanguageCode: string | undefined;
            /**
                * <p>The names of the custom terminologies applied to the input text by Amazon Translate for the
                *       translated text response.</p>
                */
            AppliedTerminologies?: AppliedTerminology[];
            /**
                * <p>Settings that configure the translation output.</p>
                */
            AppliedSettings?: TranslationSettings;
    }
    export namespace TranslateTextResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TranslateTextResponse) => any;
    }
    export interface UpdateParallelDataRequest {
            /**
                * <p>The name of the parallel data resource being updated.</p>
                */
            Name: string | undefined;
            /**
                * <p>A custom description for the parallel data resource in Amazon Translate.</p>
                */
            Description?: string;
            /**
                * <p>Specifies the format and S3 location of the parallel data input file.</p>
                */
            ParallelDataConfig: ParallelDataConfig | undefined;
            /**
                * <p>A unique identifier for the request. This token is automatically generated when you use
                *       Amazon Translate through an AWS SDK.</p>
                */
            ClientToken?: string;
    }
    export namespace UpdateParallelDataRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateParallelDataRequest) => any;
    }
    export interface UpdateParallelDataResponse {
            /**
                * <p>The name of the parallel data resource being updated.</p>
                */
            Name?: string;
            /**
                * <p>The status of the parallel data resource that you are attempting to update. Your update
                *       request is accepted only if this status is either <code>ACTIVE</code> or
                *       <code>FAILED</code>.</p>
                */
            Status?: ParallelDataStatus | string;
            /**
                * <p>The status of the parallel data update attempt. When the updated parallel data resource is
                *       ready for you to use, the status is <code>ACTIVE</code>.</p>
                */
            LatestUpdateAttemptStatus?: ParallelDataStatus | string;
            /**
                * <p>The time that the most recent update was attempted.</p>
                */
            LatestUpdateAttemptAt?: Date;
    }
    export namespace UpdateParallelDataResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateParallelDataResponse) => any;
    }
}

declare module '@aws-sdk/client-translate/node_modules/@aws-sdk/client-translate/dist-types/models/TranslateServiceException' {
    import { ServiceException as __ServiceException, ServiceExceptionOptions as __ServiceExceptionOptions } from "@aws-sdk/smithy-client";
    /**
        * Base exception class for all service exceptions from Translate service.
        */
    export class TranslateServiceException extends __ServiceException {
            /**
                * @internal
                */
            constructor(options: __ServiceExceptionOptions);
    }
}

