// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   @aws-sdk/types
//   @aws-sdk/smithy-client
//   @aws-sdk/config-resolver
//   @aws-sdk/middleware-endpoint-discovery
//   @aws-sdk/middleware-host-header
//   @aws-sdk/middleware-retry
//   @aws-sdk/middleware-signing
//   @aws-sdk/middleware-user-agent
//   @aws-sdk/protocol-http

declare module '@aws-sdk/client-dynamodb' {
    import { HttpHandlerOptions as __HttpHandlerOptions } from "@aws-sdk/types";
    import { BatchExecuteStatementCommandInput, BatchExecuteStatementCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/BatchExecuteStatementCommand";
    import { BatchGetItemCommandInput, BatchGetItemCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/BatchGetItemCommand";
    import { BatchWriteItemCommandInput, BatchWriteItemCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/BatchWriteItemCommand";
    import { CreateBackupCommandInput, CreateBackupCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/CreateBackupCommand";
    import { CreateGlobalTableCommandInput, CreateGlobalTableCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/CreateGlobalTableCommand";
    import { CreateTableCommandInput, CreateTableCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/CreateTableCommand";
    import { DeleteBackupCommandInput, DeleteBackupCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/DeleteBackupCommand";
    import { DeleteItemCommandInput, DeleteItemCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/DeleteItemCommand";
    import { DeleteTableCommandInput, DeleteTableCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/DeleteTableCommand";
    import { DescribeBackupCommandInput, DescribeBackupCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/DescribeBackupCommand";
    import { DescribeContinuousBackupsCommandInput, DescribeContinuousBackupsCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/DescribeContinuousBackupsCommand";
    import { DescribeContributorInsightsCommandInput, DescribeContributorInsightsCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/DescribeContributorInsightsCommand";
    import { DescribeEndpointsCommandInput, DescribeEndpointsCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/DescribeEndpointsCommand";
    import { DescribeExportCommandInput, DescribeExportCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/DescribeExportCommand";
    import { DescribeGlobalTableCommandInput, DescribeGlobalTableCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/DescribeGlobalTableCommand";
    import { DescribeGlobalTableSettingsCommandInput, DescribeGlobalTableSettingsCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/DescribeGlobalTableSettingsCommand";
    import { DescribeKinesisStreamingDestinationCommandInput, DescribeKinesisStreamingDestinationCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/DescribeKinesisStreamingDestinationCommand";
    import { DescribeLimitsCommandInput, DescribeLimitsCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/DescribeLimitsCommand";
    import { DescribeTableCommandInput, DescribeTableCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/DescribeTableCommand";
    import { DescribeTableReplicaAutoScalingCommandInput, DescribeTableReplicaAutoScalingCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/DescribeTableReplicaAutoScalingCommand";
    import { DescribeTimeToLiveCommandInput, DescribeTimeToLiveCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/DescribeTimeToLiveCommand";
    import { DisableKinesisStreamingDestinationCommandInput, DisableKinesisStreamingDestinationCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/DisableKinesisStreamingDestinationCommand";
    import { EnableKinesisStreamingDestinationCommandInput, EnableKinesisStreamingDestinationCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/EnableKinesisStreamingDestinationCommand";
    import { ExecuteStatementCommandInput, ExecuteStatementCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/ExecuteStatementCommand";
    import { ExecuteTransactionCommandInput, ExecuteTransactionCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/ExecuteTransactionCommand";
    import { ExportTableToPointInTimeCommandInput, ExportTableToPointInTimeCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/ExportTableToPointInTimeCommand";
    import { GetItemCommandInput, GetItemCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/GetItemCommand";
    import { ListBackupsCommandInput, ListBackupsCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/ListBackupsCommand";
    import { ListContributorInsightsCommandInput, ListContributorInsightsCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/ListContributorInsightsCommand";
    import { ListExportsCommandInput, ListExportsCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/ListExportsCommand";
    import { ListGlobalTablesCommandInput, ListGlobalTablesCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/ListGlobalTablesCommand";
    import { ListTablesCommandInput, ListTablesCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/ListTablesCommand";
    import { ListTagsOfResourceCommandInput, ListTagsOfResourceCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/ListTagsOfResourceCommand";
    import { PutItemCommandInput, PutItemCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/PutItemCommand";
    import { QueryCommandInput, QueryCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/QueryCommand";
    import { RestoreTableFromBackupCommandInput, RestoreTableFromBackupCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/RestoreTableFromBackupCommand";
    import { RestoreTableToPointInTimeCommandInput, RestoreTableToPointInTimeCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/RestoreTableToPointInTimeCommand";
    import { ScanCommandInput, ScanCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/ScanCommand";
    import { TagResourceCommandInput, TagResourceCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/TagResourceCommand";
    import { TransactGetItemsCommandInput, TransactGetItemsCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/TransactGetItemsCommand";
    import { TransactWriteItemsCommandInput, TransactWriteItemsCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/TransactWriteItemsCommand";
    import { UntagResourceCommandInput, UntagResourceCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/UntagResourceCommand";
    import { UpdateContinuousBackupsCommandInput, UpdateContinuousBackupsCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/UpdateContinuousBackupsCommand";
    import { UpdateContributorInsightsCommandInput, UpdateContributorInsightsCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/UpdateContributorInsightsCommand";
    import { UpdateGlobalTableCommandInput, UpdateGlobalTableCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/UpdateGlobalTableCommand";
    import { UpdateGlobalTableSettingsCommandInput, UpdateGlobalTableSettingsCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/UpdateGlobalTableSettingsCommand";
    import { UpdateItemCommandInput, UpdateItemCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/UpdateItemCommand";
    import { UpdateTableCommandInput, UpdateTableCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/UpdateTableCommand";
    import { UpdateTableReplicaAutoScalingCommandInput, UpdateTableReplicaAutoScalingCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/UpdateTableReplicaAutoScalingCommand";
    import { UpdateTimeToLiveCommandInput, UpdateTimeToLiveCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/UpdateTimeToLiveCommand";
    import { DynamoDBClient } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    /**
        * <fullname>Amazon DynamoDB</fullname>
        *
        *         <p>Amazon DynamoDB is a fully managed NoSQL database service that provides fast
        *             and predictable performance with seamless scalability. DynamoDB lets you
        *             offload the administrative burdens of operating and scaling a distributed database, so
        *             that you don't have to worry about hardware provisioning, setup and configuration,
        *             replication, software patching, or cluster scaling.</p>
        *
        *         <p>With DynamoDB, you can create database tables that can store and retrieve
        *             any amount of data, and serve any level of request traffic. You can scale up or scale
        *             down your tables' throughput capacity without downtime or performance degradation, and
        *             use the Amazon Web Services Management Console to monitor resource utilization and performance
        *             metrics.</p>
        *
        *         <p>DynamoDB automatically spreads the data and traffic for your tables over
        *             a sufficient number of servers to handle your throughput and storage requirements, while
        *             maintaining consistent and fast performance. All of your data is stored on solid state
        *             disks (SSDs) and automatically replicated across multiple Availability Zones in an
        *                 Amazon Web Services Region, providing built-in high availability and data
        *             durability.</p>
        */
    export class DynamoDB extends DynamoDBClient {
            /**
                * <p>This operation allows you to perform batch reads or writes on data stored in DynamoDB,
                *             using PartiQL. Each read statement in a <code>BatchExecuteStatement</code> must specify an equality
                *             condition on all key attributes. This enforces that each <code>SELECT</code> statement in a
                *             batch returns at most a single item.</p>
                *         <note>
                *             <p>The entire batch must consist of either read statements or write statements, you
                *                 cannot mix both in one batch.</p>
                *         </note>
                *         <important>
                *             <p>A HTTP 200 response does not mean that all statements in the BatchExecuteStatement
                *                 succeeded. Error details for individual statements can be found under the <a href="https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_BatchStatementResponse.html#DDB-Type-BatchStatementResponse-Error">Error</a> field of the <code>BatchStatementResponse</code> for each
                *                 statement.</p>
                *         </important>
                */
            batchExecuteStatement(args: BatchExecuteStatementCommandInput, options?: __HttpHandlerOptions): Promise<BatchExecuteStatementCommandOutput>;
            batchExecuteStatement(args: BatchExecuteStatementCommandInput, cb: (err: any, data?: BatchExecuteStatementCommandOutput) => void): void;
            batchExecuteStatement(args: BatchExecuteStatementCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: BatchExecuteStatementCommandOutput) => void): void;
            /**
                * <p>The <code>BatchGetItem</code> operation returns the attributes of one or more items
                *             from one or more tables. You identify requested items by primary key.</p>
                *         <p>A single operation can retrieve up to 16 MB of data, which can contain as many as 100
                *             items. <code>BatchGetItem</code> returns a partial result if the response size limit is
                *             exceeded, the table's provisioned throughput is exceeded, or an internal processing
                *             failure occurs. If a partial result is returned, the operation returns a value for
                *                 <code>UnprocessedKeys</code>. You can use this value to retry the operation starting
                *             with the next item to get.</p>
                *         <important>
                *             <p>If you request more than 100 items, <code>BatchGetItem</code> returns a
                *                     <code>ValidationException</code> with the message "Too many items requested for
                *                 the BatchGetItem call."</p>
                *         </important>
                *         <p>For example, if you ask to retrieve 100 items, but each individual item is 300 KB in
                *             size, the system returns 52 items (so as not to exceed the 16 MB limit). It also returns
                *             an appropriate <code>UnprocessedKeys</code> value so you can get the next page of
                *             results. If desired, your application can include its own logic to assemble the pages of
                *             results into one dataset.</p>
                *         <p>If <i>none</i> of the items can be processed due to insufficient
                *             provisioned throughput on all of the tables in the request, then
                *                 <code>BatchGetItem</code> returns a
                *                 <code>ProvisionedThroughputExceededException</code>. If <i>at least
                *                 one</i> of the items is successfully processed, then
                *                 <code>BatchGetItem</code> completes successfully, while returning the keys of the
                *             unread items in <code>UnprocessedKeys</code>.</p>
                *         <important>
                *             <p>If DynamoDB returns any unprocessed items, you should retry the batch operation on
                *                 those items. However, <i>we strongly recommend that you use an exponential
                *                     backoff algorithm</i>. If you retry the batch operation immediately, the
                *                 underlying read or write requests can still fail due to throttling on the individual
                *                 tables. If you delay the batch operation using exponential backoff, the individual
                *                 requests in the batch are much more likely to succeed.</p>
                *             <p>For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ErrorHandling.html#BatchOperations">Batch Operations and Error Handling</a> in the <i>Amazon DynamoDB
                *                     Developer Guide</i>.</p>
                *         </important>
                *         <p>By default, <code>BatchGetItem</code> performs eventually consistent reads on every
                *             table in the request. If you want strongly consistent reads instead, you can set
                *                 <code>ConsistentRead</code> to <code>true</code> for any or all tables.</p>
                *         <p>In order to minimize response latency, <code>BatchGetItem</code> retrieves items in
                *             parallel.</p>
                *         <p>When designing your application, keep in mind that DynamoDB does not return items in
                *             any particular order. To help parse the response by item, include the primary key values
                *             for the items in your request in the <code>ProjectionExpression</code> parameter.</p>
                *         <p>If a requested item does not exist, it is not returned in the result. Requests for
                *             nonexistent items consume the minimum read capacity units according to the type of read.
                *             For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html#CapacityUnitCalculations">Working with Tables</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>.</p>
                */
            batchGetItem(args: BatchGetItemCommandInput, options?: __HttpHandlerOptions): Promise<BatchGetItemCommandOutput>;
            batchGetItem(args: BatchGetItemCommandInput, cb: (err: any, data?: BatchGetItemCommandOutput) => void): void;
            batchGetItem(args: BatchGetItemCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: BatchGetItemCommandOutput) => void): void;
            /**
                * <p>The <code>BatchWriteItem</code> operation puts or deletes multiple items in one or
                *             more tables. A single call to <code>BatchWriteItem</code> can transmit up to 16MB of
                *             data over the network, consisting of up to 25 item put or delete operations. While
                *             individual items can be up to 400 KB once stored, it's important to note that an item's
                *             representation might be greater than 400KB while being sent in DynamoDB's JSON format
                *             for the API call. For more details on this distinction, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.NamingRulesDataTypes.html">Naming Rules and Data Types</a>.</p>
                *         <note>
                *             <p>
                *                 <code>BatchWriteItem</code> cannot update items. To update items, use the
                *                     <code>UpdateItem</code> action.</p>
                *         </note>
                *         <p>The individual <code>PutItem</code> and <code>DeleteItem</code> operations specified
                *             in <code>BatchWriteItem</code> are atomic; however <code>BatchWriteItem</code> as a
                *             whole is not. If any requested operations fail because the table's provisioned
                *             throughput is exceeded or an internal processing failure occurs, the failed operations
                *             are returned in the <code>UnprocessedItems</code> response parameter. You can
                *             investigate and optionally resend the requests. Typically, you would call
                *                 <code>BatchWriteItem</code> in a loop. Each iteration would check for unprocessed
                *             items and submit a new <code>BatchWriteItem</code> request with those unprocessed items
                *             until all items have been processed.</p>
                *         <p>If <i>none</i> of the items can be processed due to insufficient
                *             provisioned throughput on all of the tables in the request, then
                *                 <code>BatchWriteItem</code> returns a
                *                 <code>ProvisionedThroughputExceededException</code>.</p>
                *         <important>
                *             <p>If DynamoDB returns any unprocessed items, you should retry the batch operation on
                *                 those items. However, <i>we strongly recommend that you use an exponential
                *                     backoff algorithm</i>. If you retry the batch operation immediately, the
                *                 underlying read or write requests can still fail due to throttling on the individual
                *                 tables. If you delay the batch operation using exponential backoff, the individual
                *                 requests in the batch are much more likely to succeed.</p>
                *             <p>For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ErrorHandling.html#Programming.Errors.BatchOperations">Batch Operations and Error Handling</a> in the <i>Amazon DynamoDB
                *                     Developer Guide</i>.</p>
                *         </important>
                *
                *         <p>With <code>BatchWriteItem</code>, you can efficiently write or delete large amounts of
                *             data, such as from Amazon EMR, or copy data from another database into DynamoDB. In
                *             order to improve performance with these large-scale operations,
                *                 <code>BatchWriteItem</code> does not behave in the same way as individual
                *                 <code>PutItem</code> and <code>DeleteItem</code> calls would. For example, you
                *             cannot specify conditions on individual put and delete requests, and
                *                 <code>BatchWriteItem</code> does not return deleted items in the response.</p>
                *         <p>If you use a programming language that supports concurrency, you can use threads to
                *             write items in parallel. Your application must include the necessary logic to manage the
                *             threads. With languages that don't support threading, you must update or delete the
                *             specified items one at a time. In both situations, <code>BatchWriteItem</code> performs
                *             the specified put and delete operations in parallel, giving you the power of the thread
                *             pool approach without having to introduce complexity into your application.</p>
                *         <p>Parallel processing reduces latency, but each specified put and delete request
                *             consumes the same number of write capacity units whether it is processed in parallel or
                *             not. Delete operations on nonexistent items consume one write capacity unit.</p>
                *         <p>If one or more of the following is true, DynamoDB rejects the entire batch write
                *             operation:</p>
                *         <ul>
                *             <li>
                *                 <p>One or more tables specified in the <code>BatchWriteItem</code> request does
                *                     not exist.</p>
                *             </li>
                *             <li>
                *                 <p>Primary key attributes specified on an item in the request do not match those
                *                     in the corresponding table's primary key schema.</p>
                *             </li>
                *             <li>
                *                 <p>You try to perform multiple operations on the same item in the same
                *                         <code>BatchWriteItem</code> request. For example, you cannot put and delete
                *                     the same item in the same <code>BatchWriteItem</code> request. </p>
                *             </li>
                *             <li>
                *                 <p> Your request contains at least two items with identical hash and range keys
                *                     (which essentially is two put operations). </p>
                *             </li>
                *             <li>
                *                 <p>There are more than 25 requests in the batch.</p>
                *             </li>
                *             <li>
                *                 <p>Any individual item in a batch exceeds 400 KB.</p>
                *             </li>
                *             <li>
                *                 <p>The total request size exceeds 16 MB.</p>
                *             </li>
                *          </ul>
                */
            batchWriteItem(args: BatchWriteItemCommandInput, options?: __HttpHandlerOptions): Promise<BatchWriteItemCommandOutput>;
            batchWriteItem(args: BatchWriteItemCommandInput, cb: (err: any, data?: BatchWriteItemCommandOutput) => void): void;
            batchWriteItem(args: BatchWriteItemCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: BatchWriteItemCommandOutput) => void): void;
            /**
                * <p>Creates a backup for an existing table.</p>
                *         <p> Each time you create an on-demand backup, the entire table data is backed up. There
                *             is no limit to the number of on-demand backups that can be taken. </p>
                *         <p> When you create an on-demand backup, a time marker of the request is cataloged, and
                *             the backup is created asynchronously, by applying all changes until the time of the
                *             request to the last full table snapshot. Backup requests are processed instantaneously
                *             and become available for restore within minutes. </p>
                *         <p>You can call <code>CreateBackup</code> at a maximum rate of 50 times per
                *             second.</p>
                *         <p>All backups in DynamoDB work without consuming any provisioned throughput on the
                *             table.</p>
                *         <p> If you submit a backup request on 2018-12-14 at 14:25:00, the backup is guaranteed to
                *             contain all data committed to the table up to 14:24:00, and data committed after
                *             14:26:00 will not be. The backup might contain data modifications made between 14:24:00
                *             and 14:26:00. On-demand backup does not support causal consistency. </p>
                *         <p> Along with data, the following are also included on the backups: </p>
                *         <ul>
                *             <li>
                *                 <p>Global secondary indexes (GSIs)</p>
                *             </li>
                *             <li>
                *                 <p>Local secondary indexes (LSIs)</p>
                *             </li>
                *             <li>
                *                 <p>Streams</p>
                *             </li>
                *             <li>
                *                 <p>Provisioned read and write capacity</p>
                *             </li>
                *          </ul>
                */
            createBackup(args: CreateBackupCommandInput, options?: __HttpHandlerOptions): Promise<CreateBackupCommandOutput>;
            createBackup(args: CreateBackupCommandInput, cb: (err: any, data?: CreateBackupCommandOutput) => void): void;
            createBackup(args: CreateBackupCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateBackupCommandOutput) => void): void;
            /**
                * <p>Creates a global table from an existing table. A global table creates a replication
                *             relationship between two or more DynamoDB tables with the same table name in the
                *             provided Regions. </p>
                *         <note>
                *             <p>This operation only applies to <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.V1.html">Version
                *                     2017.11.29</a> of global tables.</p>
                *         </note>
                *
                *         <p>If you want to add a new replica table to a global table, each of the following
                *             conditions must be true:</p>
                *         <ul>
                *             <li>
                *                 <p>The table must have the same primary key as all of the other replicas.</p>
                *             </li>
                *             <li>
                *                 <p>The table must have the same name as all of the other replicas.</p>
                *             </li>
                *             <li>
                *                 <p>The table must have DynamoDB Streams enabled, with the stream containing both
                *                     the new and the old images of the item.</p>
                *             </li>
                *             <li>
                *                 <p>None of the replica tables in the global table can contain any data.</p>
                *             </li>
                *          </ul>
                *         <p> If global secondary indexes are specified, then the following conditions must also be
                *             met: </p>
                *         <ul>
                *             <li>
                *                 <p> The global secondary indexes must have the same name. </p>
                *             </li>
                *             <li>
                *                 <p> The global secondary indexes must have the same hash key and sort key (if
                *                     present). </p>
                *             </li>
                *          </ul>
                *         <p> If local secondary indexes are specified, then the following conditions must also be
                *             met: </p>
                *         <ul>
                *             <li>
                *                 <p> The local secondary indexes must have the same name. </p>
                *             </li>
                *             <li>
                *                 <p> The local secondary indexes must have the same hash key and sort key (if
                *                     present). </p>
                *             </li>
                *          </ul>
                *
                *         <important>
                *             <p> Write capacity settings should be set consistently across your replica tables and
                *                 secondary indexes. DynamoDB strongly recommends enabling auto scaling to manage the
                *                 write capacity settings for all of your global tables replicas and indexes. </p>
                *             <p> If you prefer to manage write capacity settings manually, you should provision
                *                 equal replicated write capacity units to your replica tables. You should also
                *                 provision equal replicated write capacity units to matching secondary indexes across
                *                 your global table. </p>
                *         </important>
                */
            createGlobalTable(args: CreateGlobalTableCommandInput, options?: __HttpHandlerOptions): Promise<CreateGlobalTableCommandOutput>;
            createGlobalTable(args: CreateGlobalTableCommandInput, cb: (err: any, data?: CreateGlobalTableCommandOutput) => void): void;
            createGlobalTable(args: CreateGlobalTableCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateGlobalTableCommandOutput) => void): void;
            /**
                * <p>The <code>CreateTable</code> operation adds a new table to your account. In an Amazon Web Services account, table names must be unique within each Region. That is, you can
                *             have two tables with same name if you create the tables in different Regions.</p>
                *         <p>
                *             <code>CreateTable</code> is an asynchronous operation. Upon receiving a
                *                 <code>CreateTable</code> request, DynamoDB immediately returns a response with a
                *                 <code>TableStatus</code> of <code>CREATING</code>. After the table is created,
                *             DynamoDB sets the <code>TableStatus</code> to <code>ACTIVE</code>. You can perform read
                *             and write operations only on an <code>ACTIVE</code> table. </p>
                *         <p>You can optionally define secondary indexes on the new table, as part of the
                *                 <code>CreateTable</code> operation. If you want to create multiple tables with
                *             secondary indexes on them, you must create the tables sequentially. Only one table with
                *             secondary indexes can be in the <code>CREATING</code> state at any given time.</p>
                *         <p>You can use the <code>DescribeTable</code> action to check the table status.</p>
                */
            createTable(args: CreateTableCommandInput, options?: __HttpHandlerOptions): Promise<CreateTableCommandOutput>;
            createTable(args: CreateTableCommandInput, cb: (err: any, data?: CreateTableCommandOutput) => void): void;
            createTable(args: CreateTableCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateTableCommandOutput) => void): void;
            /**
                * <p>Deletes an existing backup of a table.</p>
                *         <p>You can call <code>DeleteBackup</code> at a maximum rate of 10 times per
                *             second.</p>
                */
            deleteBackup(args: DeleteBackupCommandInput, options?: __HttpHandlerOptions): Promise<DeleteBackupCommandOutput>;
            deleteBackup(args: DeleteBackupCommandInput, cb: (err: any, data?: DeleteBackupCommandOutput) => void): void;
            deleteBackup(args: DeleteBackupCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteBackupCommandOutput) => void): void;
            /**
                * <p>Deletes a single item in a table by primary key. You can perform a conditional delete
                *             operation that deletes the item if it exists, or if it has an expected attribute
                *             value.</p>
                *         <p>In addition to deleting an item, you can also return the item's attribute values in
                *             the same operation, using the <code>ReturnValues</code> parameter.</p>
                *         <p>Unless you specify conditions, the <code>DeleteItem</code> is an idempotent operation;
                *             running it multiple times on the same item or attribute does <i>not</i>
                *             result in an error response.</p>
                *         <p>Conditional deletes are useful for deleting items only if specific conditions are met.
                *             If those conditions are met, DynamoDB performs the delete. Otherwise, the item is not
                *             deleted.</p>
                */
            deleteItem(args: DeleteItemCommandInput, options?: __HttpHandlerOptions): Promise<DeleteItemCommandOutput>;
            deleteItem(args: DeleteItemCommandInput, cb: (err: any, data?: DeleteItemCommandOutput) => void): void;
            deleteItem(args: DeleteItemCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteItemCommandOutput) => void): void;
            /**
                * <p>The <code>DeleteTable</code> operation deletes a table and all of its items. After a
                *                 <code>DeleteTable</code> request, the specified table is in the
                *                 <code>DELETING</code> state until DynamoDB completes the deletion. If the table is
                *             in the <code>ACTIVE</code> state, you can delete it. If a table is in
                *                 <code>CREATING</code> or <code>UPDATING</code> states, then DynamoDB returns a
                *                 <code>ResourceInUseException</code>. If the specified table does not exist, DynamoDB
                *             returns a <code>ResourceNotFoundException</code>. If table is already in the
                *                 <code>DELETING</code> state, no error is returned. </p>
                *         <note>
                *             <p>DynamoDB might continue to accept data read and write operations, such as
                *                     <code>GetItem</code> and <code>PutItem</code>, on a table in the
                *                     <code>DELETING</code> state until the table deletion is complete.</p>
                *         </note>
                *         <p>When you delete a table, any indexes on that table are also deleted.</p>
                *         <p>If you have DynamoDB Streams enabled on the table, then the corresponding stream on
                *             that table goes into the <code>DISABLED</code> state, and the stream is automatically
                *             deleted after 24 hours.</p>
                *
                *         <p>Use the <code>DescribeTable</code> action to check the status of the table. </p>
                */
            deleteTable(args: DeleteTableCommandInput, options?: __HttpHandlerOptions): Promise<DeleteTableCommandOutput>;
            deleteTable(args: DeleteTableCommandInput, cb: (err: any, data?: DeleteTableCommandOutput) => void): void;
            deleteTable(args: DeleteTableCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteTableCommandOutput) => void): void;
            /**
                * <p>Describes an existing backup of a table.</p>
                *         <p>You can call <code>DescribeBackup</code> at a maximum rate of 10 times per
                *             second.</p>
                */
            describeBackup(args: DescribeBackupCommandInput, options?: __HttpHandlerOptions): Promise<DescribeBackupCommandOutput>;
            describeBackup(args: DescribeBackupCommandInput, cb: (err: any, data?: DescribeBackupCommandOutput) => void): void;
            describeBackup(args: DescribeBackupCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeBackupCommandOutput) => void): void;
            /**
                * <p>Checks the status of continuous backups and point in time recovery on the specified
                *             table. Continuous backups are <code>ENABLED</code> on all tables at table creation. If
                *             point in time recovery is enabled, <code>PointInTimeRecoveryStatus</code> will be set to
                *             ENABLED.</p>
                *         <p> After continuous backups and point in time recovery are enabled, you can restore to
                *             any point in time within <code>EarliestRestorableDateTime</code> and
                *                 <code>LatestRestorableDateTime</code>. </p>
                *         <p>
                *             <code>LatestRestorableDateTime</code> is typically 5 minutes before the current time.
                *             You can restore your table to any point in time during the last 35 days. </p>
                *         <p>You can call <code>DescribeContinuousBackups</code> at a maximum rate of 10 times per
                *             second.</p>
                */
            describeContinuousBackups(args: DescribeContinuousBackupsCommandInput, options?: __HttpHandlerOptions): Promise<DescribeContinuousBackupsCommandOutput>;
            describeContinuousBackups(args: DescribeContinuousBackupsCommandInput, cb: (err: any, data?: DescribeContinuousBackupsCommandOutput) => void): void;
            describeContinuousBackups(args: DescribeContinuousBackupsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeContinuousBackupsCommandOutput) => void): void;
            /**
                * <p>Returns information about contributor insights, for a given table or global secondary
                *             index.</p>
                */
            describeContributorInsights(args: DescribeContributorInsightsCommandInput, options?: __HttpHandlerOptions): Promise<DescribeContributorInsightsCommandOutput>;
            describeContributorInsights(args: DescribeContributorInsightsCommandInput, cb: (err: any, data?: DescribeContributorInsightsCommandOutput) => void): void;
            describeContributorInsights(args: DescribeContributorInsightsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeContributorInsightsCommandOutput) => void): void;
            /**
                * <p>Returns the regional endpoint information.</p>
                */
            describeEndpoints(args: DescribeEndpointsCommandInput, options?: __HttpHandlerOptions): Promise<DescribeEndpointsCommandOutput>;
            describeEndpoints(args: DescribeEndpointsCommandInput, cb: (err: any, data?: DescribeEndpointsCommandOutput) => void): void;
            describeEndpoints(args: DescribeEndpointsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeEndpointsCommandOutput) => void): void;
            /**
                * <p>Describes an existing table export.</p>
                */
            describeExport(args: DescribeExportCommandInput, options?: __HttpHandlerOptions): Promise<DescribeExportCommandOutput>;
            describeExport(args: DescribeExportCommandInput, cb: (err: any, data?: DescribeExportCommandOutput) => void): void;
            describeExport(args: DescribeExportCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeExportCommandOutput) => void): void;
            /**
                * <p>Returns information about the specified global table.</p>
                *         <note>
                *             <p>This operation only applies to <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.V1.html">Version
                *                     2017.11.29</a> of global tables. If you are using global tables <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.V2.html">Version
                *                     2019.11.21</a> you can use <a href="https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_DescribeTable.html">DescribeTable</a> instead.</p>
                *         </note>
                */
            describeGlobalTable(args: DescribeGlobalTableCommandInput, options?: __HttpHandlerOptions): Promise<DescribeGlobalTableCommandOutput>;
            describeGlobalTable(args: DescribeGlobalTableCommandInput, cb: (err: any, data?: DescribeGlobalTableCommandOutput) => void): void;
            describeGlobalTable(args: DescribeGlobalTableCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeGlobalTableCommandOutput) => void): void;
            /**
                * <p>Describes Region-specific settings for a global table.</p>
                *         <note>
                *             <p>This operation only applies to <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.V1.html">Version
                *                     2017.11.29</a> of global tables.</p>
                *         </note>
                */
            describeGlobalTableSettings(args: DescribeGlobalTableSettingsCommandInput, options?: __HttpHandlerOptions): Promise<DescribeGlobalTableSettingsCommandOutput>;
            describeGlobalTableSettings(args: DescribeGlobalTableSettingsCommandInput, cb: (err: any, data?: DescribeGlobalTableSettingsCommandOutput) => void): void;
            describeGlobalTableSettings(args: DescribeGlobalTableSettingsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeGlobalTableSettingsCommandOutput) => void): void;
            /**
                * <p>Returns information about the status of Kinesis streaming.</p>
                */
            describeKinesisStreamingDestination(args: DescribeKinesisStreamingDestinationCommandInput, options?: __HttpHandlerOptions): Promise<DescribeKinesisStreamingDestinationCommandOutput>;
            describeKinesisStreamingDestination(args: DescribeKinesisStreamingDestinationCommandInput, cb: (err: any, data?: DescribeKinesisStreamingDestinationCommandOutput) => void): void;
            describeKinesisStreamingDestination(args: DescribeKinesisStreamingDestinationCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeKinesisStreamingDestinationCommandOutput) => void): void;
            /**
                * <p>Returns the current provisioned-capacity quotas for your Amazon Web Services account in
                *             a Region, both for the Region as a whole and for any one DynamoDB table that you create
                *             there.</p>
                *         <p>When you establish an Amazon Web Services account, the account has initial quotas on
                *             the maximum read capacity units and write capacity units that you can provision across
                *             all of your DynamoDB tables in a given Region. Also, there are per-table
                *             quotas that apply when you create a table there. For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html">Service,
                *                 Account, and Table Quotas</a> page in the <i>Amazon DynamoDB
                *                 Developer Guide</i>.</p>
                *
                *         <p>Although you can increase these quotas by filing a case at <a href="https://console.aws.amazon.com/support/home#/">Amazon Web Services Support Center</a>, obtaining the
                *             increase is not instantaneous. The <code>DescribeLimits</code> action lets you write
                *             code to compare the capacity you are currently using to those quotas imposed by your
                *             account so that you have enough time to apply for an increase before you hit a
                *             quota.</p>
                *
                *         <p>For example, you could use one of the Amazon Web Services SDKs to do the
                *             following:</p>
                *
                *         <ol>
                *             <li>
                *                 <p>Call <code>DescribeLimits</code> for a particular Region to obtain your
                *                     current account quotas on provisioned capacity there.</p>
                *             </li>
                *             <li>
                *                 <p>Create a variable to hold the aggregate read capacity units provisioned for
                *                     all your tables in that Region, and one to hold the aggregate write capacity
                *                     units. Zero them both.</p>
                *             </li>
                *             <li>
                *                 <p>Call <code>ListTables</code> to obtain a list of all your DynamoDB
                *                     tables.</p>
                *             </li>
                *             <li>
                *                 <p>For each table name listed by <code>ListTables</code>, do the
                *                     following:</p>
                *                 <ul>
                *                   <li>
                *                         <p>Call <code>DescribeTable</code> with the table name.</p>
                *                     </li>
                *                   <li>
                *                         <p>Use the data returned by <code>DescribeTable</code> to add the read
                *                             capacity units and write capacity units provisioned for the table itself
                *                             to your variables.</p>
                *                     </li>
                *                   <li>
                *                         <p>If the table has one or more global secondary indexes (GSIs), loop
                *                             over these GSIs and add their provisioned capacity values to your
                *                             variables as well.</p>
                *                     </li>
                *                </ul>
                *             </li>
                *             <li>
                *                 <p>Report the account quotas for that Region returned by
                *                         <code>DescribeLimits</code>, along with the total current provisioned
                *                     capacity levels you have calculated.</p>
                *             </li>
                *          </ol>
                *
                *         <p>This will let you see whether you are getting close to your account-level
                *             quotas.</p>
                *         <p>The per-table quotas apply only when you are creating a new table. They restrict the
                *             sum of the provisioned capacity of the new table itself and all its global secondary
                *             indexes.</p>
                *         <p>For existing tables and their GSIs, DynamoDB doesn't let you increase provisioned
                *             capacity extremely rapidly, but the only quota that applies is that the aggregate
                *             provisioned capacity over all your tables and GSIs cannot exceed either of the
                *             per-account quotas.</p>
                *         <note>
                *             <p>
                *                 <code>DescribeLimits</code> should only be called periodically. You can expect
                *                 throttling errors if you call it more than once in a minute.</p>
                *         </note>
                *         <p>The <code>DescribeLimits</code> Request element has no content.</p>
                */
            describeLimits(args: DescribeLimitsCommandInput, options?: __HttpHandlerOptions): Promise<DescribeLimitsCommandOutput>;
            describeLimits(args: DescribeLimitsCommandInput, cb: (err: any, data?: DescribeLimitsCommandOutput) => void): void;
            describeLimits(args: DescribeLimitsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeLimitsCommandOutput) => void): void;
            /**
                * <p>Returns information about the table, including the current status of the table, when
                *             it was created, the primary key schema, and any indexes on the table.</p>
                *         <note>
                *             <p>If you issue a <code>DescribeTable</code> request immediately after a
                *                     <code>CreateTable</code> request, DynamoDB might return a
                *                     <code>ResourceNotFoundException</code>. This is because
                *                     <code>DescribeTable</code> uses an eventually consistent query, and the metadata
                *                 for your table might not be available at that moment. Wait for a few seconds, and
                *                 then try the <code>DescribeTable</code> request again.</p>
                *         </note>
                */
            describeTable(args: DescribeTableCommandInput, options?: __HttpHandlerOptions): Promise<DescribeTableCommandOutput>;
            describeTable(args: DescribeTableCommandInput, cb: (err: any, data?: DescribeTableCommandOutput) => void): void;
            describeTable(args: DescribeTableCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeTableCommandOutput) => void): void;
            /**
                * <p>Describes auto scaling settings across replicas of the global table at once.</p>
                *         <note>
                *             <p>This operation only applies to <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.V2.html">Version
                *                     2019.11.21</a> of global tables.</p>
                *         </note>
                */
            describeTableReplicaAutoScaling(args: DescribeTableReplicaAutoScalingCommandInput, options?: __HttpHandlerOptions): Promise<DescribeTableReplicaAutoScalingCommandOutput>;
            describeTableReplicaAutoScaling(args: DescribeTableReplicaAutoScalingCommandInput, cb: (err: any, data?: DescribeTableReplicaAutoScalingCommandOutput) => void): void;
            describeTableReplicaAutoScaling(args: DescribeTableReplicaAutoScalingCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeTableReplicaAutoScalingCommandOutput) => void): void;
            /**
                * <p>Gives a description of the Time to Live (TTL) status on the specified table. </p>
                */
            describeTimeToLive(args: DescribeTimeToLiveCommandInput, options?: __HttpHandlerOptions): Promise<DescribeTimeToLiveCommandOutput>;
            describeTimeToLive(args: DescribeTimeToLiveCommandInput, cb: (err: any, data?: DescribeTimeToLiveCommandOutput) => void): void;
            describeTimeToLive(args: DescribeTimeToLiveCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DescribeTimeToLiveCommandOutput) => void): void;
            /**
                * <p>Stops replication from the DynamoDB table to the Kinesis data stream. This is done
                *             without deleting either of the resources.</p>
                */
            disableKinesisStreamingDestination(args: DisableKinesisStreamingDestinationCommandInput, options?: __HttpHandlerOptions): Promise<DisableKinesisStreamingDestinationCommandOutput>;
            disableKinesisStreamingDestination(args: DisableKinesisStreamingDestinationCommandInput, cb: (err: any, data?: DisableKinesisStreamingDestinationCommandOutput) => void): void;
            disableKinesisStreamingDestination(args: DisableKinesisStreamingDestinationCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DisableKinesisStreamingDestinationCommandOutput) => void): void;
            /**
                * <p>Starts table data replication to the specified Kinesis data stream at a timestamp
                *             chosen during the enable workflow. If this operation doesn't return results immediately,
                *             use DescribeKinesisStreamingDestination to check if streaming to the Kinesis data stream
                *             is ACTIVE.</p>
                */
            enableKinesisStreamingDestination(args: EnableKinesisStreamingDestinationCommandInput, options?: __HttpHandlerOptions): Promise<EnableKinesisStreamingDestinationCommandOutput>;
            enableKinesisStreamingDestination(args: EnableKinesisStreamingDestinationCommandInput, cb: (err: any, data?: EnableKinesisStreamingDestinationCommandOutput) => void): void;
            enableKinesisStreamingDestination(args: EnableKinesisStreamingDestinationCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: EnableKinesisStreamingDestinationCommandOutput) => void): void;
            /**
                * <p>This operation allows you to perform reads and singleton writes on data stored in
                *             DynamoDB, using PartiQL.</p>
                *         <p>For PartiQL reads (<code>SELECT</code> statement), if the total number of processed
                *             items exceeds the maximum dataset size limit of 1 MB, the read stops and results are
                *             returned to the user as a <code>LastEvaluatedKey</code> value to continue the read in a
                *             subsequent operation. If the filter criteria in <code>WHERE</code> clause does not match
                *             any data, the read will return an empty result set.</p>
                *         <p>A single <code>SELECT</code> statement response can return up to the maximum number of
                *             items (if using the Limit parameter) or a maximum of 1 MB of data (and then apply any
                *             filtering to the results using <code>WHERE</code> clause). If
                *                 <code>LastEvaluatedKey</code> is present in the response, you need to paginate the
                *             result set.</p>
                */
            executeStatement(args: ExecuteStatementCommandInput, options?: __HttpHandlerOptions): Promise<ExecuteStatementCommandOutput>;
            executeStatement(args: ExecuteStatementCommandInput, cb: (err: any, data?: ExecuteStatementCommandOutput) => void): void;
            executeStatement(args: ExecuteStatementCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ExecuteStatementCommandOutput) => void): void;
            /**
                * <p>This operation allows you to perform transactional reads or writes on data stored in
                *             DynamoDB, using PartiQL.</p>
                *         <note>
                *             <p>The entire transaction must consist of either read statements or write statements,
                *                 you cannot mix both in one transaction. The EXISTS function is an exception and can
                *                 be used to check the condition of specific attributes of the item in a similar
                *                 manner to <code>ConditionCheck</code> in the <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/transaction-apis.html#transaction-apis-txwriteitems">TransactWriteItems</a> API.</p>
                *         </note>
                */
            executeTransaction(args: ExecuteTransactionCommandInput, options?: __HttpHandlerOptions): Promise<ExecuteTransactionCommandOutput>;
            executeTransaction(args: ExecuteTransactionCommandInput, cb: (err: any, data?: ExecuteTransactionCommandOutput) => void): void;
            executeTransaction(args: ExecuteTransactionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ExecuteTransactionCommandOutput) => void): void;
            /**
                * <p>Exports table data to an S3 bucket. The table must have point in time recovery
                *             enabled, and you can export data from any time within the point in time recovery
                *             window.</p>
                */
            exportTableToPointInTime(args: ExportTableToPointInTimeCommandInput, options?: __HttpHandlerOptions): Promise<ExportTableToPointInTimeCommandOutput>;
            exportTableToPointInTime(args: ExportTableToPointInTimeCommandInput, cb: (err: any, data?: ExportTableToPointInTimeCommandOutput) => void): void;
            exportTableToPointInTime(args: ExportTableToPointInTimeCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ExportTableToPointInTimeCommandOutput) => void): void;
            /**
                * <p>The <code>GetItem</code> operation returns a set of attributes for the item with the
                *             given primary key. If there is no matching item, <code>GetItem</code> does not return
                *             any data and there will be no <code>Item</code> element in the response.</p>
                *         <p>
                *             <code>GetItem</code> provides an eventually consistent read by default. If your
                *             application requires a strongly consistent read, set <code>ConsistentRead</code> to
                *                 <code>true</code>. Although a strongly consistent read might take more time than an
                *             eventually consistent read, it always returns the last updated value.</p>
                */
            getItem(args: GetItemCommandInput, options?: __HttpHandlerOptions): Promise<GetItemCommandOutput>;
            getItem(args: GetItemCommandInput, cb: (err: any, data?: GetItemCommandOutput) => void): void;
            getItem(args: GetItemCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetItemCommandOutput) => void): void;
            /**
                * <p>List backups associated with an Amazon Web Services account. To list backups for a
                *             given table, specify <code>TableName</code>. <code>ListBackups</code> returns a
                *             paginated list of results with at most 1 MB worth of items in a page. You can also
                *             specify a maximum number of entries to be returned in a page.</p>
                *         <p>In the request, start time is inclusive, but end time is exclusive. Note that these
                *             boundaries are for the time at which the original backup was requested.</p>
                *         <p>You can call <code>ListBackups</code> a maximum of five times per second.</p>
                */
            listBackups(args: ListBackupsCommandInput, options?: __HttpHandlerOptions): Promise<ListBackupsCommandOutput>;
            listBackups(args: ListBackupsCommandInput, cb: (err: any, data?: ListBackupsCommandOutput) => void): void;
            listBackups(args: ListBackupsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListBackupsCommandOutput) => void): void;
            /**
                * <p>Returns a list of ContributorInsightsSummary for a table and all its global secondary
                *             indexes.</p>
                */
            listContributorInsights(args: ListContributorInsightsCommandInput, options?: __HttpHandlerOptions): Promise<ListContributorInsightsCommandOutput>;
            listContributorInsights(args: ListContributorInsightsCommandInput, cb: (err: any, data?: ListContributorInsightsCommandOutput) => void): void;
            listContributorInsights(args: ListContributorInsightsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListContributorInsightsCommandOutput) => void): void;
            /**
                * <p>Lists completed exports within the past 90 days.</p>
                */
            listExports(args: ListExportsCommandInput, options?: __HttpHandlerOptions): Promise<ListExportsCommandOutput>;
            listExports(args: ListExportsCommandInput, cb: (err: any, data?: ListExportsCommandOutput) => void): void;
            listExports(args: ListExportsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListExportsCommandOutput) => void): void;
            /**
                * <p>Lists all global tables that have a replica in the specified Region.</p>
                *         <note>
                *             <p>This operation only applies to <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.V1.html">Version
                *                     2017.11.29</a> of global tables.</p>
                *         </note>
                */
            listGlobalTables(args: ListGlobalTablesCommandInput, options?: __HttpHandlerOptions): Promise<ListGlobalTablesCommandOutput>;
            listGlobalTables(args: ListGlobalTablesCommandInput, cb: (err: any, data?: ListGlobalTablesCommandOutput) => void): void;
            listGlobalTables(args: ListGlobalTablesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListGlobalTablesCommandOutput) => void): void;
            /**
                * <p>Returns an array of table names associated with the current account and endpoint. The
                *             output from <code>ListTables</code> is paginated, with each page returning a maximum of
                *             100 table names.</p>
                */
            listTables(args: ListTablesCommandInput, options?: __HttpHandlerOptions): Promise<ListTablesCommandOutput>;
            listTables(args: ListTablesCommandInput, cb: (err: any, data?: ListTablesCommandOutput) => void): void;
            listTables(args: ListTablesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListTablesCommandOutput) => void): void;
            /**
                * <p>List all tags on an Amazon DynamoDB resource. You can call ListTagsOfResource up to 10
                *             times per second, per account.</p>
                *         <p>For an overview on tagging DynamoDB resources, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Tagging.html">Tagging for DynamoDB</a>
                *             in the <i>Amazon DynamoDB Developer Guide</i>.</p>
                */
            listTagsOfResource(args: ListTagsOfResourceCommandInput, options?: __HttpHandlerOptions): Promise<ListTagsOfResourceCommandOutput>;
            listTagsOfResource(args: ListTagsOfResourceCommandInput, cb: (err: any, data?: ListTagsOfResourceCommandOutput) => void): void;
            listTagsOfResource(args: ListTagsOfResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListTagsOfResourceCommandOutput) => void): void;
            /**
                * <p>Creates a new item, or replaces an old item with a new item. If an item that has the
                *             same primary key as the new item already exists in the specified table, the new item
                *             completely replaces the existing item. You can perform a conditional put operation (add
                *             a new item if one with the specified primary key doesn't exist), or replace an existing
                *             item if it has certain attribute values. You can return the item's attribute values in
                *             the same operation, using the <code>ReturnValues</code> parameter.</p>
                *
                *         <p>When you add an item, the primary key attributes are the only required attributes.
                *             Attribute values cannot be null.</p>
                *         <p>Empty String and Binary attribute values are allowed. Attribute values of type String
                *             and Binary must have a length greater than zero if the attribute is used as a key
                *             attribute for a table or index. Set type attributes cannot be empty. </p>
                *         <p>Invalid Requests with empty values will be rejected with a
                *                 <code>ValidationException</code> exception.</p>
                *         <note>
                *             <p>To prevent a new item from replacing an existing item, use a conditional
                *                 expression that contains the <code>attribute_not_exists</code> function with the
                *                 name of the attribute being used as the partition key for the table. Since every
                *                 record must contain that attribute, the <code>attribute_not_exists</code> function
                *                 will only succeed if no matching item exists.</p>
                *         </note>
                *         <p>For more information about <code>PutItem</code>, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithItems.html">Working with
                *                 Items</a> in the <i>Amazon DynamoDB Developer Guide</i>.</p>
                */
            putItem(args: PutItemCommandInput, options?: __HttpHandlerOptions): Promise<PutItemCommandOutput>;
            putItem(args: PutItemCommandInput, cb: (err: any, data?: PutItemCommandOutput) => void): void;
            putItem(args: PutItemCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: PutItemCommandOutput) => void): void;
            /**
                * <p>You must provide the name of the partition key attribute and a single value for that
                *             attribute. <code>Query</code> returns all items with that partition key value.
                *             Optionally, you can provide a sort key attribute and use a comparison operator to refine
                *             the search results.</p>
                *
                *         <p>Use the <code>KeyConditionExpression</code> parameter to provide a specific value for
                *             the partition key. The <code>Query</code> operation will return all of the items from
                *             the table or index with that partition key value. You can optionally narrow the scope of
                *             the <code>Query</code> operation by specifying a sort key value and a comparison
                *             operator in <code>KeyConditionExpression</code>. To further refine the
                *                 <code>Query</code> results, you can optionally provide a
                *                 <code>FilterExpression</code>. A <code>FilterExpression</code> determines which
                *             items within the results should be returned to you. All of the other results are
                *             discarded. </p>
                *         <p> A <code>Query</code> operation always returns a result set. If no matching items are
                *             found, the result set will be empty. Queries that do not return results consume the
                *             minimum number of read capacity units for that type of read operation. </p>
                *         <note>
                *             <p> DynamoDB calculates the number of read capacity units consumed based on item
                *                 size, not on the amount of data that is returned to an application. The number of
                *                 capacity units consumed will be the same whether you request all of the attributes
                *                 (the default behavior) or just some of them (using a projection expression). The
                *                 number will also be the same whether or not you use a <code>FilterExpression</code>.
                *             </p>
                *         </note>
                *         <p>
                *             <code>Query</code> results are always sorted by the sort key value. If the data type of
                *             the sort key is Number, the results are returned in numeric order; otherwise, the
                *             results are returned in order of UTF-8 bytes. By default, the sort order is ascending.
                *             To reverse the order, set the <code>ScanIndexForward</code> parameter to false. </p>
                *         <p> A single <code>Query</code> operation will read up to the maximum number of items set
                *             (if using the <code>Limit</code> parameter) or a maximum of 1 MB of data and then apply
                *             any filtering to the results using <code>FilterExpression</code>. If
                *                 <code>LastEvaluatedKey</code> is present in the response, you will need to paginate
                *             the result set. For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Query.html#Query.Pagination">Paginating
                *                 the Results</a> in the <i>Amazon DynamoDB Developer Guide</i>. </p>
                *         <p>
                *             <code>FilterExpression</code> is applied after a <code>Query</code> finishes, but before
                *             the results are returned. A <code>FilterExpression</code> cannot contain partition key
                *             or sort key attributes. You need to specify those attributes in the
                *                 <code>KeyConditionExpression</code>. </p>
                *         <note>
                *             <p> A <code>Query</code> operation can return an empty result set and a
                *                     <code>LastEvaluatedKey</code> if all the items read for the page of results are
                *                 filtered out. </p>
                *         </note>
                *         <p>You can query a table, a local secondary index, or a global secondary index. For a
                *             query on a table or on a local secondary index, you can set the
                *                 <code>ConsistentRead</code> parameter to <code>true</code> and obtain a strongly
                *             consistent result. Global secondary indexes support eventually consistent reads only, so
                *             do not specify <code>ConsistentRead</code> when querying a global secondary
                *             index.</p>
                */
            query(args: QueryCommandInput, options?: __HttpHandlerOptions): Promise<QueryCommandOutput>;
            query(args: QueryCommandInput, cb: (err: any, data?: QueryCommandOutput) => void): void;
            query(args: QueryCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: QueryCommandOutput) => void): void;
            /**
                * <p>Creates a new table from an existing backup. Any number of users can execute up to 4
                *             concurrent restores (any type of restore) in a given account. </p>
                *         <p>You can call <code>RestoreTableFromBackup</code> at a maximum rate of 10 times per
                *             second.</p>
                *         <p>You must manually set up the following on the restored table:</p>
                *         <ul>
                *             <li>
                *                 <p>Auto scaling policies</p>
                *             </li>
                *             <li>
                *                 <p>IAM policies</p>
                *             </li>
                *             <li>
                *                 <p>Amazon CloudWatch metrics and alarms</p>
                *             </li>
                *             <li>
                *                 <p>Tags</p>
                *             </li>
                *             <li>
                *                 <p>Stream settings</p>
                *             </li>
                *             <li>
                *                 <p>Time to Live (TTL) settings</p>
                *             </li>
                *          </ul>
                */
            restoreTableFromBackup(args: RestoreTableFromBackupCommandInput, options?: __HttpHandlerOptions): Promise<RestoreTableFromBackupCommandOutput>;
            restoreTableFromBackup(args: RestoreTableFromBackupCommandInput, cb: (err: any, data?: RestoreTableFromBackupCommandOutput) => void): void;
            restoreTableFromBackup(args: RestoreTableFromBackupCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: RestoreTableFromBackupCommandOutput) => void): void;
            /**
                * <p>Restores the specified table to the specified point in time within
                *                 <code>EarliestRestorableDateTime</code> and <code>LatestRestorableDateTime</code>.
                *             You can restore your table to any point in time during the last 35 days. Any number of
                *             users can execute up to 4 concurrent restores (any type of restore) in a given account. </p>
                *         <p> When you restore using point in time recovery, DynamoDB restores your table data to
                *             the state based on the selected date and time (day:hour:minute:second) to a new table. </p>
                *         <p> Along with data, the following are also included on the new restored table using
                *             point in time recovery: </p>
                *         <ul>
                *             <li>
                *                 <p>Global secondary indexes (GSIs)</p>
                *             </li>
                *             <li>
                *                 <p>Local secondary indexes (LSIs)</p>
                *             </li>
                *             <li>
                *                 <p>Provisioned read and write capacity</p>
                *             </li>
                *             <li>
                *                 <p>Encryption settings</p>
                *                 <important>
                *                     <p> All these settings come from the current settings of the source table at
                *                         the time of restore. </p>
                *                 </important>
                *             </li>
                *          </ul>
                *
                *         <p>You must manually set up the following on the restored table:</p>
                *         <ul>
                *             <li>
                *                 <p>Auto scaling policies</p>
                *             </li>
                *             <li>
                *                 <p>IAM policies</p>
                *             </li>
                *             <li>
                *                 <p>Amazon CloudWatch metrics and alarms</p>
                *             </li>
                *             <li>
                *                 <p>Tags</p>
                *             </li>
                *             <li>
                *                 <p>Stream settings</p>
                *             </li>
                *             <li>
                *                 <p>Time to Live (TTL) settings</p>
                *             </li>
                *             <li>
                *                 <p>Point in time recovery settings</p>
                *             </li>
                *          </ul>
                */
            restoreTableToPointInTime(args: RestoreTableToPointInTimeCommandInput, options?: __HttpHandlerOptions): Promise<RestoreTableToPointInTimeCommandOutput>;
            restoreTableToPointInTime(args: RestoreTableToPointInTimeCommandInput, cb: (err: any, data?: RestoreTableToPointInTimeCommandOutput) => void): void;
            restoreTableToPointInTime(args: RestoreTableToPointInTimeCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: RestoreTableToPointInTimeCommandOutput) => void): void;
            /**
                * <p>The <code>Scan</code> operation returns one or more items and item attributes by
                *             accessing every item in a table or a secondary index. To have DynamoDB return fewer
                *             items, you can provide a <code>FilterExpression</code> operation.</p>
                *         <p>If the total number of scanned items exceeds the maximum dataset size limit of 1 MB,
                *             the scan stops and results are returned to the user as a <code>LastEvaluatedKey</code>
                *             value to continue the scan in a subsequent operation. The results also include the
                *             number of items exceeding the limit. A scan can result in no table data meeting the
                *             filter criteria. </p>
                *         <p>A single <code>Scan</code> operation reads up to the maximum number of items set (if
                *             using the <code>Limit</code> parameter) or a maximum of 1 MB of data and then apply any
                *             filtering to the results using <code>FilterExpression</code>. If
                *                 <code>LastEvaluatedKey</code> is present in the response, you need to paginate the
                *             result set. For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Scan.html#Scan.Pagination">Paginating the
                *                 Results</a> in the <i>Amazon DynamoDB Developer Guide</i>. </p>
                *         <p>
                *             <code>Scan</code> operations proceed sequentially; however, for faster performance on
                *             a large table or secondary index, applications can request a parallel <code>Scan</code>
                *             operation by providing the <code>Segment</code> and <code>TotalSegments</code>
                *             parameters. For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Scan.html#Scan.ParallelScan">Parallel
                *                 Scan</a> in the <i>Amazon DynamoDB Developer Guide</i>.</p>
                *         <p>
                *             <code>Scan</code> uses eventually consistent reads when accessing the data in a table;
                *             therefore, the result set might not include the changes to data in the table immediately
                *             before the operation began. If you need a consistent copy of the data, as of the time
                *             that the <code>Scan</code> begins, you can set the <code>ConsistentRead</code> parameter
                *             to <code>true</code>.</p>
                */
            scan(args: ScanCommandInput, options?: __HttpHandlerOptions): Promise<ScanCommandOutput>;
            scan(args: ScanCommandInput, cb: (err: any, data?: ScanCommandOutput) => void): void;
            scan(args: ScanCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ScanCommandOutput) => void): void;
            /**
                * <p>Associate a set of tags with an Amazon DynamoDB resource. You can then activate these
                *             user-defined tags so that they appear on the Billing and Cost Management console for
                *             cost allocation tracking. You can call TagResource up to five times per second, per
                *             account. </p>
                *         <p>For an overview on tagging DynamoDB resources, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Tagging.html">Tagging for DynamoDB</a>
                *             in the <i>Amazon DynamoDB Developer Guide</i>.</p>
                */
            tagResource(args: TagResourceCommandInput, options?: __HttpHandlerOptions): Promise<TagResourceCommandOutput>;
            tagResource(args: TagResourceCommandInput, cb: (err: any, data?: TagResourceCommandOutput) => void): void;
            tagResource(args: TagResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: TagResourceCommandOutput) => void): void;
            /**
                * <p>
                *             <code>TransactGetItems</code> is a synchronous operation that atomically retrieves
                *             multiple items from one or more tables (but not from indexes) in a single account and
                *             Region. A <code>TransactGetItems</code> call can contain up to 25
                *                 <code>TransactGetItem</code> objects, each of which contains a <code>Get</code>
                *             structure that specifies an item to retrieve from a table in the account and Region. A
                *             call to <code>TransactGetItems</code> cannot retrieve items from tables in more than one
                *                 Amazon Web Services account or Region. The aggregate size of the items in the
                *             transaction cannot exceed 4 MB.</p>
                *         <p>DynamoDB rejects the entire <code>TransactGetItems</code> request if any of
                *             the following is true:</p>
                *         <ul>
                *             <li>
                *                 <p>A conflicting operation is in the process of updating an item to be
                *                     read.</p>
                *             </li>
                *             <li>
                *                 <p>There is insufficient provisioned capacity for the transaction to be
                *                     completed.</p>
                *             </li>
                *             <li>
                *                 <p>There is a user error, such as an invalid data format.</p>
                *             </li>
                *             <li>
                *                 <p>The aggregate size of the items in the transaction cannot exceed 4 MB.</p>
                *             </li>
                *          </ul>
                */
            transactGetItems(args: TransactGetItemsCommandInput, options?: __HttpHandlerOptions): Promise<TransactGetItemsCommandOutput>;
            transactGetItems(args: TransactGetItemsCommandInput, cb: (err: any, data?: TransactGetItemsCommandOutput) => void): void;
            transactGetItems(args: TransactGetItemsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: TransactGetItemsCommandOutput) => void): void;
            /**
                * <p>
                *             <code>TransactWriteItems</code> is a synchronous write operation that groups up to 25
                *             action requests. These actions can target items in different tables, but not in
                *             different Amazon Web Services accounts or Regions, and no two actions can target the same
                *             item. For example, you cannot both <code>ConditionCheck</code> and <code>Update</code>
                *             the same item. The aggregate size of the items in the transaction cannot exceed 4
                *             MB.</p>
                *
                *         <p>The actions are completed atomically so that either all of them succeed, or all of
                *             them fail. They are defined by the following objects:</p>
                *
                *         <ul>
                *             <li>
                *                 <p>
                *                   <code>Put</code>   Initiates a <code>PutItem</code>
                *                     operation to write a new item. This structure specifies the primary key of the
                *                     item to be written, the name of the table to write it in, an optional condition
                *                     expression that must be satisfied for the write to succeed, a list of the item's
                *                     attributes, and a field indicating whether to retrieve the item's attributes if
                *                     the condition is not met.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>Update</code>   Initiates an <code>UpdateItem</code>
                *                     operation to update an existing item. This structure specifies the primary key
                *                     of the item to be updated, the name of the table where it resides, an optional
                *                     condition expression that must be satisfied for the update to succeed, an
                *                     expression that defines one or more attributes to be updated, and a field
                *                     indicating whether to retrieve the item's attributes if the condition is not
                *                     met.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>Delete</code>   Initiates a <code>DeleteItem</code>
                *                     operation to delete an existing item. This structure specifies the primary key
                *                     of the item to be deleted, the name of the table where it resides, an optional
                *                     condition expression that must be satisfied for the deletion to succeed, and a
                *                     field indicating whether to retrieve the item's attributes if the condition is
                *                     not met.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>ConditionCheck</code>   Applies a condition to an item
                *                     that is not being modified by the transaction. This structure specifies the
                *                     primary key of the item to be checked, the name of the table where it resides, a
                *                     condition expression that must be satisfied for the transaction to succeed, and
                *                     a field indicating whether to retrieve the item's attributes if the condition is
                *                     not met.</p>
                *             </li>
                *          </ul>
                *
                *         <p>DynamoDB rejects the entire <code>TransactWriteItems</code> request if any of the
                *             following is true:</p>
                *         <ul>
                *             <li>
                *                 <p>A condition in one of the condition expressions is not met.</p>
                *             </li>
                *             <li>
                *                 <p>An ongoing operation is in the process of updating the same item.</p>
                *             </li>
                *             <li>
                *                 <p>There is insufficient provisioned capacity for the transaction to be
                *                     completed.</p>
                *             </li>
                *             <li>
                *                 <p>An item size becomes too large (bigger than 400 KB), a local secondary index
                *                     (LSI) becomes too large, or a similar validation error occurs because of changes
                *                     made by the transaction.</p>
                *             </li>
                *             <li>
                *                 <p>The aggregate size of the items in the transaction exceeds 4 MB.</p>
                *             </li>
                *             <li>
                *                 <p>There is a user error, such as an invalid data format.</p>
                *             </li>
                *          </ul>
                */
            transactWriteItems(args: TransactWriteItemsCommandInput, options?: __HttpHandlerOptions): Promise<TransactWriteItemsCommandOutput>;
            transactWriteItems(args: TransactWriteItemsCommandInput, cb: (err: any, data?: TransactWriteItemsCommandOutput) => void): void;
            transactWriteItems(args: TransactWriteItemsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: TransactWriteItemsCommandOutput) => void): void;
            /**
                * <p>Removes the association of tags from an Amazon DynamoDB resource. You can call
                *                 <code>UntagResource</code> up to five times per second, per account. </p>
                *         <p>For an overview on tagging DynamoDB resources, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Tagging.html">Tagging for DynamoDB</a>
                *             in the <i>Amazon DynamoDB Developer Guide</i>.</p>
                */
            untagResource(args: UntagResourceCommandInput, options?: __HttpHandlerOptions): Promise<UntagResourceCommandOutput>;
            untagResource(args: UntagResourceCommandInput, cb: (err: any, data?: UntagResourceCommandOutput) => void): void;
            untagResource(args: UntagResourceCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UntagResourceCommandOutput) => void): void;
            /**
                * <p>
                *             <code>UpdateContinuousBackups</code> enables or disables point in time recovery for
                *             the specified table. A successful <code>UpdateContinuousBackups</code> call returns the
                *             current <code>ContinuousBackupsDescription</code>. Continuous backups are
                *                 <code>ENABLED</code> on all tables at table creation. If point in time recovery is
                *             enabled, <code>PointInTimeRecoveryStatus</code> will be set to ENABLED.</p>
                *         <p> Once continuous backups and point in time recovery are enabled, you can restore to
                *             any point in time within <code>EarliestRestorableDateTime</code> and
                *                 <code>LatestRestorableDateTime</code>. </p>
                *         <p>
                *             <code>LatestRestorableDateTime</code> is typically 5 minutes before the current time.
                *             You can restore your table to any point in time during the last 35 days. </p>
                */
            updateContinuousBackups(args: UpdateContinuousBackupsCommandInput, options?: __HttpHandlerOptions): Promise<UpdateContinuousBackupsCommandOutput>;
            updateContinuousBackups(args: UpdateContinuousBackupsCommandInput, cb: (err: any, data?: UpdateContinuousBackupsCommandOutput) => void): void;
            updateContinuousBackups(args: UpdateContinuousBackupsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateContinuousBackupsCommandOutput) => void): void;
            /**
                * <p>Updates the status for contributor insights for a specific table or index. CloudWatch
                *             Contributor Insights for DynamoDB graphs display the partition key and (if applicable)
                *             sort key of frequently accessed items and frequently throttled items in plaintext. If
                *             you require the use of Amazon Web Services Key Management Service (KMS) to encrypt this
                *             tables partition key and sort key data with an Amazon Web Services managed key or
                *             customer managed key, you should not enable CloudWatch Contributor Insights for DynamoDB
                *             for this table.</p>
                */
            updateContributorInsights(args: UpdateContributorInsightsCommandInput, options?: __HttpHandlerOptions): Promise<UpdateContributorInsightsCommandOutput>;
            updateContributorInsights(args: UpdateContributorInsightsCommandInput, cb: (err: any, data?: UpdateContributorInsightsCommandOutput) => void): void;
            updateContributorInsights(args: UpdateContributorInsightsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateContributorInsightsCommandOutput) => void): void;
            /**
                * <p>Adds or removes replicas in the specified global table. The global table must already
                *             exist to be able to use this operation. Any replica to be added must be empty, have the
                *             same name as the global table, have the same key schema, have DynamoDB Streams enabled,
                *             and have the same provisioned and maximum write capacity units.</p>
                *         <note>
                *             <p>Although you can use <code>UpdateGlobalTable</code> to add replicas and remove
                *                 replicas in a single request, for simplicity we recommend that you issue separate
                *                 requests for adding or removing replicas.</p>
                *         </note>
                *         <p> If global secondary indexes are specified, then the following conditions must also be
                *             met: </p>
                *         <ul>
                *             <li>
                *                 <p> The global secondary indexes must have the same name. </p>
                *             </li>
                *             <li>
                *                 <p> The global secondary indexes must have the same hash key and sort key (if
                *                     present). </p>
                *             </li>
                *             <li>
                *                 <p> The global secondary indexes must have the same provisioned and maximum write
                *                     capacity units. </p>
                *             </li>
                *          </ul>
                */
            updateGlobalTable(args: UpdateGlobalTableCommandInput, options?: __HttpHandlerOptions): Promise<UpdateGlobalTableCommandOutput>;
            updateGlobalTable(args: UpdateGlobalTableCommandInput, cb: (err: any, data?: UpdateGlobalTableCommandOutput) => void): void;
            updateGlobalTable(args: UpdateGlobalTableCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateGlobalTableCommandOutput) => void): void;
            /**
                * <p>Updates settings for a global table.</p>
                */
            updateGlobalTableSettings(args: UpdateGlobalTableSettingsCommandInput, options?: __HttpHandlerOptions): Promise<UpdateGlobalTableSettingsCommandOutput>;
            updateGlobalTableSettings(args: UpdateGlobalTableSettingsCommandInput, cb: (err: any, data?: UpdateGlobalTableSettingsCommandOutput) => void): void;
            updateGlobalTableSettings(args: UpdateGlobalTableSettingsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateGlobalTableSettingsCommandOutput) => void): void;
            /**
                * <p>Edits an existing item's attributes, or adds a new item to the table if it does not
                *             already exist. You can put, delete, or add attribute values. You can also perform a
                *             conditional update on an existing item (insert a new attribute name-value pair if it
                *             doesn't exist, or replace an existing name-value pair if it has certain expected
                *             attribute values).</p>
                *         <p>You can also return the item's attribute values in the same <code>UpdateItem</code>
                *             operation using the <code>ReturnValues</code> parameter.</p>
                */
            updateItem(args: UpdateItemCommandInput, options?: __HttpHandlerOptions): Promise<UpdateItemCommandOutput>;
            updateItem(args: UpdateItemCommandInput, cb: (err: any, data?: UpdateItemCommandOutput) => void): void;
            updateItem(args: UpdateItemCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateItemCommandOutput) => void): void;
            /**
                * <p>Modifies the provisioned throughput settings, global secondary indexes, or DynamoDB
                *             Streams settings for a given table.</p>
                *         <p>You can only perform one of the following operations at once:</p>
                *         <ul>
                *             <li>
                *                 <p>Modify the provisioned throughput settings of the table.</p>
                *             </li>
                *             <li>
                *                 <p>Remove a global secondary index from the table.</p>
                *             </li>
                *             <li>
                *                 <p>Create a new global secondary index on the table. After the index begins
                *                     backfilling, you can use <code>UpdateTable</code> to perform other
                *                     operations.</p>
                *             </li>
                *          </ul>
                *         <p>
                *             <code>UpdateTable</code> is an asynchronous operation; while it is executing, the table
                *             status changes from <code>ACTIVE</code> to <code>UPDATING</code>. While it is
                *                 <code>UPDATING</code>, you cannot issue another <code>UpdateTable</code> request.
                *             When the table returns to the <code>ACTIVE</code> state, the <code>UpdateTable</code>
                *             operation is complete.</p>
                */
            updateTable(args: UpdateTableCommandInput, options?: __HttpHandlerOptions): Promise<UpdateTableCommandOutput>;
            updateTable(args: UpdateTableCommandInput, cb: (err: any, data?: UpdateTableCommandOutput) => void): void;
            updateTable(args: UpdateTableCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateTableCommandOutput) => void): void;
            /**
                * <p>Updates auto scaling settings on your global tables at once.</p>
                *         <note>
                *             <p>This operation only applies to <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.V2.html">Version
                *                     2019.11.21</a> of global tables.</p>
                *         </note>
                */
            updateTableReplicaAutoScaling(args: UpdateTableReplicaAutoScalingCommandInput, options?: __HttpHandlerOptions): Promise<UpdateTableReplicaAutoScalingCommandOutput>;
            updateTableReplicaAutoScaling(args: UpdateTableReplicaAutoScalingCommandInput, cb: (err: any, data?: UpdateTableReplicaAutoScalingCommandOutput) => void): void;
            updateTableReplicaAutoScaling(args: UpdateTableReplicaAutoScalingCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateTableReplicaAutoScalingCommandOutput) => void): void;
            /**
                * <p>The <code>UpdateTimeToLive</code> method enables or disables Time to Live (TTL) for
                *             the specified table. A successful <code>UpdateTimeToLive</code> call returns the current
                *                 <code>TimeToLiveSpecification</code>. It can take up to one hour for the change to
                *             fully process. Any additional <code>UpdateTimeToLive</code> calls for the same table
                *             during this one hour duration result in a <code>ValidationException</code>. </p>
                *         <p>TTL compares the current time in epoch time format to the time stored in the TTL
                *             attribute of an item. If the epoch time value stored in the attribute is less than the
                *             current time, the item is marked as expired and subsequently deleted.</p>
                *         <note>
                *             <p> The epoch time format is the number of seconds elapsed since 12:00:00 AM January
                *                 1, 1970 UTC. </p>
                *         </note>
                *         <p>DynamoDB deletes expired items on a best-effort basis to ensure availability of
                *             throughput for other data operations. </p>
                *         <important>
                *             <p>DynamoDB typically deletes expired items within two days of expiration. The exact
                *                 duration within which an item gets deleted after expiration is specific to the
                *                 nature of the workload. Items that have expired and not been deleted will still show
                *                 up in reads, queries, and scans.</p>
                *         </important>
                *         <p>As items are deleted, they are removed from any local secondary index and global
                *             secondary index immediately in the same eventually consistent way as a standard delete
                *             operation.</p>
                *         <p>For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/TTL.html">Time To Live</a> in the
                *             Amazon DynamoDB Developer Guide. </p>
                */
            updateTimeToLive(args: UpdateTimeToLiveCommandInput, options?: __HttpHandlerOptions): Promise<UpdateTimeToLiveCommandOutput>;
            updateTimeToLive(args: UpdateTimeToLiveCommandInput, cb: (err: any, data?: UpdateTimeToLiveCommandOutput) => void): void;
            updateTimeToLive(args: UpdateTimeToLiveCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateTimeToLiveCommandOutput) => void): void;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/BatchExecuteStatementCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { BatchExecuteStatementInput, BatchExecuteStatementOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface BatchExecuteStatementCommandInput extends BatchExecuteStatementInput {
    }
    export interface BatchExecuteStatementCommandOutput extends BatchExecuteStatementOutput, __MetadataBearer {
    }
    /**
        * <p>This operation allows you to perform batch reads or writes on data stored in DynamoDB,
        *             using PartiQL. Each read statement in a <code>BatchExecuteStatement</code> must specify an equality
        *             condition on all key attributes. This enforces that each <code>SELECT</code> statement in a
        *             batch returns at most a single item.</p>
        *         <note>
        *             <p>The entire batch must consist of either read statements or write statements, you
        *                 cannot mix both in one batch.</p>
        *         </note>
        *         <important>
        *             <p>A HTTP 200 response does not mean that all statements in the BatchExecuteStatement
        *                 succeeded. Error details for individual statements can be found under the <a href="https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_BatchStatementResponse.html#DDB-Type-BatchStatementResponse-Error">Error</a> field of the <code>BatchStatementResponse</code> for each
        *                 statement.</p>
        *         </important>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, BatchExecuteStatementCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, BatchExecuteStatementCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new BatchExecuteStatementCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link BatchExecuteStatementCommandInput} for command's `input` shape.
        * @see {@link BatchExecuteStatementCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class BatchExecuteStatementCommand extends $Command<BatchExecuteStatementCommandInput, BatchExecuteStatementCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: BatchExecuteStatementCommandInput;
            constructor(input: BatchExecuteStatementCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<BatchExecuteStatementCommandInput, BatchExecuteStatementCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/BatchGetItemCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { BatchGetItemInput, BatchGetItemOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface BatchGetItemCommandInput extends BatchGetItemInput {
    }
    export interface BatchGetItemCommandOutput extends BatchGetItemOutput, __MetadataBearer {
    }
    /**
        * <p>The <code>BatchGetItem</code> operation returns the attributes of one or more items
        *             from one or more tables. You identify requested items by primary key.</p>
        *         <p>A single operation can retrieve up to 16 MB of data, which can contain as many as 100
        *             items. <code>BatchGetItem</code> returns a partial result if the response size limit is
        *             exceeded, the table's provisioned throughput is exceeded, or an internal processing
        *             failure occurs. If a partial result is returned, the operation returns a value for
        *                 <code>UnprocessedKeys</code>. You can use this value to retry the operation starting
        *             with the next item to get.</p>
        *         <important>
        *             <p>If you request more than 100 items, <code>BatchGetItem</code> returns a
        *                     <code>ValidationException</code> with the message "Too many items requested for
        *                 the BatchGetItem call."</p>
        *         </important>
        *         <p>For example, if you ask to retrieve 100 items, but each individual item is 300 KB in
        *             size, the system returns 52 items (so as not to exceed the 16 MB limit). It also returns
        *             an appropriate <code>UnprocessedKeys</code> value so you can get the next page of
        *             results. If desired, your application can include its own logic to assemble the pages of
        *             results into one dataset.</p>
        *         <p>If <i>none</i> of the items can be processed due to insufficient
        *             provisioned throughput on all of the tables in the request, then
        *                 <code>BatchGetItem</code> returns a
        *                 <code>ProvisionedThroughputExceededException</code>. If <i>at least
        *                 one</i> of the items is successfully processed, then
        *                 <code>BatchGetItem</code> completes successfully, while returning the keys of the
        *             unread items in <code>UnprocessedKeys</code>.</p>
        *         <important>
        *             <p>If DynamoDB returns any unprocessed items, you should retry the batch operation on
        *                 those items. However, <i>we strongly recommend that you use an exponential
        *                     backoff algorithm</i>. If you retry the batch operation immediately, the
        *                 underlying read or write requests can still fail due to throttling on the individual
        *                 tables. If you delay the batch operation using exponential backoff, the individual
        *                 requests in the batch are much more likely to succeed.</p>
        *             <p>For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ErrorHandling.html#BatchOperations">Batch Operations and Error Handling</a> in the <i>Amazon DynamoDB
        *                     Developer Guide</i>.</p>
        *         </important>
        *         <p>By default, <code>BatchGetItem</code> performs eventually consistent reads on every
        *             table in the request. If you want strongly consistent reads instead, you can set
        *                 <code>ConsistentRead</code> to <code>true</code> for any or all tables.</p>
        *         <p>In order to minimize response latency, <code>BatchGetItem</code> retrieves items in
        *             parallel.</p>
        *         <p>When designing your application, keep in mind that DynamoDB does not return items in
        *             any particular order. To help parse the response by item, include the primary key values
        *             for the items in your request in the <code>ProjectionExpression</code> parameter.</p>
        *         <p>If a requested item does not exist, it is not returned in the result. Requests for
        *             nonexistent items consume the minimum read capacity units according to the type of read.
        *             For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html#CapacityUnitCalculations">Working with Tables</a> in the <i>Amazon DynamoDB Developer
        *                 Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, BatchGetItemCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, BatchGetItemCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new BatchGetItemCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link BatchGetItemCommandInput} for command's `input` shape.
        * @see {@link BatchGetItemCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class BatchGetItemCommand extends $Command<BatchGetItemCommandInput, BatchGetItemCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: BatchGetItemCommandInput;
            constructor(input: BatchGetItemCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<BatchGetItemCommandInput, BatchGetItemCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/BatchWriteItemCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { BatchWriteItemInput, BatchWriteItemOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface BatchWriteItemCommandInput extends BatchWriteItemInput {
    }
    export interface BatchWriteItemCommandOutput extends BatchWriteItemOutput, __MetadataBearer {
    }
    /**
        * <p>The <code>BatchWriteItem</code> operation puts or deletes multiple items in one or
        *             more tables. A single call to <code>BatchWriteItem</code> can transmit up to 16MB of
        *             data over the network, consisting of up to 25 item put or delete operations. While
        *             individual items can be up to 400 KB once stored, it's important to note that an item's
        *             representation might be greater than 400KB while being sent in DynamoDB's JSON format
        *             for the API call. For more details on this distinction, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.NamingRulesDataTypes.html">Naming Rules and Data Types</a>.</p>
        *         <note>
        *             <p>
        *                 <code>BatchWriteItem</code> cannot update items. To update items, use the
        *                     <code>UpdateItem</code> action.</p>
        *         </note>
        *         <p>The individual <code>PutItem</code> and <code>DeleteItem</code> operations specified
        *             in <code>BatchWriteItem</code> are atomic; however <code>BatchWriteItem</code> as a
        *             whole is not. If any requested operations fail because the table's provisioned
        *             throughput is exceeded or an internal processing failure occurs, the failed operations
        *             are returned in the <code>UnprocessedItems</code> response parameter. You can
        *             investigate and optionally resend the requests. Typically, you would call
        *                 <code>BatchWriteItem</code> in a loop. Each iteration would check for unprocessed
        *             items and submit a new <code>BatchWriteItem</code> request with those unprocessed items
        *             until all items have been processed.</p>
        *         <p>If <i>none</i> of the items can be processed due to insufficient
        *             provisioned throughput on all of the tables in the request, then
        *                 <code>BatchWriteItem</code> returns a
        *                 <code>ProvisionedThroughputExceededException</code>.</p>
        *         <important>
        *             <p>If DynamoDB returns any unprocessed items, you should retry the batch operation on
        *                 those items. However, <i>we strongly recommend that you use an exponential
        *                     backoff algorithm</i>. If you retry the batch operation immediately, the
        *                 underlying read or write requests can still fail due to throttling on the individual
        *                 tables. If you delay the batch operation using exponential backoff, the individual
        *                 requests in the batch are much more likely to succeed.</p>
        *             <p>For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ErrorHandling.html#Programming.Errors.BatchOperations">Batch Operations and Error Handling</a> in the <i>Amazon DynamoDB
        *                     Developer Guide</i>.</p>
        *         </important>
        *
        *         <p>With <code>BatchWriteItem</code>, you can efficiently write or delete large amounts of
        *             data, such as from Amazon EMR, or copy data from another database into DynamoDB. In
        *             order to improve performance with these large-scale operations,
        *                 <code>BatchWriteItem</code> does not behave in the same way as individual
        *                 <code>PutItem</code> and <code>DeleteItem</code> calls would. For example, you
        *             cannot specify conditions on individual put and delete requests, and
        *                 <code>BatchWriteItem</code> does not return deleted items in the response.</p>
        *         <p>If you use a programming language that supports concurrency, you can use threads to
        *             write items in parallel. Your application must include the necessary logic to manage the
        *             threads. With languages that don't support threading, you must update or delete the
        *             specified items one at a time. In both situations, <code>BatchWriteItem</code> performs
        *             the specified put and delete operations in parallel, giving you the power of the thread
        *             pool approach without having to introduce complexity into your application.</p>
        *         <p>Parallel processing reduces latency, but each specified put and delete request
        *             consumes the same number of write capacity units whether it is processed in parallel or
        *             not. Delete operations on nonexistent items consume one write capacity unit.</p>
        *         <p>If one or more of the following is true, DynamoDB rejects the entire batch write
        *             operation:</p>
        *         <ul>
        *             <li>
        *                 <p>One or more tables specified in the <code>BatchWriteItem</code> request does
        *                     not exist.</p>
        *             </li>
        *             <li>
        *                 <p>Primary key attributes specified on an item in the request do not match those
        *                     in the corresponding table's primary key schema.</p>
        *             </li>
        *             <li>
        *                 <p>You try to perform multiple operations on the same item in the same
        *                         <code>BatchWriteItem</code> request. For example, you cannot put and delete
        *                     the same item in the same <code>BatchWriteItem</code> request. </p>
        *             </li>
        *             <li>
        *                 <p> Your request contains at least two items with identical hash and range keys
        *                     (which essentially is two put operations). </p>
        *             </li>
        *             <li>
        *                 <p>There are more than 25 requests in the batch.</p>
        *             </li>
        *             <li>
        *                 <p>Any individual item in a batch exceeds 400 KB.</p>
        *             </li>
        *             <li>
        *                 <p>The total request size exceeds 16 MB.</p>
        *             </li>
        *          </ul>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, BatchWriteItemCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, BatchWriteItemCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new BatchWriteItemCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link BatchWriteItemCommandInput} for command's `input` shape.
        * @see {@link BatchWriteItemCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class BatchWriteItemCommand extends $Command<BatchWriteItemCommandInput, BatchWriteItemCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: BatchWriteItemCommandInput;
            constructor(input: BatchWriteItemCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<BatchWriteItemCommandInput, BatchWriteItemCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/CreateBackupCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { CreateBackupInput, CreateBackupOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface CreateBackupCommandInput extends CreateBackupInput {
    }
    export interface CreateBackupCommandOutput extends CreateBackupOutput, __MetadataBearer {
    }
    /**
        * <p>Creates a backup for an existing table.</p>
        *         <p> Each time you create an on-demand backup, the entire table data is backed up. There
        *             is no limit to the number of on-demand backups that can be taken. </p>
        *         <p> When you create an on-demand backup, a time marker of the request is cataloged, and
        *             the backup is created asynchronously, by applying all changes until the time of the
        *             request to the last full table snapshot. Backup requests are processed instantaneously
        *             and become available for restore within minutes. </p>
        *         <p>You can call <code>CreateBackup</code> at a maximum rate of 50 times per
        *             second.</p>
        *         <p>All backups in DynamoDB work without consuming any provisioned throughput on the
        *             table.</p>
        *         <p> If you submit a backup request on 2018-12-14 at 14:25:00, the backup is guaranteed to
        *             contain all data committed to the table up to 14:24:00, and data committed after
        *             14:26:00 will not be. The backup might contain data modifications made between 14:24:00
        *             and 14:26:00. On-demand backup does not support causal consistency. </p>
        *         <p> Along with data, the following are also included on the backups: </p>
        *         <ul>
        *             <li>
        *                 <p>Global secondary indexes (GSIs)</p>
        *             </li>
        *             <li>
        *                 <p>Local secondary indexes (LSIs)</p>
        *             </li>
        *             <li>
        *                 <p>Streams</p>
        *             </li>
        *             <li>
        *                 <p>Provisioned read and write capacity</p>
        *             </li>
        *          </ul>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, CreateBackupCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, CreateBackupCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new CreateBackupCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateBackupCommandInput} for command's `input` shape.
        * @see {@link CreateBackupCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class CreateBackupCommand extends $Command<CreateBackupCommandInput, CreateBackupCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: CreateBackupCommandInput;
            constructor(input: CreateBackupCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateBackupCommandInput, CreateBackupCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/CreateGlobalTableCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { CreateGlobalTableInput, CreateGlobalTableOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface CreateGlobalTableCommandInput extends CreateGlobalTableInput {
    }
    export interface CreateGlobalTableCommandOutput extends CreateGlobalTableOutput, __MetadataBearer {
    }
    /**
        * <p>Creates a global table from an existing table. A global table creates a replication
        *             relationship between two or more DynamoDB tables with the same table name in the
        *             provided Regions. </p>
        *         <note>
        *             <p>This operation only applies to <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.V1.html">Version
        *                     2017.11.29</a> of global tables.</p>
        *         </note>
        *
        *         <p>If you want to add a new replica table to a global table, each of the following
        *             conditions must be true:</p>
        *         <ul>
        *             <li>
        *                 <p>The table must have the same primary key as all of the other replicas.</p>
        *             </li>
        *             <li>
        *                 <p>The table must have the same name as all of the other replicas.</p>
        *             </li>
        *             <li>
        *                 <p>The table must have DynamoDB Streams enabled, with the stream containing both
        *                     the new and the old images of the item.</p>
        *             </li>
        *             <li>
        *                 <p>None of the replica tables in the global table can contain any data.</p>
        *             </li>
        *          </ul>
        *         <p> If global secondary indexes are specified, then the following conditions must also be
        *             met: </p>
        *         <ul>
        *             <li>
        *                 <p> The global secondary indexes must have the same name. </p>
        *             </li>
        *             <li>
        *                 <p> The global secondary indexes must have the same hash key and sort key (if
        *                     present). </p>
        *             </li>
        *          </ul>
        *         <p> If local secondary indexes are specified, then the following conditions must also be
        *             met: </p>
        *         <ul>
        *             <li>
        *                 <p> The local secondary indexes must have the same name. </p>
        *             </li>
        *             <li>
        *                 <p> The local secondary indexes must have the same hash key and sort key (if
        *                     present). </p>
        *             </li>
        *          </ul>
        *
        *         <important>
        *             <p> Write capacity settings should be set consistently across your replica tables and
        *                 secondary indexes. DynamoDB strongly recommends enabling auto scaling to manage the
        *                 write capacity settings for all of your global tables replicas and indexes. </p>
        *             <p> If you prefer to manage write capacity settings manually, you should provision
        *                 equal replicated write capacity units to your replica tables. You should also
        *                 provision equal replicated write capacity units to matching secondary indexes across
        *                 your global table. </p>
        *         </important>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, CreateGlobalTableCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, CreateGlobalTableCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new CreateGlobalTableCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateGlobalTableCommandInput} for command's `input` shape.
        * @see {@link CreateGlobalTableCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class CreateGlobalTableCommand extends $Command<CreateGlobalTableCommandInput, CreateGlobalTableCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: CreateGlobalTableCommandInput;
            constructor(input: CreateGlobalTableCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateGlobalTableCommandInput, CreateGlobalTableCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/CreateTableCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { CreateTableInput, CreateTableOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface CreateTableCommandInput extends CreateTableInput {
    }
    export interface CreateTableCommandOutput extends CreateTableOutput, __MetadataBearer {
    }
    /**
        * <p>The <code>CreateTable</code> operation adds a new table to your account. In an Amazon Web Services account, table names must be unique within each Region. That is, you can
        *             have two tables with same name if you create the tables in different Regions.</p>
        *         <p>
        *             <code>CreateTable</code> is an asynchronous operation. Upon receiving a
        *                 <code>CreateTable</code> request, DynamoDB immediately returns a response with a
        *                 <code>TableStatus</code> of <code>CREATING</code>. After the table is created,
        *             DynamoDB sets the <code>TableStatus</code> to <code>ACTIVE</code>. You can perform read
        *             and write operations only on an <code>ACTIVE</code> table. </p>
        *         <p>You can optionally define secondary indexes on the new table, as part of the
        *                 <code>CreateTable</code> operation. If you want to create multiple tables with
        *             secondary indexes on them, you must create the tables sequentially. Only one table with
        *             secondary indexes can be in the <code>CREATING</code> state at any given time.</p>
        *         <p>You can use the <code>DescribeTable</code> action to check the table status.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, CreateTableCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, CreateTableCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new CreateTableCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link CreateTableCommandInput} for command's `input` shape.
        * @see {@link CreateTableCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class CreateTableCommand extends $Command<CreateTableCommandInput, CreateTableCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: CreateTableCommandInput;
            constructor(input: CreateTableCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<CreateTableCommandInput, CreateTableCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/DeleteBackupCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { DeleteBackupInput, DeleteBackupOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface DeleteBackupCommandInput extends DeleteBackupInput {
    }
    export interface DeleteBackupCommandOutput extends DeleteBackupOutput, __MetadataBearer {
    }
    /**
        * <p>Deletes an existing backup of a table.</p>
        *         <p>You can call <code>DeleteBackup</code> at a maximum rate of 10 times per
        *             second.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, DeleteBackupCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, DeleteBackupCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new DeleteBackupCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteBackupCommandInput} for command's `input` shape.
        * @see {@link DeleteBackupCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class DeleteBackupCommand extends $Command<DeleteBackupCommandInput, DeleteBackupCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: DeleteBackupCommandInput;
            constructor(input: DeleteBackupCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteBackupCommandInput, DeleteBackupCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/DeleteItemCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { DeleteItemInput, DeleteItemOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface DeleteItemCommandInput extends DeleteItemInput {
    }
    export interface DeleteItemCommandOutput extends DeleteItemOutput, __MetadataBearer {
    }
    /**
        * <p>Deletes a single item in a table by primary key. You can perform a conditional delete
        *             operation that deletes the item if it exists, or if it has an expected attribute
        *             value.</p>
        *         <p>In addition to deleting an item, you can also return the item's attribute values in
        *             the same operation, using the <code>ReturnValues</code> parameter.</p>
        *         <p>Unless you specify conditions, the <code>DeleteItem</code> is an idempotent operation;
        *             running it multiple times on the same item or attribute does <i>not</i>
        *             result in an error response.</p>
        *         <p>Conditional deletes are useful for deleting items only if specific conditions are met.
        *             If those conditions are met, DynamoDB performs the delete. Otherwise, the item is not
        *             deleted.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, DeleteItemCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, DeleteItemCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new DeleteItemCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteItemCommandInput} for command's `input` shape.
        * @see {@link DeleteItemCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class DeleteItemCommand extends $Command<DeleteItemCommandInput, DeleteItemCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: DeleteItemCommandInput;
            constructor(input: DeleteItemCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteItemCommandInput, DeleteItemCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/DeleteTableCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { DeleteTableInput, DeleteTableOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface DeleteTableCommandInput extends DeleteTableInput {
    }
    export interface DeleteTableCommandOutput extends DeleteTableOutput, __MetadataBearer {
    }
    /**
        * <p>The <code>DeleteTable</code> operation deletes a table and all of its items. After a
        *                 <code>DeleteTable</code> request, the specified table is in the
        *                 <code>DELETING</code> state until DynamoDB completes the deletion. If the table is
        *             in the <code>ACTIVE</code> state, you can delete it. If a table is in
        *                 <code>CREATING</code> or <code>UPDATING</code> states, then DynamoDB returns a
        *                 <code>ResourceInUseException</code>. If the specified table does not exist, DynamoDB
        *             returns a <code>ResourceNotFoundException</code>. If table is already in the
        *                 <code>DELETING</code> state, no error is returned. </p>
        *         <note>
        *             <p>DynamoDB might continue to accept data read and write operations, such as
        *                     <code>GetItem</code> and <code>PutItem</code>, on a table in the
        *                     <code>DELETING</code> state until the table deletion is complete.</p>
        *         </note>
        *         <p>When you delete a table, any indexes on that table are also deleted.</p>
        *         <p>If you have DynamoDB Streams enabled on the table, then the corresponding stream on
        *             that table goes into the <code>DISABLED</code> state, and the stream is automatically
        *             deleted after 24 hours.</p>
        *
        *         <p>Use the <code>DescribeTable</code> action to check the status of the table. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, DeleteTableCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, DeleteTableCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new DeleteTableCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DeleteTableCommandInput} for command's `input` shape.
        * @see {@link DeleteTableCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class DeleteTableCommand extends $Command<DeleteTableCommandInput, DeleteTableCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: DeleteTableCommandInput;
            constructor(input: DeleteTableCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteTableCommandInput, DeleteTableCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/DescribeBackupCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { DescribeBackupInput, DescribeBackupOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface DescribeBackupCommandInput extends DescribeBackupInput {
    }
    export interface DescribeBackupCommandOutput extends DescribeBackupOutput, __MetadataBearer {
    }
    /**
        * <p>Describes an existing backup of a table.</p>
        *         <p>You can call <code>DescribeBackup</code> at a maximum rate of 10 times per
        *             second.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, DescribeBackupCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, DescribeBackupCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new DescribeBackupCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeBackupCommandInput} for command's `input` shape.
        * @see {@link DescribeBackupCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class DescribeBackupCommand extends $Command<DescribeBackupCommandInput, DescribeBackupCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: DescribeBackupCommandInput;
            constructor(input: DescribeBackupCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeBackupCommandInput, DescribeBackupCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/DescribeContinuousBackupsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { DescribeContinuousBackupsInput, DescribeContinuousBackupsOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface DescribeContinuousBackupsCommandInput extends DescribeContinuousBackupsInput {
    }
    export interface DescribeContinuousBackupsCommandOutput extends DescribeContinuousBackupsOutput, __MetadataBearer {
    }
    /**
        * <p>Checks the status of continuous backups and point in time recovery on the specified
        *             table. Continuous backups are <code>ENABLED</code> on all tables at table creation. If
        *             point in time recovery is enabled, <code>PointInTimeRecoveryStatus</code> will be set to
        *             ENABLED.</p>
        *         <p> After continuous backups and point in time recovery are enabled, you can restore to
        *             any point in time within <code>EarliestRestorableDateTime</code> and
        *                 <code>LatestRestorableDateTime</code>. </p>
        *         <p>
        *             <code>LatestRestorableDateTime</code> is typically 5 minutes before the current time.
        *             You can restore your table to any point in time during the last 35 days. </p>
        *         <p>You can call <code>DescribeContinuousBackups</code> at a maximum rate of 10 times per
        *             second.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, DescribeContinuousBackupsCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, DescribeContinuousBackupsCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new DescribeContinuousBackupsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeContinuousBackupsCommandInput} for command's `input` shape.
        * @see {@link DescribeContinuousBackupsCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class DescribeContinuousBackupsCommand extends $Command<DescribeContinuousBackupsCommandInput, DescribeContinuousBackupsCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: DescribeContinuousBackupsCommandInput;
            constructor(input: DescribeContinuousBackupsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeContinuousBackupsCommandInput, DescribeContinuousBackupsCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/DescribeContributorInsightsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { DescribeContributorInsightsInput, DescribeContributorInsightsOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface DescribeContributorInsightsCommandInput extends DescribeContributorInsightsInput {
    }
    export interface DescribeContributorInsightsCommandOutput extends DescribeContributorInsightsOutput, __MetadataBearer {
    }
    /**
        * <p>Returns information about contributor insights, for a given table or global secondary
        *             index.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, DescribeContributorInsightsCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, DescribeContributorInsightsCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new DescribeContributorInsightsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeContributorInsightsCommandInput} for command's `input` shape.
        * @see {@link DescribeContributorInsightsCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class DescribeContributorInsightsCommand extends $Command<DescribeContributorInsightsCommandInput, DescribeContributorInsightsCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: DescribeContributorInsightsCommandInput;
            constructor(input: DescribeContributorInsightsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeContributorInsightsCommandInput, DescribeContributorInsightsCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/DescribeEndpointsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { DescribeEndpointsRequest, DescribeEndpointsResponse } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface DescribeEndpointsCommandInput extends DescribeEndpointsRequest {
    }
    export interface DescribeEndpointsCommandOutput extends DescribeEndpointsResponse, __MetadataBearer {
    }
    /**
        * <p>Returns the regional endpoint information.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, DescribeEndpointsCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, DescribeEndpointsCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new DescribeEndpointsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeEndpointsCommandInput} for command's `input` shape.
        * @see {@link DescribeEndpointsCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class DescribeEndpointsCommand extends $Command<DescribeEndpointsCommandInput, DescribeEndpointsCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: DescribeEndpointsCommandInput;
            constructor(input: DescribeEndpointsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeEndpointsCommandInput, DescribeEndpointsCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/DescribeExportCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { DescribeExportInput, DescribeExportOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface DescribeExportCommandInput extends DescribeExportInput {
    }
    export interface DescribeExportCommandOutput extends DescribeExportOutput, __MetadataBearer {
    }
    /**
        * <p>Describes an existing table export.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, DescribeExportCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, DescribeExportCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new DescribeExportCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeExportCommandInput} for command's `input` shape.
        * @see {@link DescribeExportCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class DescribeExportCommand extends $Command<DescribeExportCommandInput, DescribeExportCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: DescribeExportCommandInput;
            constructor(input: DescribeExportCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeExportCommandInput, DescribeExportCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/DescribeGlobalTableCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { DescribeGlobalTableInput, DescribeGlobalTableOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface DescribeGlobalTableCommandInput extends DescribeGlobalTableInput {
    }
    export interface DescribeGlobalTableCommandOutput extends DescribeGlobalTableOutput, __MetadataBearer {
    }
    /**
        * <p>Returns information about the specified global table.</p>
        *         <note>
        *             <p>This operation only applies to <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.V1.html">Version
        *                     2017.11.29</a> of global tables. If you are using global tables <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.V2.html">Version
        *                     2019.11.21</a> you can use <a href="https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_DescribeTable.html">DescribeTable</a> instead.</p>
        *         </note>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, DescribeGlobalTableCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, DescribeGlobalTableCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new DescribeGlobalTableCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeGlobalTableCommandInput} for command's `input` shape.
        * @see {@link DescribeGlobalTableCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class DescribeGlobalTableCommand extends $Command<DescribeGlobalTableCommandInput, DescribeGlobalTableCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: DescribeGlobalTableCommandInput;
            constructor(input: DescribeGlobalTableCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeGlobalTableCommandInput, DescribeGlobalTableCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/DescribeGlobalTableSettingsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { DescribeGlobalTableSettingsInput, DescribeGlobalTableSettingsOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface DescribeGlobalTableSettingsCommandInput extends DescribeGlobalTableSettingsInput {
    }
    export interface DescribeGlobalTableSettingsCommandOutput extends DescribeGlobalTableSettingsOutput, __MetadataBearer {
    }
    /**
        * <p>Describes Region-specific settings for a global table.</p>
        *         <note>
        *             <p>This operation only applies to <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.V1.html">Version
        *                     2017.11.29</a> of global tables.</p>
        *         </note>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, DescribeGlobalTableSettingsCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, DescribeGlobalTableSettingsCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new DescribeGlobalTableSettingsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeGlobalTableSettingsCommandInput} for command's `input` shape.
        * @see {@link DescribeGlobalTableSettingsCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class DescribeGlobalTableSettingsCommand extends $Command<DescribeGlobalTableSettingsCommandInput, DescribeGlobalTableSettingsCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: DescribeGlobalTableSettingsCommandInput;
            constructor(input: DescribeGlobalTableSettingsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeGlobalTableSettingsCommandInput, DescribeGlobalTableSettingsCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/DescribeKinesisStreamingDestinationCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { DescribeKinesisStreamingDestinationInput, DescribeKinesisStreamingDestinationOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface DescribeKinesisStreamingDestinationCommandInput extends DescribeKinesisStreamingDestinationInput {
    }
    export interface DescribeKinesisStreamingDestinationCommandOutput extends DescribeKinesisStreamingDestinationOutput, __MetadataBearer {
    }
    /**
        * <p>Returns information about the status of Kinesis streaming.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, DescribeKinesisStreamingDestinationCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, DescribeKinesisStreamingDestinationCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new DescribeKinesisStreamingDestinationCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeKinesisStreamingDestinationCommandInput} for command's `input` shape.
        * @see {@link DescribeKinesisStreamingDestinationCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class DescribeKinesisStreamingDestinationCommand extends $Command<DescribeKinesisStreamingDestinationCommandInput, DescribeKinesisStreamingDestinationCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: DescribeKinesisStreamingDestinationCommandInput;
            constructor(input: DescribeKinesisStreamingDestinationCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeKinesisStreamingDestinationCommandInput, DescribeKinesisStreamingDestinationCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/DescribeLimitsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { DescribeLimitsInput, DescribeLimitsOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface DescribeLimitsCommandInput extends DescribeLimitsInput {
    }
    export interface DescribeLimitsCommandOutput extends DescribeLimitsOutput, __MetadataBearer {
    }
    /**
        * <p>Returns the current provisioned-capacity quotas for your Amazon Web Services account in
        *             a Region, both for the Region as a whole and for any one DynamoDB table that you create
        *             there.</p>
        *         <p>When you establish an Amazon Web Services account, the account has initial quotas on
        *             the maximum read capacity units and write capacity units that you can provision across
        *             all of your DynamoDB tables in a given Region. Also, there are per-table
        *             quotas that apply when you create a table there. For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html">Service,
        *                 Account, and Table Quotas</a> page in the <i>Amazon DynamoDB
        *                 Developer Guide</i>.</p>
        *
        *         <p>Although you can increase these quotas by filing a case at <a href="https://console.aws.amazon.com/support/home#/">Amazon Web Services Support Center</a>, obtaining the
        *             increase is not instantaneous. The <code>DescribeLimits</code> action lets you write
        *             code to compare the capacity you are currently using to those quotas imposed by your
        *             account so that you have enough time to apply for an increase before you hit a
        *             quota.</p>
        *
        *         <p>For example, you could use one of the Amazon Web Services SDKs to do the
        *             following:</p>
        *
        *         <ol>
        *             <li>
        *                 <p>Call <code>DescribeLimits</code> for a particular Region to obtain your
        *                     current account quotas on provisioned capacity there.</p>
        *             </li>
        *             <li>
        *                 <p>Create a variable to hold the aggregate read capacity units provisioned for
        *                     all your tables in that Region, and one to hold the aggregate write capacity
        *                     units. Zero them both.</p>
        *             </li>
        *             <li>
        *                 <p>Call <code>ListTables</code> to obtain a list of all your DynamoDB
        *                     tables.</p>
        *             </li>
        *             <li>
        *                 <p>For each table name listed by <code>ListTables</code>, do the
        *                     following:</p>
        *                 <ul>
        *                   <li>
        *                         <p>Call <code>DescribeTable</code> with the table name.</p>
        *                     </li>
        *                   <li>
        *                         <p>Use the data returned by <code>DescribeTable</code> to add the read
        *                             capacity units and write capacity units provisioned for the table itself
        *                             to your variables.</p>
        *                     </li>
        *                   <li>
        *                         <p>If the table has one or more global secondary indexes (GSIs), loop
        *                             over these GSIs and add their provisioned capacity values to your
        *                             variables as well.</p>
        *                     </li>
        *                </ul>
        *             </li>
        *             <li>
        *                 <p>Report the account quotas for that Region returned by
        *                         <code>DescribeLimits</code>, along with the total current provisioned
        *                     capacity levels you have calculated.</p>
        *             </li>
        *          </ol>
        *
        *         <p>This will let you see whether you are getting close to your account-level
        *             quotas.</p>
        *         <p>The per-table quotas apply only when you are creating a new table. They restrict the
        *             sum of the provisioned capacity of the new table itself and all its global secondary
        *             indexes.</p>
        *         <p>For existing tables and their GSIs, DynamoDB doesn't let you increase provisioned
        *             capacity extremely rapidly, but the only quota that applies is that the aggregate
        *             provisioned capacity over all your tables and GSIs cannot exceed either of the
        *             per-account quotas.</p>
        *         <note>
        *             <p>
        *                 <code>DescribeLimits</code> should only be called periodically. You can expect
        *                 throttling errors if you call it more than once in a minute.</p>
        *         </note>
        *         <p>The <code>DescribeLimits</code> Request element has no content.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, DescribeLimitsCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, DescribeLimitsCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new DescribeLimitsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeLimitsCommandInput} for command's `input` shape.
        * @see {@link DescribeLimitsCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class DescribeLimitsCommand extends $Command<DescribeLimitsCommandInput, DescribeLimitsCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: DescribeLimitsCommandInput;
            constructor(input: DescribeLimitsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeLimitsCommandInput, DescribeLimitsCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/DescribeTableCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { DescribeTableInput, DescribeTableOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface DescribeTableCommandInput extends DescribeTableInput {
    }
    export interface DescribeTableCommandOutput extends DescribeTableOutput, __MetadataBearer {
    }
    /**
        * <p>Returns information about the table, including the current status of the table, when
        *             it was created, the primary key schema, and any indexes on the table.</p>
        *         <note>
        *             <p>If you issue a <code>DescribeTable</code> request immediately after a
        *                     <code>CreateTable</code> request, DynamoDB might return a
        *                     <code>ResourceNotFoundException</code>. This is because
        *                     <code>DescribeTable</code> uses an eventually consistent query, and the metadata
        *                 for your table might not be available at that moment. Wait for a few seconds, and
        *                 then try the <code>DescribeTable</code> request again.</p>
        *         </note>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, DescribeTableCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, DescribeTableCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new DescribeTableCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeTableCommandInput} for command's `input` shape.
        * @see {@link DescribeTableCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class DescribeTableCommand extends $Command<DescribeTableCommandInput, DescribeTableCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: DescribeTableCommandInput;
            constructor(input: DescribeTableCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeTableCommandInput, DescribeTableCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/DescribeTableReplicaAutoScalingCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { DescribeTableReplicaAutoScalingInput, DescribeTableReplicaAutoScalingOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface DescribeTableReplicaAutoScalingCommandInput extends DescribeTableReplicaAutoScalingInput {
    }
    export interface DescribeTableReplicaAutoScalingCommandOutput extends DescribeTableReplicaAutoScalingOutput, __MetadataBearer {
    }
    /**
        * <p>Describes auto scaling settings across replicas of the global table at once.</p>
        *         <note>
        *             <p>This operation only applies to <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.V2.html">Version
        *                     2019.11.21</a> of global tables.</p>
        *         </note>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, DescribeTableReplicaAutoScalingCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, DescribeTableReplicaAutoScalingCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new DescribeTableReplicaAutoScalingCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeTableReplicaAutoScalingCommandInput} for command's `input` shape.
        * @see {@link DescribeTableReplicaAutoScalingCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class DescribeTableReplicaAutoScalingCommand extends $Command<DescribeTableReplicaAutoScalingCommandInput, DescribeTableReplicaAutoScalingCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: DescribeTableReplicaAutoScalingCommandInput;
            constructor(input: DescribeTableReplicaAutoScalingCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeTableReplicaAutoScalingCommandInput, DescribeTableReplicaAutoScalingCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/DescribeTimeToLiveCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { DescribeTimeToLiveInput, DescribeTimeToLiveOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface DescribeTimeToLiveCommandInput extends DescribeTimeToLiveInput {
    }
    export interface DescribeTimeToLiveCommandOutput extends DescribeTimeToLiveOutput, __MetadataBearer {
    }
    /**
        * <p>Gives a description of the Time to Live (TTL) status on the specified table. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, DescribeTimeToLiveCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, DescribeTimeToLiveCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new DescribeTimeToLiveCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DescribeTimeToLiveCommandInput} for command's `input` shape.
        * @see {@link DescribeTimeToLiveCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class DescribeTimeToLiveCommand extends $Command<DescribeTimeToLiveCommandInput, DescribeTimeToLiveCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: DescribeTimeToLiveCommandInput;
            constructor(input: DescribeTimeToLiveCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DescribeTimeToLiveCommandInput, DescribeTimeToLiveCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/DisableKinesisStreamingDestinationCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { KinesisStreamingDestinationInput, KinesisStreamingDestinationOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface DisableKinesisStreamingDestinationCommandInput extends KinesisStreamingDestinationInput {
    }
    export interface DisableKinesisStreamingDestinationCommandOutput extends KinesisStreamingDestinationOutput, __MetadataBearer {
    }
    /**
        * <p>Stops replication from the DynamoDB table to the Kinesis data stream. This is done
        *             without deleting either of the resources.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, DisableKinesisStreamingDestinationCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, DisableKinesisStreamingDestinationCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new DisableKinesisStreamingDestinationCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DisableKinesisStreamingDestinationCommandInput} for command's `input` shape.
        * @see {@link DisableKinesisStreamingDestinationCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class DisableKinesisStreamingDestinationCommand extends $Command<DisableKinesisStreamingDestinationCommandInput, DisableKinesisStreamingDestinationCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: DisableKinesisStreamingDestinationCommandInput;
            constructor(input: DisableKinesisStreamingDestinationCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DisableKinesisStreamingDestinationCommandInput, DisableKinesisStreamingDestinationCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/EnableKinesisStreamingDestinationCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { KinesisStreamingDestinationInput, KinesisStreamingDestinationOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface EnableKinesisStreamingDestinationCommandInput extends KinesisStreamingDestinationInput {
    }
    export interface EnableKinesisStreamingDestinationCommandOutput extends KinesisStreamingDestinationOutput, __MetadataBearer {
    }
    /**
        * <p>Starts table data replication to the specified Kinesis data stream at a timestamp
        *             chosen during the enable workflow. If this operation doesn't return results immediately,
        *             use DescribeKinesisStreamingDestination to check if streaming to the Kinesis data stream
        *             is ACTIVE.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, EnableKinesisStreamingDestinationCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, EnableKinesisStreamingDestinationCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new EnableKinesisStreamingDestinationCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link EnableKinesisStreamingDestinationCommandInput} for command's `input` shape.
        * @see {@link EnableKinesisStreamingDestinationCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class EnableKinesisStreamingDestinationCommand extends $Command<EnableKinesisStreamingDestinationCommandInput, EnableKinesisStreamingDestinationCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: EnableKinesisStreamingDestinationCommandInput;
            constructor(input: EnableKinesisStreamingDestinationCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<EnableKinesisStreamingDestinationCommandInput, EnableKinesisStreamingDestinationCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/ExecuteStatementCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { ExecuteStatementInput, ExecuteStatementOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface ExecuteStatementCommandInput extends ExecuteStatementInput {
    }
    export interface ExecuteStatementCommandOutput extends ExecuteStatementOutput, __MetadataBearer {
    }
    /**
        * <p>This operation allows you to perform reads and singleton writes on data stored in
        *             DynamoDB, using PartiQL.</p>
        *         <p>For PartiQL reads (<code>SELECT</code> statement), if the total number of processed
        *             items exceeds the maximum dataset size limit of 1 MB, the read stops and results are
        *             returned to the user as a <code>LastEvaluatedKey</code> value to continue the read in a
        *             subsequent operation. If the filter criteria in <code>WHERE</code> clause does not match
        *             any data, the read will return an empty result set.</p>
        *         <p>A single <code>SELECT</code> statement response can return up to the maximum number of
        *             items (if using the Limit parameter) or a maximum of 1 MB of data (and then apply any
        *             filtering to the results using <code>WHERE</code> clause). If
        *                 <code>LastEvaluatedKey</code> is present in the response, you need to paginate the
        *             result set.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, ExecuteStatementCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, ExecuteStatementCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new ExecuteStatementCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ExecuteStatementCommandInput} for command's `input` shape.
        * @see {@link ExecuteStatementCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class ExecuteStatementCommand extends $Command<ExecuteStatementCommandInput, ExecuteStatementCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: ExecuteStatementCommandInput;
            constructor(input: ExecuteStatementCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ExecuteStatementCommandInput, ExecuteStatementCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/ExecuteTransactionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { ExecuteTransactionInput, ExecuteTransactionOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface ExecuteTransactionCommandInput extends ExecuteTransactionInput {
    }
    export interface ExecuteTransactionCommandOutput extends ExecuteTransactionOutput, __MetadataBearer {
    }
    /**
        * <p>This operation allows you to perform transactional reads or writes on data stored in
        *             DynamoDB, using PartiQL.</p>
        *         <note>
        *             <p>The entire transaction must consist of either read statements or write statements,
        *                 you cannot mix both in one transaction. The EXISTS function is an exception and can
        *                 be used to check the condition of specific attributes of the item in a similar
        *                 manner to <code>ConditionCheck</code> in the <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/transaction-apis.html#transaction-apis-txwriteitems">TransactWriteItems</a> API.</p>
        *         </note>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, ExecuteTransactionCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, ExecuteTransactionCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new ExecuteTransactionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ExecuteTransactionCommandInput} for command's `input` shape.
        * @see {@link ExecuteTransactionCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class ExecuteTransactionCommand extends $Command<ExecuteTransactionCommandInput, ExecuteTransactionCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: ExecuteTransactionCommandInput;
            constructor(input: ExecuteTransactionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ExecuteTransactionCommandInput, ExecuteTransactionCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/ExportTableToPointInTimeCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { ExportTableToPointInTimeInput, ExportTableToPointInTimeOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface ExportTableToPointInTimeCommandInput extends ExportTableToPointInTimeInput {
    }
    export interface ExportTableToPointInTimeCommandOutput extends ExportTableToPointInTimeOutput, __MetadataBearer {
    }
    /**
        * <p>Exports table data to an S3 bucket. The table must have point in time recovery
        *             enabled, and you can export data from any time within the point in time recovery
        *             window.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, ExportTableToPointInTimeCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, ExportTableToPointInTimeCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new ExportTableToPointInTimeCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ExportTableToPointInTimeCommandInput} for command's `input` shape.
        * @see {@link ExportTableToPointInTimeCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class ExportTableToPointInTimeCommand extends $Command<ExportTableToPointInTimeCommandInput, ExportTableToPointInTimeCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: ExportTableToPointInTimeCommandInput;
            constructor(input: ExportTableToPointInTimeCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ExportTableToPointInTimeCommandInput, ExportTableToPointInTimeCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/GetItemCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { GetItemInput, GetItemOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface GetItemCommandInput extends GetItemInput {
    }
    export interface GetItemCommandOutput extends GetItemOutput, __MetadataBearer {
    }
    /**
        * <p>The <code>GetItem</code> operation returns a set of attributes for the item with the
        *             given primary key. If there is no matching item, <code>GetItem</code> does not return
        *             any data and there will be no <code>Item</code> element in the response.</p>
        *         <p>
        *             <code>GetItem</code> provides an eventually consistent read by default. If your
        *             application requires a strongly consistent read, set <code>ConsistentRead</code> to
        *                 <code>true</code>. Although a strongly consistent read might take more time than an
        *             eventually consistent read, it always returns the last updated value.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, GetItemCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, GetItemCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new GetItemCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetItemCommandInput} for command's `input` shape.
        * @see {@link GetItemCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class GetItemCommand extends $Command<GetItemCommandInput, GetItemCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: GetItemCommandInput;
            constructor(input: GetItemCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetItemCommandInput, GetItemCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/ListBackupsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { ListBackupsInput, ListBackupsOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface ListBackupsCommandInput extends ListBackupsInput {
    }
    export interface ListBackupsCommandOutput extends ListBackupsOutput, __MetadataBearer {
    }
    /**
        * <p>List backups associated with an Amazon Web Services account. To list backups for a
        *             given table, specify <code>TableName</code>. <code>ListBackups</code> returns a
        *             paginated list of results with at most 1 MB worth of items in a page. You can also
        *             specify a maximum number of entries to be returned in a page.</p>
        *         <p>In the request, start time is inclusive, but end time is exclusive. Note that these
        *             boundaries are for the time at which the original backup was requested.</p>
        *         <p>You can call <code>ListBackups</code> a maximum of five times per second.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, ListBackupsCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, ListBackupsCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new ListBackupsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListBackupsCommandInput} for command's `input` shape.
        * @see {@link ListBackupsCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class ListBackupsCommand extends $Command<ListBackupsCommandInput, ListBackupsCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: ListBackupsCommandInput;
            constructor(input: ListBackupsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListBackupsCommandInput, ListBackupsCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/ListContributorInsightsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { ListContributorInsightsInput, ListContributorInsightsOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface ListContributorInsightsCommandInput extends ListContributorInsightsInput {
    }
    export interface ListContributorInsightsCommandOutput extends ListContributorInsightsOutput, __MetadataBearer {
    }
    /**
        * <p>Returns a list of ContributorInsightsSummary for a table and all its global secondary
        *             indexes.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, ListContributorInsightsCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, ListContributorInsightsCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new ListContributorInsightsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListContributorInsightsCommandInput} for command's `input` shape.
        * @see {@link ListContributorInsightsCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class ListContributorInsightsCommand extends $Command<ListContributorInsightsCommandInput, ListContributorInsightsCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: ListContributorInsightsCommandInput;
            constructor(input: ListContributorInsightsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListContributorInsightsCommandInput, ListContributorInsightsCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/ListExportsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { ListExportsInput, ListExportsOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface ListExportsCommandInput extends ListExportsInput {
    }
    export interface ListExportsCommandOutput extends ListExportsOutput, __MetadataBearer {
    }
    /**
        * <p>Lists completed exports within the past 90 days.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, ListExportsCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, ListExportsCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new ListExportsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListExportsCommandInput} for command's `input` shape.
        * @see {@link ListExportsCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class ListExportsCommand extends $Command<ListExportsCommandInput, ListExportsCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: ListExportsCommandInput;
            constructor(input: ListExportsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListExportsCommandInput, ListExportsCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/ListGlobalTablesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { ListGlobalTablesInput, ListGlobalTablesOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface ListGlobalTablesCommandInput extends ListGlobalTablesInput {
    }
    export interface ListGlobalTablesCommandOutput extends ListGlobalTablesOutput, __MetadataBearer {
    }
    /**
        * <p>Lists all global tables that have a replica in the specified Region.</p>
        *         <note>
        *             <p>This operation only applies to <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.V1.html">Version
        *                     2017.11.29</a> of global tables.</p>
        *         </note>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, ListGlobalTablesCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, ListGlobalTablesCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new ListGlobalTablesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListGlobalTablesCommandInput} for command's `input` shape.
        * @see {@link ListGlobalTablesCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class ListGlobalTablesCommand extends $Command<ListGlobalTablesCommandInput, ListGlobalTablesCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: ListGlobalTablesCommandInput;
            constructor(input: ListGlobalTablesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListGlobalTablesCommandInput, ListGlobalTablesCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/ListTablesCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { ListTablesInput, ListTablesOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface ListTablesCommandInput extends ListTablesInput {
    }
    export interface ListTablesCommandOutput extends ListTablesOutput, __MetadataBearer {
    }
    /**
        * <p>Returns an array of table names associated with the current account and endpoint. The
        *             output from <code>ListTables</code> is paginated, with each page returning a maximum of
        *             100 table names.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, ListTablesCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, ListTablesCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new ListTablesCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListTablesCommandInput} for command's `input` shape.
        * @see {@link ListTablesCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class ListTablesCommand extends $Command<ListTablesCommandInput, ListTablesCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: ListTablesCommandInput;
            constructor(input: ListTablesCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListTablesCommandInput, ListTablesCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/ListTagsOfResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { ListTagsOfResourceInput, ListTagsOfResourceOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface ListTagsOfResourceCommandInput extends ListTagsOfResourceInput {
    }
    export interface ListTagsOfResourceCommandOutput extends ListTagsOfResourceOutput, __MetadataBearer {
    }
    /**
        * <p>List all tags on an Amazon DynamoDB resource. You can call ListTagsOfResource up to 10
        *             times per second, per account.</p>
        *         <p>For an overview on tagging DynamoDB resources, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Tagging.html">Tagging for DynamoDB</a>
        *             in the <i>Amazon DynamoDB Developer Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, ListTagsOfResourceCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, ListTagsOfResourceCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new ListTagsOfResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ListTagsOfResourceCommandInput} for command's `input` shape.
        * @see {@link ListTagsOfResourceCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class ListTagsOfResourceCommand extends $Command<ListTagsOfResourceCommandInput, ListTagsOfResourceCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: ListTagsOfResourceCommandInput;
            constructor(input: ListTagsOfResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ListTagsOfResourceCommandInput, ListTagsOfResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/PutItemCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { PutItemInput, PutItemOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface PutItemCommandInput extends PutItemInput {
    }
    export interface PutItemCommandOutput extends PutItemOutput, __MetadataBearer {
    }
    /**
        * <p>Creates a new item, or replaces an old item with a new item. If an item that has the
        *             same primary key as the new item already exists in the specified table, the new item
        *             completely replaces the existing item. You can perform a conditional put operation (add
        *             a new item if one with the specified primary key doesn't exist), or replace an existing
        *             item if it has certain attribute values. You can return the item's attribute values in
        *             the same operation, using the <code>ReturnValues</code> parameter.</p>
        *
        *         <p>When you add an item, the primary key attributes are the only required attributes.
        *             Attribute values cannot be null.</p>
        *         <p>Empty String and Binary attribute values are allowed. Attribute values of type String
        *             and Binary must have a length greater than zero if the attribute is used as a key
        *             attribute for a table or index. Set type attributes cannot be empty. </p>
        *         <p>Invalid Requests with empty values will be rejected with a
        *                 <code>ValidationException</code> exception.</p>
        *         <note>
        *             <p>To prevent a new item from replacing an existing item, use a conditional
        *                 expression that contains the <code>attribute_not_exists</code> function with the
        *                 name of the attribute being used as the partition key for the table. Since every
        *                 record must contain that attribute, the <code>attribute_not_exists</code> function
        *                 will only succeed if no matching item exists.</p>
        *         </note>
        *         <p>For more information about <code>PutItem</code>, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithItems.html">Working with
        *                 Items</a> in the <i>Amazon DynamoDB Developer Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, PutItemCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, PutItemCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new PutItemCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link PutItemCommandInput} for command's `input` shape.
        * @see {@link PutItemCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class PutItemCommand extends $Command<PutItemCommandInput, PutItemCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: PutItemCommandInput;
            constructor(input: PutItemCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<PutItemCommandInput, PutItemCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/QueryCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { QueryInput, QueryOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface QueryCommandInput extends QueryInput {
    }
    export interface QueryCommandOutput extends QueryOutput, __MetadataBearer {
    }
    /**
        * <p>You must provide the name of the partition key attribute and a single value for that
        *             attribute. <code>Query</code> returns all items with that partition key value.
        *             Optionally, you can provide a sort key attribute and use a comparison operator to refine
        *             the search results.</p>
        *
        *         <p>Use the <code>KeyConditionExpression</code> parameter to provide a specific value for
        *             the partition key. The <code>Query</code> operation will return all of the items from
        *             the table or index with that partition key value. You can optionally narrow the scope of
        *             the <code>Query</code> operation by specifying a sort key value and a comparison
        *             operator in <code>KeyConditionExpression</code>. To further refine the
        *                 <code>Query</code> results, you can optionally provide a
        *                 <code>FilterExpression</code>. A <code>FilterExpression</code> determines which
        *             items within the results should be returned to you. All of the other results are
        *             discarded. </p>
        *         <p> A <code>Query</code> operation always returns a result set. If no matching items are
        *             found, the result set will be empty. Queries that do not return results consume the
        *             minimum number of read capacity units for that type of read operation. </p>
        *         <note>
        *             <p> DynamoDB calculates the number of read capacity units consumed based on item
        *                 size, not on the amount of data that is returned to an application. The number of
        *                 capacity units consumed will be the same whether you request all of the attributes
        *                 (the default behavior) or just some of them (using a projection expression). The
        *                 number will also be the same whether or not you use a <code>FilterExpression</code>.
        *             </p>
        *         </note>
        *         <p>
        *             <code>Query</code> results are always sorted by the sort key value. If the data type of
        *             the sort key is Number, the results are returned in numeric order; otherwise, the
        *             results are returned in order of UTF-8 bytes. By default, the sort order is ascending.
        *             To reverse the order, set the <code>ScanIndexForward</code> parameter to false. </p>
        *         <p> A single <code>Query</code> operation will read up to the maximum number of items set
        *             (if using the <code>Limit</code> parameter) or a maximum of 1 MB of data and then apply
        *             any filtering to the results using <code>FilterExpression</code>. If
        *                 <code>LastEvaluatedKey</code> is present in the response, you will need to paginate
        *             the result set. For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Query.html#Query.Pagination">Paginating
        *                 the Results</a> in the <i>Amazon DynamoDB Developer Guide</i>. </p>
        *         <p>
        *             <code>FilterExpression</code> is applied after a <code>Query</code> finishes, but before
        *             the results are returned. A <code>FilterExpression</code> cannot contain partition key
        *             or sort key attributes. You need to specify those attributes in the
        *                 <code>KeyConditionExpression</code>. </p>
        *         <note>
        *             <p> A <code>Query</code> operation can return an empty result set and a
        *                     <code>LastEvaluatedKey</code> if all the items read for the page of results are
        *                 filtered out. </p>
        *         </note>
        *         <p>You can query a table, a local secondary index, or a global secondary index. For a
        *             query on a table or on a local secondary index, you can set the
        *                 <code>ConsistentRead</code> parameter to <code>true</code> and obtain a strongly
        *             consistent result. Global secondary indexes support eventually consistent reads only, so
        *             do not specify <code>ConsistentRead</code> when querying a global secondary
        *             index.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, QueryCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, QueryCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new QueryCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link QueryCommandInput} for command's `input` shape.
        * @see {@link QueryCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class QueryCommand extends $Command<QueryCommandInput, QueryCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: QueryCommandInput;
            constructor(input: QueryCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<QueryCommandInput, QueryCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/RestoreTableFromBackupCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { RestoreTableFromBackupInput, RestoreTableFromBackupOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface RestoreTableFromBackupCommandInput extends RestoreTableFromBackupInput {
    }
    export interface RestoreTableFromBackupCommandOutput extends RestoreTableFromBackupOutput, __MetadataBearer {
    }
    /**
        * <p>Creates a new table from an existing backup. Any number of users can execute up to 4
        *             concurrent restores (any type of restore) in a given account. </p>
        *         <p>You can call <code>RestoreTableFromBackup</code> at a maximum rate of 10 times per
        *             second.</p>
        *         <p>You must manually set up the following on the restored table:</p>
        *         <ul>
        *             <li>
        *                 <p>Auto scaling policies</p>
        *             </li>
        *             <li>
        *                 <p>IAM policies</p>
        *             </li>
        *             <li>
        *                 <p>Amazon CloudWatch metrics and alarms</p>
        *             </li>
        *             <li>
        *                 <p>Tags</p>
        *             </li>
        *             <li>
        *                 <p>Stream settings</p>
        *             </li>
        *             <li>
        *                 <p>Time to Live (TTL) settings</p>
        *             </li>
        *          </ul>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, RestoreTableFromBackupCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, RestoreTableFromBackupCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new RestoreTableFromBackupCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link RestoreTableFromBackupCommandInput} for command's `input` shape.
        * @see {@link RestoreTableFromBackupCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class RestoreTableFromBackupCommand extends $Command<RestoreTableFromBackupCommandInput, RestoreTableFromBackupCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: RestoreTableFromBackupCommandInput;
            constructor(input: RestoreTableFromBackupCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<RestoreTableFromBackupCommandInput, RestoreTableFromBackupCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/RestoreTableToPointInTimeCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { RestoreTableToPointInTimeInput, RestoreTableToPointInTimeOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface RestoreTableToPointInTimeCommandInput extends RestoreTableToPointInTimeInput {
    }
    export interface RestoreTableToPointInTimeCommandOutput extends RestoreTableToPointInTimeOutput, __MetadataBearer {
    }
    /**
        * <p>Restores the specified table to the specified point in time within
        *                 <code>EarliestRestorableDateTime</code> and <code>LatestRestorableDateTime</code>.
        *             You can restore your table to any point in time during the last 35 days. Any number of
        *             users can execute up to 4 concurrent restores (any type of restore) in a given account. </p>
        *         <p> When you restore using point in time recovery, DynamoDB restores your table data to
        *             the state based on the selected date and time (day:hour:minute:second) to a new table. </p>
        *         <p> Along with data, the following are also included on the new restored table using
        *             point in time recovery: </p>
        *         <ul>
        *             <li>
        *                 <p>Global secondary indexes (GSIs)</p>
        *             </li>
        *             <li>
        *                 <p>Local secondary indexes (LSIs)</p>
        *             </li>
        *             <li>
        *                 <p>Provisioned read and write capacity</p>
        *             </li>
        *             <li>
        *                 <p>Encryption settings</p>
        *                 <important>
        *                     <p> All these settings come from the current settings of the source table at
        *                         the time of restore. </p>
        *                 </important>
        *             </li>
        *          </ul>
        *
        *         <p>You must manually set up the following on the restored table:</p>
        *         <ul>
        *             <li>
        *                 <p>Auto scaling policies</p>
        *             </li>
        *             <li>
        *                 <p>IAM policies</p>
        *             </li>
        *             <li>
        *                 <p>Amazon CloudWatch metrics and alarms</p>
        *             </li>
        *             <li>
        *                 <p>Tags</p>
        *             </li>
        *             <li>
        *                 <p>Stream settings</p>
        *             </li>
        *             <li>
        *                 <p>Time to Live (TTL) settings</p>
        *             </li>
        *             <li>
        *                 <p>Point in time recovery settings</p>
        *             </li>
        *          </ul>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, RestoreTableToPointInTimeCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, RestoreTableToPointInTimeCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new RestoreTableToPointInTimeCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link RestoreTableToPointInTimeCommandInput} for command's `input` shape.
        * @see {@link RestoreTableToPointInTimeCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class RestoreTableToPointInTimeCommand extends $Command<RestoreTableToPointInTimeCommandInput, RestoreTableToPointInTimeCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: RestoreTableToPointInTimeCommandInput;
            constructor(input: RestoreTableToPointInTimeCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<RestoreTableToPointInTimeCommandInput, RestoreTableToPointInTimeCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/ScanCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { ScanInput, ScanOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface ScanCommandInput extends ScanInput {
    }
    export interface ScanCommandOutput extends ScanOutput, __MetadataBearer {
    }
    /**
        * <p>The <code>Scan</code> operation returns one or more items and item attributes by
        *             accessing every item in a table or a secondary index. To have DynamoDB return fewer
        *             items, you can provide a <code>FilterExpression</code> operation.</p>
        *         <p>If the total number of scanned items exceeds the maximum dataset size limit of 1 MB,
        *             the scan stops and results are returned to the user as a <code>LastEvaluatedKey</code>
        *             value to continue the scan in a subsequent operation. The results also include the
        *             number of items exceeding the limit. A scan can result in no table data meeting the
        *             filter criteria. </p>
        *         <p>A single <code>Scan</code> operation reads up to the maximum number of items set (if
        *             using the <code>Limit</code> parameter) or a maximum of 1 MB of data and then apply any
        *             filtering to the results using <code>FilterExpression</code>. If
        *                 <code>LastEvaluatedKey</code> is present in the response, you need to paginate the
        *             result set. For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Scan.html#Scan.Pagination">Paginating the
        *                 Results</a> in the <i>Amazon DynamoDB Developer Guide</i>. </p>
        *         <p>
        *             <code>Scan</code> operations proceed sequentially; however, for faster performance on
        *             a large table or secondary index, applications can request a parallel <code>Scan</code>
        *             operation by providing the <code>Segment</code> and <code>TotalSegments</code>
        *             parameters. For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Scan.html#Scan.ParallelScan">Parallel
        *                 Scan</a> in the <i>Amazon DynamoDB Developer Guide</i>.</p>
        *         <p>
        *             <code>Scan</code> uses eventually consistent reads when accessing the data in a table;
        *             therefore, the result set might not include the changes to data in the table immediately
        *             before the operation began. If you need a consistent copy of the data, as of the time
        *             that the <code>Scan</code> begins, you can set the <code>ConsistentRead</code> parameter
        *             to <code>true</code>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, ScanCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, ScanCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new ScanCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link ScanCommandInput} for command's `input` shape.
        * @see {@link ScanCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class ScanCommand extends $Command<ScanCommandInput, ScanCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: ScanCommandInput;
            constructor(input: ScanCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ScanCommandInput, ScanCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/TagResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { TagResourceInput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface TagResourceCommandInput extends TagResourceInput {
    }
    export interface TagResourceCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Associate a set of tags with an Amazon DynamoDB resource. You can then activate these
        *             user-defined tags so that they appear on the Billing and Cost Management console for
        *             cost allocation tracking. You can call TagResource up to five times per second, per
        *             account. </p>
        *         <p>For an overview on tagging DynamoDB resources, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Tagging.html">Tagging for DynamoDB</a>
        *             in the <i>Amazon DynamoDB Developer Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, TagResourceCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, TagResourceCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new TagResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link TagResourceCommandInput} for command's `input` shape.
        * @see {@link TagResourceCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class TagResourceCommand extends $Command<TagResourceCommandInput, TagResourceCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: TagResourceCommandInput;
            constructor(input: TagResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<TagResourceCommandInput, TagResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/TransactGetItemsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { TransactGetItemsInput, TransactGetItemsOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface TransactGetItemsCommandInput extends TransactGetItemsInput {
    }
    export interface TransactGetItemsCommandOutput extends TransactGetItemsOutput, __MetadataBearer {
    }
    /**
        * <p>
        *             <code>TransactGetItems</code> is a synchronous operation that atomically retrieves
        *             multiple items from one or more tables (but not from indexes) in a single account and
        *             Region. A <code>TransactGetItems</code> call can contain up to 25
        *                 <code>TransactGetItem</code> objects, each of which contains a <code>Get</code>
        *             structure that specifies an item to retrieve from a table in the account and Region. A
        *             call to <code>TransactGetItems</code> cannot retrieve items from tables in more than one
        *                 Amazon Web Services account or Region. The aggregate size of the items in the
        *             transaction cannot exceed 4 MB.</p>
        *         <p>DynamoDB rejects the entire <code>TransactGetItems</code> request if any of
        *             the following is true:</p>
        *         <ul>
        *             <li>
        *                 <p>A conflicting operation is in the process of updating an item to be
        *                     read.</p>
        *             </li>
        *             <li>
        *                 <p>There is insufficient provisioned capacity for the transaction to be
        *                     completed.</p>
        *             </li>
        *             <li>
        *                 <p>There is a user error, such as an invalid data format.</p>
        *             </li>
        *             <li>
        *                 <p>The aggregate size of the items in the transaction cannot exceed 4 MB.</p>
        *             </li>
        *          </ul>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, TransactGetItemsCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, TransactGetItemsCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new TransactGetItemsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link TransactGetItemsCommandInput} for command's `input` shape.
        * @see {@link TransactGetItemsCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class TransactGetItemsCommand extends $Command<TransactGetItemsCommandInput, TransactGetItemsCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: TransactGetItemsCommandInput;
            constructor(input: TransactGetItemsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<TransactGetItemsCommandInput, TransactGetItemsCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/TransactWriteItemsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { TransactWriteItemsInput, TransactWriteItemsOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface TransactWriteItemsCommandInput extends TransactWriteItemsInput {
    }
    export interface TransactWriteItemsCommandOutput extends TransactWriteItemsOutput, __MetadataBearer {
    }
    /**
        * <p>
        *             <code>TransactWriteItems</code> is a synchronous write operation that groups up to 25
        *             action requests. These actions can target items in different tables, but not in
        *             different Amazon Web Services accounts or Regions, and no two actions can target the same
        *             item. For example, you cannot both <code>ConditionCheck</code> and <code>Update</code>
        *             the same item. The aggregate size of the items in the transaction cannot exceed 4
        *             MB.</p>
        *
        *         <p>The actions are completed atomically so that either all of them succeed, or all of
        *             them fail. They are defined by the following objects:</p>
        *
        *         <ul>
        *             <li>
        *                 <p>
        *                   <code>Put</code>   Initiates a <code>PutItem</code>
        *                     operation to write a new item. This structure specifies the primary key of the
        *                     item to be written, the name of the table to write it in, an optional condition
        *                     expression that must be satisfied for the write to succeed, a list of the item's
        *                     attributes, and a field indicating whether to retrieve the item's attributes if
        *                     the condition is not met.</p>
        *             </li>
        *             <li>
        *                 <p>
        *                   <code>Update</code>   Initiates an <code>UpdateItem</code>
        *                     operation to update an existing item. This structure specifies the primary key
        *                     of the item to be updated, the name of the table where it resides, an optional
        *                     condition expression that must be satisfied for the update to succeed, an
        *                     expression that defines one or more attributes to be updated, and a field
        *                     indicating whether to retrieve the item's attributes if the condition is not
        *                     met.</p>
        *             </li>
        *             <li>
        *                 <p>
        *                   <code>Delete</code>   Initiates a <code>DeleteItem</code>
        *                     operation to delete an existing item. This structure specifies the primary key
        *                     of the item to be deleted, the name of the table where it resides, an optional
        *                     condition expression that must be satisfied for the deletion to succeed, and a
        *                     field indicating whether to retrieve the item's attributes if the condition is
        *                     not met.</p>
        *             </li>
        *             <li>
        *                 <p>
        *                   <code>ConditionCheck</code>   Applies a condition to an item
        *                     that is not being modified by the transaction. This structure specifies the
        *                     primary key of the item to be checked, the name of the table where it resides, a
        *                     condition expression that must be satisfied for the transaction to succeed, and
        *                     a field indicating whether to retrieve the item's attributes if the condition is
        *                     not met.</p>
        *             </li>
        *          </ul>
        *
        *         <p>DynamoDB rejects the entire <code>TransactWriteItems</code> request if any of the
        *             following is true:</p>
        *         <ul>
        *             <li>
        *                 <p>A condition in one of the condition expressions is not met.</p>
        *             </li>
        *             <li>
        *                 <p>An ongoing operation is in the process of updating the same item.</p>
        *             </li>
        *             <li>
        *                 <p>There is insufficient provisioned capacity for the transaction to be
        *                     completed.</p>
        *             </li>
        *             <li>
        *                 <p>An item size becomes too large (bigger than 400 KB), a local secondary index
        *                     (LSI) becomes too large, or a similar validation error occurs because of changes
        *                     made by the transaction.</p>
        *             </li>
        *             <li>
        *                 <p>The aggregate size of the items in the transaction exceeds 4 MB.</p>
        *             </li>
        *             <li>
        *                 <p>There is a user error, such as an invalid data format.</p>
        *             </li>
        *          </ul>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, TransactWriteItemsCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, TransactWriteItemsCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new TransactWriteItemsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link TransactWriteItemsCommandInput} for command's `input` shape.
        * @see {@link TransactWriteItemsCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class TransactWriteItemsCommand extends $Command<TransactWriteItemsCommandInput, TransactWriteItemsCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: TransactWriteItemsCommandInput;
            constructor(input: TransactWriteItemsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<TransactWriteItemsCommandInput, TransactWriteItemsCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/UntagResourceCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { UntagResourceInput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface UntagResourceCommandInput extends UntagResourceInput {
    }
    export interface UntagResourceCommandOutput extends __MetadataBearer {
    }
    /**
        * <p>Removes the association of tags from an Amazon DynamoDB resource. You can call
        *                 <code>UntagResource</code> up to five times per second, per account. </p>
        *         <p>For an overview on tagging DynamoDB resources, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Tagging.html">Tagging for DynamoDB</a>
        *             in the <i>Amazon DynamoDB Developer Guide</i>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, UntagResourceCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, UntagResourceCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new UntagResourceCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UntagResourceCommandInput} for command's `input` shape.
        * @see {@link UntagResourceCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class UntagResourceCommand extends $Command<UntagResourceCommandInput, UntagResourceCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: UntagResourceCommandInput;
            constructor(input: UntagResourceCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UntagResourceCommandInput, UntagResourceCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/UpdateContinuousBackupsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { UpdateContinuousBackupsInput, UpdateContinuousBackupsOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface UpdateContinuousBackupsCommandInput extends UpdateContinuousBackupsInput {
    }
    export interface UpdateContinuousBackupsCommandOutput extends UpdateContinuousBackupsOutput, __MetadataBearer {
    }
    /**
        * <p>
        *             <code>UpdateContinuousBackups</code> enables or disables point in time recovery for
        *             the specified table. A successful <code>UpdateContinuousBackups</code> call returns the
        *             current <code>ContinuousBackupsDescription</code>. Continuous backups are
        *                 <code>ENABLED</code> on all tables at table creation. If point in time recovery is
        *             enabled, <code>PointInTimeRecoveryStatus</code> will be set to ENABLED.</p>
        *         <p> Once continuous backups and point in time recovery are enabled, you can restore to
        *             any point in time within <code>EarliestRestorableDateTime</code> and
        *                 <code>LatestRestorableDateTime</code>. </p>
        *         <p>
        *             <code>LatestRestorableDateTime</code> is typically 5 minutes before the current time.
        *             You can restore your table to any point in time during the last 35 days. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, UpdateContinuousBackupsCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, UpdateContinuousBackupsCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new UpdateContinuousBackupsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateContinuousBackupsCommandInput} for command's `input` shape.
        * @see {@link UpdateContinuousBackupsCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class UpdateContinuousBackupsCommand extends $Command<UpdateContinuousBackupsCommandInput, UpdateContinuousBackupsCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: UpdateContinuousBackupsCommandInput;
            constructor(input: UpdateContinuousBackupsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateContinuousBackupsCommandInput, UpdateContinuousBackupsCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/UpdateContributorInsightsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { UpdateContributorInsightsInput, UpdateContributorInsightsOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface UpdateContributorInsightsCommandInput extends UpdateContributorInsightsInput {
    }
    export interface UpdateContributorInsightsCommandOutput extends UpdateContributorInsightsOutput, __MetadataBearer {
    }
    /**
        * <p>Updates the status for contributor insights for a specific table or index. CloudWatch
        *             Contributor Insights for DynamoDB graphs display the partition key and (if applicable)
        *             sort key of frequently accessed items and frequently throttled items in plaintext. If
        *             you require the use of Amazon Web Services Key Management Service (KMS) to encrypt this
        *             tables partition key and sort key data with an Amazon Web Services managed key or
        *             customer managed key, you should not enable CloudWatch Contributor Insights for DynamoDB
        *             for this table.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, UpdateContributorInsightsCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, UpdateContributorInsightsCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new UpdateContributorInsightsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateContributorInsightsCommandInput} for command's `input` shape.
        * @see {@link UpdateContributorInsightsCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class UpdateContributorInsightsCommand extends $Command<UpdateContributorInsightsCommandInput, UpdateContributorInsightsCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: UpdateContributorInsightsCommandInput;
            constructor(input: UpdateContributorInsightsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateContributorInsightsCommandInput, UpdateContributorInsightsCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/UpdateGlobalTableCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { UpdateGlobalTableInput, UpdateGlobalTableOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface UpdateGlobalTableCommandInput extends UpdateGlobalTableInput {
    }
    export interface UpdateGlobalTableCommandOutput extends UpdateGlobalTableOutput, __MetadataBearer {
    }
    /**
        * <p>Adds or removes replicas in the specified global table. The global table must already
        *             exist to be able to use this operation. Any replica to be added must be empty, have the
        *             same name as the global table, have the same key schema, have DynamoDB Streams enabled,
        *             and have the same provisioned and maximum write capacity units.</p>
        *         <note>
        *             <p>Although you can use <code>UpdateGlobalTable</code> to add replicas and remove
        *                 replicas in a single request, for simplicity we recommend that you issue separate
        *                 requests for adding or removing replicas.</p>
        *         </note>
        *         <p> If global secondary indexes are specified, then the following conditions must also be
        *             met: </p>
        *         <ul>
        *             <li>
        *                 <p> The global secondary indexes must have the same name. </p>
        *             </li>
        *             <li>
        *                 <p> The global secondary indexes must have the same hash key and sort key (if
        *                     present). </p>
        *             </li>
        *             <li>
        *                 <p> The global secondary indexes must have the same provisioned and maximum write
        *                     capacity units. </p>
        *             </li>
        *          </ul>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, UpdateGlobalTableCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, UpdateGlobalTableCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new UpdateGlobalTableCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateGlobalTableCommandInput} for command's `input` shape.
        * @see {@link UpdateGlobalTableCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class UpdateGlobalTableCommand extends $Command<UpdateGlobalTableCommandInput, UpdateGlobalTableCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: UpdateGlobalTableCommandInput;
            constructor(input: UpdateGlobalTableCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateGlobalTableCommandInput, UpdateGlobalTableCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/UpdateGlobalTableSettingsCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { UpdateGlobalTableSettingsInput, UpdateGlobalTableSettingsOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface UpdateGlobalTableSettingsCommandInput extends UpdateGlobalTableSettingsInput {
    }
    export interface UpdateGlobalTableSettingsCommandOutput extends UpdateGlobalTableSettingsOutput, __MetadataBearer {
    }
    /**
        * <p>Updates settings for a global table.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, UpdateGlobalTableSettingsCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, UpdateGlobalTableSettingsCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new UpdateGlobalTableSettingsCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateGlobalTableSettingsCommandInput} for command's `input` shape.
        * @see {@link UpdateGlobalTableSettingsCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class UpdateGlobalTableSettingsCommand extends $Command<UpdateGlobalTableSettingsCommandInput, UpdateGlobalTableSettingsCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: UpdateGlobalTableSettingsCommandInput;
            constructor(input: UpdateGlobalTableSettingsCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateGlobalTableSettingsCommandInput, UpdateGlobalTableSettingsCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/UpdateItemCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { UpdateItemInput, UpdateItemOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface UpdateItemCommandInput extends UpdateItemInput {
    }
    export interface UpdateItemCommandOutput extends UpdateItemOutput, __MetadataBearer {
    }
    /**
        * <p>Edits an existing item's attributes, or adds a new item to the table if it does not
        *             already exist. You can put, delete, or add attribute values. You can also perform a
        *             conditional update on an existing item (insert a new attribute name-value pair if it
        *             doesn't exist, or replace an existing name-value pair if it has certain expected
        *             attribute values).</p>
        *         <p>You can also return the item's attribute values in the same <code>UpdateItem</code>
        *             operation using the <code>ReturnValues</code> parameter.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, UpdateItemCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, UpdateItemCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new UpdateItemCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateItemCommandInput} for command's `input` shape.
        * @see {@link UpdateItemCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class UpdateItemCommand extends $Command<UpdateItemCommandInput, UpdateItemCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: UpdateItemCommandInput;
            constructor(input: UpdateItemCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateItemCommandInput, UpdateItemCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/UpdateTableCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { UpdateTableInput, UpdateTableOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface UpdateTableCommandInput extends UpdateTableInput {
    }
    export interface UpdateTableCommandOutput extends UpdateTableOutput, __MetadataBearer {
    }
    /**
        * <p>Modifies the provisioned throughput settings, global secondary indexes, or DynamoDB
        *             Streams settings for a given table.</p>
        *         <p>You can only perform one of the following operations at once:</p>
        *         <ul>
        *             <li>
        *                 <p>Modify the provisioned throughput settings of the table.</p>
        *             </li>
        *             <li>
        *                 <p>Remove a global secondary index from the table.</p>
        *             </li>
        *             <li>
        *                 <p>Create a new global secondary index on the table. After the index begins
        *                     backfilling, you can use <code>UpdateTable</code> to perform other
        *                     operations.</p>
        *             </li>
        *          </ul>
        *         <p>
        *             <code>UpdateTable</code> is an asynchronous operation; while it is executing, the table
        *             status changes from <code>ACTIVE</code> to <code>UPDATING</code>. While it is
        *                 <code>UPDATING</code>, you cannot issue another <code>UpdateTable</code> request.
        *             When the table returns to the <code>ACTIVE</code> state, the <code>UpdateTable</code>
        *             operation is complete.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, UpdateTableCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, UpdateTableCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new UpdateTableCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateTableCommandInput} for command's `input` shape.
        * @see {@link UpdateTableCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class UpdateTableCommand extends $Command<UpdateTableCommandInput, UpdateTableCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: UpdateTableCommandInput;
            constructor(input: UpdateTableCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateTableCommandInput, UpdateTableCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/UpdateTableReplicaAutoScalingCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { UpdateTableReplicaAutoScalingInput, UpdateTableReplicaAutoScalingOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface UpdateTableReplicaAutoScalingCommandInput extends UpdateTableReplicaAutoScalingInput {
    }
    export interface UpdateTableReplicaAutoScalingCommandOutput extends UpdateTableReplicaAutoScalingOutput, __MetadataBearer {
    }
    /**
        * <p>Updates auto scaling settings on your global tables at once.</p>
        *         <note>
        *             <p>This operation only applies to <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.V2.html">Version
        *                     2019.11.21</a> of global tables.</p>
        *         </note>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, UpdateTableReplicaAutoScalingCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, UpdateTableReplicaAutoScalingCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new UpdateTableReplicaAutoScalingCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateTableReplicaAutoScalingCommandInput} for command's `input` shape.
        * @see {@link UpdateTableReplicaAutoScalingCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class UpdateTableReplicaAutoScalingCommand extends $Command<UpdateTableReplicaAutoScalingCommandInput, UpdateTableReplicaAutoScalingCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: UpdateTableReplicaAutoScalingCommandInput;
            constructor(input: UpdateTableReplicaAutoScalingCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateTableReplicaAutoScalingCommandInput, UpdateTableReplicaAutoScalingCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/UpdateTimeToLiveCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DynamoDBClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient";
    import { UpdateTimeToLiveInput, UpdateTimeToLiveOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0";
    export interface UpdateTimeToLiveCommandInput extends UpdateTimeToLiveInput {
    }
    export interface UpdateTimeToLiveCommandOutput extends UpdateTimeToLiveOutput, __MetadataBearer {
    }
    /**
        * <p>The <code>UpdateTimeToLive</code> method enables or disables Time to Live (TTL) for
        *             the specified table. A successful <code>UpdateTimeToLive</code> call returns the current
        *                 <code>TimeToLiveSpecification</code>. It can take up to one hour for the change to
        *             fully process. Any additional <code>UpdateTimeToLive</code> calls for the same table
        *             during this one hour duration result in a <code>ValidationException</code>. </p>
        *         <p>TTL compares the current time in epoch time format to the time stored in the TTL
        *             attribute of an item. If the epoch time value stored in the attribute is less than the
        *             current time, the item is marked as expired and subsequently deleted.</p>
        *         <note>
        *             <p> The epoch time format is the number of seconds elapsed since 12:00:00 AM January
        *                 1, 1970 UTC. </p>
        *         </note>
        *         <p>DynamoDB deletes expired items on a best-effort basis to ensure availability of
        *             throughput for other data operations. </p>
        *         <important>
        *             <p>DynamoDB typically deletes expired items within two days of expiration. The exact
        *                 duration within which an item gets deleted after expiration is specific to the
        *                 nature of the workload. Items that have expired and not been deleted will still show
        *                 up in reads, queries, and scans.</p>
        *         </important>
        *         <p>As items are deleted, they are removed from any local secondary index and global
        *             secondary index immediately in the same eventually consistent way as a standard delete
        *             operation.</p>
        *         <p>For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/TTL.html">Time To Live</a> in the
        *             Amazon DynamoDB Developer Guide. </p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { DynamoDBClient, UpdateTimeToLiveCommand } from "@aws-sdk/client-dynamodb"; // ES Modules import
        * // const { DynamoDBClient, UpdateTimeToLiveCommand } = require("@aws-sdk/client-dynamodb"); // CommonJS import
        * const client = new DynamoDBClient(config);
        * const command = new UpdateTimeToLiveCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link UpdateTimeToLiveCommandInput} for command's `input` shape.
        * @see {@link UpdateTimeToLiveCommandOutput} for command's `response` shape.
        * @see {@link DynamoDBClientResolvedConfig | config} for DynamoDBClient's `config` shape.
        *
        */
    export class UpdateTimeToLiveCommand extends $Command<UpdateTimeToLiveCommandInput, UpdateTimeToLiveCommandOutput, DynamoDBClientResolvedConfig> {
            readonly input: UpdateTimeToLiveCommandInput;
            constructor(input: UpdateTimeToLiveCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateTimeToLiveCommandInput, UpdateTimeToLiveCommandOutput>;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/DynamoDBClient' {
    import { EndpointsInputConfig, EndpointsResolvedConfig, RegionInputConfig, RegionResolvedConfig } from "@aws-sdk/config-resolver";
    import { EndpointDiscoveryInputConfig, EndpointDiscoveryResolvedConfig } from "@aws-sdk/middleware-endpoint-discovery";
    import { HostHeaderInputConfig, HostHeaderResolvedConfig } from "@aws-sdk/middleware-host-header";
    import { RetryInputConfig, RetryResolvedConfig } from "@aws-sdk/middleware-retry";
    import { AwsAuthInputConfig, AwsAuthResolvedConfig } from "@aws-sdk/middleware-signing";
    import { UserAgentInputConfig, UserAgentResolvedConfig } from "@aws-sdk/middleware-user-agent";
    import { HttpHandler as __HttpHandler } from "@aws-sdk/protocol-http";
    import { Client as __Client, DefaultsMode, SmithyConfiguration as __SmithyConfiguration, SmithyResolvedConfiguration as __SmithyResolvedConfiguration } from "@aws-sdk/smithy-client";
    import { BodyLengthCalculator as __BodyLengthCalculator, Credentials as __Credentials, Decoder as __Decoder, Encoder as __Encoder, HashConstructor as __HashConstructor, HttpHandlerOptions as __HttpHandlerOptions, Logger as __Logger, Provider as __Provider, Provider, RegionInfoProvider, StreamCollector as __StreamCollector, UrlParser as __UrlParser, UserAgent as __UserAgent } from "@aws-sdk/types";
    import { BatchExecuteStatementCommandInput, BatchExecuteStatementCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/BatchExecuteStatementCommand";
    import { BatchGetItemCommandInput, BatchGetItemCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/BatchGetItemCommand";
    import { BatchWriteItemCommandInput, BatchWriteItemCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/BatchWriteItemCommand";
    import { CreateBackupCommandInput, CreateBackupCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/CreateBackupCommand";
    import { CreateGlobalTableCommandInput, CreateGlobalTableCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/CreateGlobalTableCommand";
    import { CreateTableCommandInput, CreateTableCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/CreateTableCommand";
    import { DeleteBackupCommandInput, DeleteBackupCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/DeleteBackupCommand";
    import { DeleteItemCommandInput, DeleteItemCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/DeleteItemCommand";
    import { DeleteTableCommandInput, DeleteTableCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/DeleteTableCommand";
    import { DescribeBackupCommandInput, DescribeBackupCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/DescribeBackupCommand";
    import { DescribeContinuousBackupsCommandInput, DescribeContinuousBackupsCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/DescribeContinuousBackupsCommand";
    import { DescribeContributorInsightsCommandInput, DescribeContributorInsightsCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/DescribeContributorInsightsCommand";
    import { DescribeEndpointsCommandInput, DescribeEndpointsCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/DescribeEndpointsCommand";
    import { DescribeExportCommandInput, DescribeExportCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/DescribeExportCommand";
    import { DescribeGlobalTableCommandInput, DescribeGlobalTableCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/DescribeGlobalTableCommand";
    import { DescribeGlobalTableSettingsCommandInput, DescribeGlobalTableSettingsCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/DescribeGlobalTableSettingsCommand";
    import { DescribeKinesisStreamingDestinationCommandInput, DescribeKinesisStreamingDestinationCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/DescribeKinesisStreamingDestinationCommand";
    import { DescribeLimitsCommandInput, DescribeLimitsCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/DescribeLimitsCommand";
    import { DescribeTableCommandInput, DescribeTableCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/DescribeTableCommand";
    import { DescribeTableReplicaAutoScalingCommandInput, DescribeTableReplicaAutoScalingCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/DescribeTableReplicaAutoScalingCommand";
    import { DescribeTimeToLiveCommandInput, DescribeTimeToLiveCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/DescribeTimeToLiveCommand";
    import { DisableKinesisStreamingDestinationCommandInput, DisableKinesisStreamingDestinationCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/DisableKinesisStreamingDestinationCommand";
    import { EnableKinesisStreamingDestinationCommandInput, EnableKinesisStreamingDestinationCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/EnableKinesisStreamingDestinationCommand";
    import { ExecuteStatementCommandInput, ExecuteStatementCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/ExecuteStatementCommand";
    import { ExecuteTransactionCommandInput, ExecuteTransactionCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/ExecuteTransactionCommand";
    import { ExportTableToPointInTimeCommandInput, ExportTableToPointInTimeCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/ExportTableToPointInTimeCommand";
    import { GetItemCommandInput, GetItemCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/GetItemCommand";
    import { ListBackupsCommandInput, ListBackupsCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/ListBackupsCommand";
    import { ListContributorInsightsCommandInput, ListContributorInsightsCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/ListContributorInsightsCommand";
    import { ListExportsCommandInput, ListExportsCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/ListExportsCommand";
    import { ListGlobalTablesCommandInput, ListGlobalTablesCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/ListGlobalTablesCommand";
    import { ListTablesCommandInput, ListTablesCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/ListTablesCommand";
    import { ListTagsOfResourceCommandInput, ListTagsOfResourceCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/ListTagsOfResourceCommand";
    import { PutItemCommandInput, PutItemCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/PutItemCommand";
    import { QueryCommandInput, QueryCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/QueryCommand";
    import { RestoreTableFromBackupCommandInput, RestoreTableFromBackupCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/RestoreTableFromBackupCommand";
    import { RestoreTableToPointInTimeCommandInput, RestoreTableToPointInTimeCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/RestoreTableToPointInTimeCommand";
    import { ScanCommandInput, ScanCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/ScanCommand";
    import { TagResourceCommandInput, TagResourceCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/TagResourceCommand";
    import { TransactGetItemsCommandInput, TransactGetItemsCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/TransactGetItemsCommand";
    import { TransactWriteItemsCommandInput, TransactWriteItemsCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/TransactWriteItemsCommand";
    import { UntagResourceCommandInput, UntagResourceCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/UntagResourceCommand";
    import { UpdateContinuousBackupsCommandInput, UpdateContinuousBackupsCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/UpdateContinuousBackupsCommand";
    import { UpdateContributorInsightsCommandInput, UpdateContributorInsightsCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/UpdateContributorInsightsCommand";
    import { UpdateGlobalTableCommandInput, UpdateGlobalTableCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/UpdateGlobalTableCommand";
    import { UpdateGlobalTableSettingsCommandInput, UpdateGlobalTableSettingsCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/UpdateGlobalTableSettingsCommand";
    import { UpdateItemCommandInput, UpdateItemCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/UpdateItemCommand";
    import { UpdateTableCommandInput, UpdateTableCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/UpdateTableCommand";
    import { UpdateTableReplicaAutoScalingCommandInput, UpdateTableReplicaAutoScalingCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/UpdateTableReplicaAutoScalingCommand";
    import { UpdateTimeToLiveCommandInput, UpdateTimeToLiveCommandOutput } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/commands/UpdateTimeToLiveCommand";
    export type ServiceInputTypes = BatchExecuteStatementCommandInput | BatchGetItemCommandInput | BatchWriteItemCommandInput | CreateBackupCommandInput | CreateGlobalTableCommandInput | CreateTableCommandInput | DeleteBackupCommandInput | DeleteItemCommandInput | DeleteTableCommandInput | DescribeBackupCommandInput | DescribeContinuousBackupsCommandInput | DescribeContributorInsightsCommandInput | DescribeEndpointsCommandInput | DescribeExportCommandInput | DescribeGlobalTableCommandInput | DescribeGlobalTableSettingsCommandInput | DescribeKinesisStreamingDestinationCommandInput | DescribeLimitsCommandInput | DescribeTableCommandInput | DescribeTableReplicaAutoScalingCommandInput | DescribeTimeToLiveCommandInput | DisableKinesisStreamingDestinationCommandInput | EnableKinesisStreamingDestinationCommandInput | ExecuteStatementCommandInput | ExecuteTransactionCommandInput | ExportTableToPointInTimeCommandInput | GetItemCommandInput | ListBackupsCommandInput | ListContributorInsightsCommandInput | ListExportsCommandInput | ListGlobalTablesCommandInput | ListTablesCommandInput | ListTagsOfResourceCommandInput | PutItemCommandInput | QueryCommandInput | RestoreTableFromBackupCommandInput | RestoreTableToPointInTimeCommandInput | ScanCommandInput | TagResourceCommandInput | TransactGetItemsCommandInput | TransactWriteItemsCommandInput | UntagResourceCommandInput | UpdateContinuousBackupsCommandInput | UpdateContributorInsightsCommandInput | UpdateGlobalTableCommandInput | UpdateGlobalTableSettingsCommandInput | UpdateItemCommandInput | UpdateTableCommandInput | UpdateTableReplicaAutoScalingCommandInput | UpdateTimeToLiveCommandInput;
    export type ServiceOutputTypes = BatchExecuteStatementCommandOutput | BatchGetItemCommandOutput | BatchWriteItemCommandOutput | CreateBackupCommandOutput | CreateGlobalTableCommandOutput | CreateTableCommandOutput | DeleteBackupCommandOutput | DeleteItemCommandOutput | DeleteTableCommandOutput | DescribeBackupCommandOutput | DescribeContinuousBackupsCommandOutput | DescribeContributorInsightsCommandOutput | DescribeEndpointsCommandOutput | DescribeExportCommandOutput | DescribeGlobalTableCommandOutput | DescribeGlobalTableSettingsCommandOutput | DescribeKinesisStreamingDestinationCommandOutput | DescribeLimitsCommandOutput | DescribeTableCommandOutput | DescribeTableReplicaAutoScalingCommandOutput | DescribeTimeToLiveCommandOutput | DisableKinesisStreamingDestinationCommandOutput | EnableKinesisStreamingDestinationCommandOutput | ExecuteStatementCommandOutput | ExecuteTransactionCommandOutput | ExportTableToPointInTimeCommandOutput | GetItemCommandOutput | ListBackupsCommandOutput | ListContributorInsightsCommandOutput | ListExportsCommandOutput | ListGlobalTablesCommandOutput | ListTablesCommandOutput | ListTagsOfResourceCommandOutput | PutItemCommandOutput | QueryCommandOutput | RestoreTableFromBackupCommandOutput | RestoreTableToPointInTimeCommandOutput | ScanCommandOutput | TagResourceCommandOutput | TransactGetItemsCommandOutput | TransactWriteItemsCommandOutput | UntagResourceCommandOutput | UpdateContinuousBackupsCommandOutput | UpdateContributorInsightsCommandOutput | UpdateGlobalTableCommandOutput | UpdateGlobalTableSettingsCommandOutput | UpdateItemCommandOutput | UpdateTableCommandOutput | UpdateTableReplicaAutoScalingCommandOutput | UpdateTimeToLiveCommandOutput;
    export interface ClientDefaults extends Partial<__SmithyResolvedConfiguration<__HttpHandlerOptions>> {
            /**
                * The HTTP handler to use. Fetch in browser and Https in Nodejs.
                */
            requestHandler?: __HttpHandler;
            /**
                * A constructor for a class implementing the {@link __Hash} interface
                * that computes the SHA-256 HMAC or checksum of a string or binary buffer.
                * @internal
                */
            sha256?: __HashConstructor;
            /**
                * The function that will be used to convert strings into HTTP endpoints.
                * @internal
                */
            urlParser?: __UrlParser;
            /**
                * A function that can calculate the length of a request body.
                * @internal
                */
            bodyLengthChecker?: __BodyLengthCalculator;
            /**
                * A function that converts a stream into an array of bytes.
                * @internal
                */
            streamCollector?: __StreamCollector;
            /**
                * The function that will be used to convert a base64-encoded string to a byte array.
                * @internal
                */
            base64Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a base64-encoded string.
                * @internal
                */
            base64Encoder?: __Encoder;
            /**
                * The function that will be used to convert a UTF8-encoded string to a byte array.
                * @internal
                */
            utf8Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a UTF-8 encoded string.
                * @internal
                */
            utf8Encoder?: __Encoder;
            /**
                * The runtime environment.
                * @internal
                */
            runtime?: string;
            /**
                * Disable dyanamically changing the endpoint of the client based on the hostPrefix
                * trait of an operation.
                */
            disableHostPrefix?: boolean;
            /**
                * Value for how many times a request will be made at most in case of retry.
                */
            maxAttempts?: number | __Provider<number>;
            /**
                * Specifies which retry algorithm to use.
                */
            retryMode?: string | __Provider<string>;
            /**
                * Optional logger for logging debug/info/warn/error.
                */
            logger?: __Logger;
            /**
                * Enables IPv6/IPv4 dualstack endpoint.
                */
            useDualstackEndpoint?: boolean | __Provider<boolean>;
            /**
                * Enables FIPS compatible endpoints.
                */
            useFipsEndpoint?: boolean | __Provider<boolean>;
            /**
                * Unique service identifier.
                * @internal
                */
            serviceId?: string;
            /**
                * The AWS region to which this client will send requests
                */
            region?: string | __Provider<string>;
            /**
                * Default credentials provider; Not available in browser runtime.
                * @internal
                */
            credentialDefaultProvider?: (input: any) => __Provider<__Credentials>;
            /**
                * Fetch related hostname, signing name or signing region with given region.
                * @internal
                */
            regionInfoProvider?: RegionInfoProvider;
            /**
                * The provider populating default tracking information to be sent with `user-agent`, `x-amz-user-agent` header
                * @internal
                */
            defaultUserAgentProvider?: Provider<__UserAgent>;
            /**
                * The provider which populates default for endpointDiscoveryEnabled configuration, if it's
                * not passed during client creation.
                * @internal
                */
            endpointDiscoveryEnabledProvider?: __Provider<boolean | undefined>;
            /**
                * The {@link DefaultsMode} that will be used to determine how certain default configuration options are resolved in the SDK.
                */
            defaultsMode?: DefaultsMode | Provider<DefaultsMode>;
    }
    type DynamoDBClientConfigType = Partial<__SmithyConfiguration<__HttpHandlerOptions>> & ClientDefaults & RegionInputConfig & EndpointsInputConfig & RetryInputConfig & HostHeaderInputConfig & AwsAuthInputConfig & UserAgentInputConfig & EndpointDiscoveryInputConfig;
    /**
        * The configuration interface of DynamoDBClient class constructor that set the region, credentials and other options.
        */
    export interface DynamoDBClientConfig extends DynamoDBClientConfigType {
    }
    type DynamoDBClientResolvedConfigType = __SmithyResolvedConfiguration<__HttpHandlerOptions> & Required<ClientDefaults> & RegionResolvedConfig & EndpointsResolvedConfig & RetryResolvedConfig & HostHeaderResolvedConfig & AwsAuthResolvedConfig & UserAgentResolvedConfig & EndpointDiscoveryResolvedConfig;
    /**
        * The resolved configuration interface of DynamoDBClient class. This is resolved and normalized from the {@link DynamoDBClientConfig | constructor configuration interface}.
        */
    export interface DynamoDBClientResolvedConfig extends DynamoDBClientResolvedConfigType {
    }
    /**
        * <fullname>Amazon DynamoDB</fullname>
        *
        *         <p>Amazon DynamoDB is a fully managed NoSQL database service that provides fast
        *             and predictable performance with seamless scalability. DynamoDB lets you
        *             offload the administrative burdens of operating and scaling a distributed database, so
        *             that you don't have to worry about hardware provisioning, setup and configuration,
        *             replication, software patching, or cluster scaling.</p>
        *
        *         <p>With DynamoDB, you can create database tables that can store and retrieve
        *             any amount of data, and serve any level of request traffic. You can scale up or scale
        *             down your tables' throughput capacity without downtime or performance degradation, and
        *             use the Amazon Web Services Management Console to monitor resource utilization and performance
        *             metrics.</p>
        *
        *         <p>DynamoDB automatically spreads the data and traffic for your tables over
        *             a sufficient number of servers to handle your throughput and storage requirements, while
        *             maintaining consistent and fast performance. All of your data is stored on solid state
        *             disks (SSDs) and automatically replicated across multiple Availability Zones in an
        *                 Amazon Web Services Region, providing built-in high availability and data
        *             durability.</p>
        */
    export class DynamoDBClient extends __Client<__HttpHandlerOptions, ServiceInputTypes, ServiceOutputTypes, DynamoDBClientResolvedConfig> {
            /**
                * The resolved configuration of DynamoDBClient class. This is resolved and normalized from the {@link DynamoDBClientConfig | constructor configuration interface}.
                */
            readonly config: DynamoDBClientResolvedConfig;
            constructor(configuration: DynamoDBClientConfig);
            /**
                * Destroy underlying resources, like sockets. It's usually not necessary to do this.
                * However in Node.js, it's best to explicitly shut down the client's agent when it is no longer needed.
                * Otherwise, sockets might stay open for quite a long time before the server terminates them.
                */
            destroy(): void;
    }
    export {};
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/models_0' {
    import { ExceptionOptionType as __ExceptionOptionType } from "@aws-sdk/smithy-client";
    import { DynamoDBServiceException as __BaseException } from "@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/DynamoDBServiceException";
    /**
        * <p>Contains details of a table archival operation.</p>
        */
    export interface ArchivalSummary {
            /**
                * <p>The date and time when table archival was initiated by DynamoDB, in UNIX epoch time
                *             format.</p>
                */
            ArchivalDateTime?: Date;
            /**
                * <p>The reason DynamoDB archived the table. Currently, the only possible value is:</p>
                *
                *         <ul>
                *             <li>
                *                 <p>
                *                   <code>INACCESSIBLE_ENCRYPTION_CREDENTIALS</code> - The table was archived due
                *                     to the table's KMS key being inaccessible for more than seven
                *                     days. An On-Demand backup was created at the archival time.</p>
                *             </li>
                *          </ul>
                */
            ArchivalReason?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of the backup the table was archived to, when
                *             applicable in the archival reason. If you wish to restore this backup to the same table
                *             name, you will need to delete the original table.</p>
                */
            ArchivalBackupArn?: string;
    }
    export namespace ArchivalSummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ArchivalSummary) => any;
    }
    export type AttributeAction = "ADD" | "DELETE" | "PUT";
    export type ScalarAttributeType = "B" | "N" | "S";
    /**
        * <p>Represents an attribute for describing the key schema for the table and
        *             indexes.</p>
        */
    export interface AttributeDefinition {
            /**
                * <p>A name for the attribute.</p>
                */
            AttributeName: string | undefined;
            /**
                * <p>The data type for the attribute, where:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>S</code> - the attribute is of type String</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>N</code> - the attribute is of type Number</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>B</code> - the attribute is of type Binary</p>
                *             </li>
                *          </ul>
                */
            AttributeType: ScalarAttributeType | string | undefined;
    }
    export namespace AttributeDefinition {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AttributeDefinition) => any;
    }
    /**
        * <p>Represents the properties of a target tracking scaling policy.</p>
        */
    export interface AutoScalingTargetTrackingScalingPolicyConfigurationDescription {
            /**
                * <p>Indicates whether scale in by the target tracking policy is disabled. If the value is
                *             true, scale in is disabled and the target tracking policy won't remove capacity from the
                *             scalable resource. Otherwise, scale in is enabled and the target tracking policy can
                *             remove capacity from the scalable resource. The default value is false.</p>
                */
            DisableScaleIn?: boolean;
            /**
                * <p>The amount of time, in seconds, after a scale in activity completes before another
                *             scale in activity can start. The cooldown period is used to block subsequent scale in
                *             requests until it has expired. You should scale in conservatively to protect your
                *             application's availability. However, if another alarm triggers a scale out policy during
                *             the cooldown period after a scale-in, application auto scaling scales out your scalable
                *             target immediately. </p>
                */
            ScaleInCooldown?: number;
            /**
                * <p>The amount of time, in seconds, after a scale out activity completes before another
                *             scale out activity can start. While the cooldown period is in effect, the capacity that
                *             has been added by the previous scale out event that initiated the cooldown is calculated
                *             as part of the desired capacity for the next scale out. You should continuously (but not
                *             excessively) scale out.</p>
                */
            ScaleOutCooldown?: number;
            /**
                * <p>The target value for the metric. The range is 8.515920e-109 to 1.174271e+108 (Base 10)
                *             or 2e-360 to 2e360 (Base 2).</p>
                */
            TargetValue: number | undefined;
    }
    export namespace AutoScalingTargetTrackingScalingPolicyConfigurationDescription {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AutoScalingTargetTrackingScalingPolicyConfigurationDescription) => any;
    }
    /**
        * <p>Represents the properties of the scaling policy.</p>
        */
    export interface AutoScalingPolicyDescription {
            /**
                * <p>The name of the scaling policy.</p>
                */
            PolicyName?: string;
            /**
                * <p>Represents a target tracking scaling policy configuration.</p>
                */
            TargetTrackingScalingPolicyConfiguration?: AutoScalingTargetTrackingScalingPolicyConfigurationDescription;
    }
    export namespace AutoScalingPolicyDescription {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AutoScalingPolicyDescription) => any;
    }
    /**
        * <p>Represents the settings of a target tracking scaling policy that will be
        *             modified.</p>
        */
    export interface AutoScalingTargetTrackingScalingPolicyConfigurationUpdate {
            /**
                * <p>Indicates whether scale in by the target tracking policy is disabled. If the value is
                *             true, scale in is disabled and the target tracking policy won't remove capacity from the
                *             scalable resource. Otherwise, scale in is enabled and the target tracking policy can
                *             remove capacity from the scalable resource. The default value is false.</p>
                */
            DisableScaleIn?: boolean;
            /**
                * <p>The amount of time, in seconds, after a scale in activity completes before another
                *             scale in activity can start. The cooldown period is used to block subsequent scale in
                *             requests until it has expired. You should scale in conservatively to protect your
                *             application's availability. However, if another alarm triggers a scale out policy during
                *             the cooldown period after a scale-in, application auto scaling scales out your scalable
                *             target immediately. </p>
                */
            ScaleInCooldown?: number;
            /**
                * <p>The amount of time, in seconds, after a scale out activity completes before another
                *             scale out activity can start. While the cooldown period is in effect, the capacity that
                *             has been added by the previous scale out event that initiated the cooldown is calculated
                *             as part of the desired capacity for the next scale out. You should continuously (but not
                *             excessively) scale out.</p>
                */
            ScaleOutCooldown?: number;
            /**
                * <p>The target value for the metric. The range is 8.515920e-109 to 1.174271e+108 (Base 10)
                *             or 2e-360 to 2e360 (Base 2).</p>
                */
            TargetValue: number | undefined;
    }
    export namespace AutoScalingTargetTrackingScalingPolicyConfigurationUpdate {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AutoScalingTargetTrackingScalingPolicyConfigurationUpdate) => any;
    }
    /**
        * <p>Represents the auto scaling policy to be modified.</p>
        */
    export interface AutoScalingPolicyUpdate {
            /**
                * <p>The name of the scaling policy.</p>
                */
            PolicyName?: string;
            /**
                * <p>Represents a target tracking scaling policy configuration.</p>
                */
            TargetTrackingScalingPolicyConfiguration: AutoScalingTargetTrackingScalingPolicyConfigurationUpdate | undefined;
    }
    export namespace AutoScalingPolicyUpdate {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AutoScalingPolicyUpdate) => any;
    }
    /**
        * <p>Represents the auto scaling settings for a global table or global secondary
        *             index.</p>
        */
    export interface AutoScalingSettingsDescription {
            /**
                * <p>The minimum capacity units that a global table or global secondary index should be
                *             scaled down to.</p>
                */
            MinimumUnits?: number;
            /**
                * <p>The maximum capacity units that a global table or global secondary index should be
                *             scaled up to.</p>
                */
            MaximumUnits?: number;
            /**
                * <p>Disabled auto scaling for this global table or global secondary index.</p>
                */
            AutoScalingDisabled?: boolean;
            /**
                * <p>Role ARN used for configuring the auto scaling policy.</p>
                */
            AutoScalingRoleArn?: string;
            /**
                * <p>Information about the scaling policies.</p>
                */
            ScalingPolicies?: AutoScalingPolicyDescription[];
    }
    export namespace AutoScalingSettingsDescription {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AutoScalingSettingsDescription) => any;
    }
    /**
        * <p>Represents the auto scaling settings to be modified for a global table or global
        *             secondary index.</p>
        */
    export interface AutoScalingSettingsUpdate {
            /**
                * <p>The minimum capacity units that a global table or global secondary index should be
                *             scaled down to.</p>
                */
            MinimumUnits?: number;
            /**
                * <p>The maximum capacity units that a global table or global secondary index should be
                *             scaled up to.</p>
                */
            MaximumUnits?: number;
            /**
                * <p>Disabled auto scaling for this global table or global secondary index.</p>
                */
            AutoScalingDisabled?: boolean;
            /**
                * <p>Role ARN used for configuring auto scaling policy.</p>
                */
            AutoScalingRoleArn?: string;
            /**
                * <p>The scaling policy to apply for scaling target global table or global secondary index
                *             capacity units.</p>
                */
            ScalingPolicyUpdate?: AutoScalingPolicyUpdate;
    }
    export namespace AutoScalingSettingsUpdate {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AutoScalingSettingsUpdate) => any;
    }
    export type BackupStatus = "AVAILABLE" | "CREATING" | "DELETED";
    export enum BackupType {
            AWS_BACKUP = "AWS_BACKUP",
            SYSTEM = "SYSTEM",
            USER = "USER"
    }
    /**
        * <p>Contains the details of the backup created for the table.</p>
        */
    export interface BackupDetails {
            /**
                * <p>ARN associated with the backup.</p>
                */
            BackupArn: string | undefined;
            /**
                * <p>Name of the requested backup.</p>
                */
            BackupName: string | undefined;
            /**
                * <p>Size of the backup in bytes. DynamoDB updates this value approximately every six hours.
                *          Recent changes might not be reflected in this value.</p>
                */
            BackupSizeBytes?: number;
            /**
                * <p>Backup can be in one of the following states: CREATING, ACTIVE, DELETED. </p>
                */
            BackupStatus: BackupStatus | string | undefined;
            /**
                * <p>BackupType:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>USER</code> - You create and manage these using the on-demand backup
                *                     feature.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>SYSTEM</code> - If you delete a table with point-in-time recovery enabled,
                *                     a <code>SYSTEM</code> backup is automatically created and is retained for 35
                *                     days (at no additional cost). System backups allow you to restore the deleted
                *                     table to the state it was in just before the point of deletion. </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>AWS_BACKUP</code> - On-demand backup created by you from Backup service.</p>
                *             </li>
                *          </ul>
                */
            BackupType: BackupType | string | undefined;
            /**
                * <p>Time at which the backup was created. This is the request time of the backup. </p>
                */
            BackupCreationDateTime: Date | undefined;
            /**
                * <p>Time at which the automatic on-demand backup created by DynamoDB will
                *             expire. This <code>SYSTEM</code> on-demand backup expires automatically 35 days after
                *             its creation.</p>
                */
            BackupExpiryDateTime?: Date;
    }
    export namespace BackupDetails {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BackupDetails) => any;
    }
    export type BillingMode = "PAY_PER_REQUEST" | "PROVISIONED";
    export type KeyType = "HASH" | "RANGE";
    /**
        * <p>Represents <i>a single element</i> of a key schema. A key schema
        *             specifies the attributes that make up the primary key of a table, or the key attributes
        *             of an index.</p>
        *         <p>A <code>KeySchemaElement</code> represents exactly one attribute of the primary key.
        *             For example, a simple primary key would be represented by one
        *                 <code>KeySchemaElement</code> (for the partition key). A composite primary key would
        *             require one <code>KeySchemaElement</code> for the partition key, and another
        *                 <code>KeySchemaElement</code> for the sort key.</p>
        *         <p>A <code>KeySchemaElement</code> must be a scalar, top-level attribute (not a nested
        *             attribute). The data type must be one of String, Number, or Binary. The attribute cannot
        *             be nested within a List or a Map.</p>
        */
    export interface KeySchemaElement {
            /**
                * <p>The name of a key attribute.</p>
                */
            AttributeName: string | undefined;
            /**
                * <p>The role that this key attribute will assume:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>HASH</code> - partition key</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>RANGE</code> - sort key</p>
                *             </li>
                *          </ul>
                *         <note>
                *             <p>The partition key of an item is also known as its <i>hash
                *                     attribute</i>. The term "hash attribute" derives from DynamoDB's usage of an internal hash function to evenly distribute data items across
                *                 partitions, based on their partition key values.</p>
                *             <p>The sort key of an item is also known as its <i>range attribute</i>.
                *                 The term "range attribute" derives from the way DynamoDB stores items with
                *                 the same partition key physically close together, in sorted order by the sort key
                *                 value.</p>
                *         </note>
                */
            KeyType: KeyType | string | undefined;
    }
    export namespace KeySchemaElement {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: KeySchemaElement) => any;
    }
    /**
        * <p>Represents the provisioned throughput settings for a specified table or index. The
        *             settings can be modified using the <code>UpdateTable</code> operation.</p>
        *         <p>For current minimum and maximum provisioned throughput values, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html">Service,
        *                 Account, and Table Quotas</a> in the <i>Amazon DynamoDB Developer
        *                 Guide</i>.</p>
        */
    export interface ProvisionedThroughput {
            /**
                * <p>The maximum number of strongly consistent reads consumed per second before DynamoDB
                *             returns a <code>ThrottlingException</code>. For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html#ProvisionedThroughput">Specifying Read and Write Requirements</a> in the <i>Amazon DynamoDB
                *                 Developer Guide</i>.</p>
                *         <p>If read/write capacity mode is <code>PAY_PER_REQUEST</code> the value is set to
                *             0.</p>
                */
            ReadCapacityUnits: number | undefined;
            /**
                * <p>The maximum number of writes consumed per second before DynamoDB returns a
                *                 <code>ThrottlingException</code>. For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html#ProvisionedThroughput">Specifying Read and Write Requirements</a> in the <i>Amazon DynamoDB
                *                 Developer Guide</i>.</p>
                *         <p>If read/write capacity mode is <code>PAY_PER_REQUEST</code> the value is set to
                *             0.</p>
                */
            WriteCapacityUnits: number | undefined;
    }
    export namespace ProvisionedThroughput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ProvisionedThroughput) => any;
    }
    /**
        * <p>Contains the details of the table when the backup was created. </p>
        */
    export interface SourceTableDetails {
            /**
                * <p>The name of the table for which the backup was created. </p>
                */
            TableName: string | undefined;
            /**
                * <p>Unique identifier for the table for which the backup was created. </p>
                */
            TableId: string | undefined;
            /**
                * <p>ARN of the table for which backup was created. </p>
                */
            TableArn?: string;
            /**
                * <p>Size of the table in bytes. Note that this is an approximate value.</p>
                */
            TableSizeBytes?: number;
            /**
                * <p>Schema of the table. </p>
                */
            KeySchema: KeySchemaElement[] | undefined;
            /**
                * <p>Time when the source table was created. </p>
                */
            TableCreationDateTime: Date | undefined;
            /**
                * <p>Read IOPs and Write IOPS on the table when the backup was created.</p>
                */
            ProvisionedThroughput: ProvisionedThroughput | undefined;
            /**
                * <p>Number of items in the table. Note that this is an approximate value. </p>
                */
            ItemCount?: number;
            /**
                * <p>Controls how you are charged for read and write throughput and how you manage
                *             capacity. This setting can be changed later.</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>PROVISIONED</code> - Sets the read/write capacity mode to
                *                         <code>PROVISIONED</code>. We recommend using <code>PROVISIONED</code> for
                *                     predictable workloads.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>PAY_PER_REQUEST</code> - Sets the read/write capacity mode to
                *                         <code>PAY_PER_REQUEST</code>. We recommend using
                *                         <code>PAY_PER_REQUEST</code> for unpredictable workloads. </p>
                *             </li>
                *          </ul>
                */
            BillingMode?: BillingMode | string;
    }
    export namespace SourceTableDetails {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SourceTableDetails) => any;
    }
    export type ProjectionType = "ALL" | "INCLUDE" | "KEYS_ONLY";
    /**
        * <p>Represents attributes that are copied (projected) from the table into an index. These
        *             are in addition to the primary key attributes and index key attributes, which are
        *             automatically projected.</p>
        */
    export interface Projection {
            /**
                * <p>The set of attributes that are projected into the index:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>KEYS_ONLY</code> - Only the index and primary keys are projected into the
                *                     index.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>INCLUDE</code> - In addition to the attributes described in
                *                         <code>KEYS_ONLY</code>, the secondary index will include other non-key
                *                     attributes that you specify.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>ALL</code> - All of the table attributes are projected into the
                *                     index.</p>
                *             </li>
                *          </ul>
                */
            ProjectionType?: ProjectionType | string;
            /**
                * <p>Represents the non-key attribute names which will be projected into the index.</p>
                *         <p>For local secondary indexes, the total count of <code>NonKeyAttributes</code> summed
                *             across all of the local secondary indexes, must not exceed 100. If you project the same
                *             attribute into two different indexes, this counts as two distinct attributes when
                *             determining the total.</p>
                */
            NonKeyAttributes?: string[];
    }
    export namespace Projection {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Projection) => any;
    }
    /**
        * <p>Represents the properties of a global secondary index for the table when the backup
        *             was created.</p>
        */
    export interface GlobalSecondaryIndexInfo {
            /**
                * <p>The name of the global secondary index.</p>
                */
            IndexName?: string;
            /**
                * <p>The complete key schema for a global secondary index, which consists of one or more
                *             pairs of attribute names and key types:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>HASH</code> - partition key</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>RANGE</code> - sort key</p>
                *             </li>
                *          </ul>
                *         <note>
                *             <p>The partition key of an item is also known as its <i>hash
                *                     attribute</i>. The term "hash attribute" derives from DynamoDB's usage of an internal hash function to evenly distribute data items across
                *                 partitions, based on their partition key values.</p>
                *             <p>The sort key of an item is also known as its <i>range attribute</i>.
                *                 The term "range attribute" derives from the way DynamoDB stores items with
                *                 the same partition key physically close together, in sorted order by the sort key
                *                 value.</p>
                *         </note>
                */
            KeySchema?: KeySchemaElement[];
            /**
                * <p>Represents attributes that are copied (projected) from the table into the global
                *             secondary index. These are in addition to the primary key attributes and index key
                *             attributes, which are automatically projected. </p>
                */
            Projection?: Projection;
            /**
                * <p>Represents the provisioned throughput settings for the specified global secondary
                *             index. </p>
                */
            ProvisionedThroughput?: ProvisionedThroughput;
    }
    export namespace GlobalSecondaryIndexInfo {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GlobalSecondaryIndexInfo) => any;
    }
    /**
        * <p>Represents the properties of a local secondary index for the table when the backup was
        *             created.</p>
        */
    export interface LocalSecondaryIndexInfo {
            /**
                * <p>Represents the name of the local secondary index.</p>
                */
            IndexName?: string;
            /**
                * <p>The complete key schema for a local secondary index, which consists of one or more
                *             pairs of attribute names and key types:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>HASH</code> - partition key</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>RANGE</code> - sort key</p>
                *             </li>
                *          </ul>
                *         <note>
                *             <p>The partition key of an item is also known as its <i>hash
                *                     attribute</i>. The term "hash attribute" derives from DynamoDB's usage of
                *                 an internal hash function to evenly distribute data items across partitions, based
                *                 on their partition key values.</p>
                *             <p>The sort key of an item is also known as its <i>range attribute</i>.
                *                 The term "range attribute" derives from the way DynamoDB stores items with the same
                *                 partition key physically close together, in sorted order by the sort key
                *                 value.</p>
                *         </note>
                */
            KeySchema?: KeySchemaElement[];
            /**
                * <p>Represents attributes that are copied (projected) from the table into the global
                *             secondary index. These are in addition to the primary key attributes and index key
                *             attributes, which are automatically projected. </p>
                */
            Projection?: Projection;
    }
    export namespace LocalSecondaryIndexInfo {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: LocalSecondaryIndexInfo) => any;
    }
    export type SSEType = "AES256" | "KMS";
    export type SSEStatus = "DISABLED" | "DISABLING" | "ENABLED" | "ENABLING" | "UPDATING";
    /**
        * <p>The description of the server-side encryption status on the specified table.</p>
        */
    export interface SSEDescription {
            /**
                * <p>Represents the current state of server-side encryption. The only supported values
                *             are:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>ENABLED</code> - Server-side encryption is enabled.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>UPDATING</code> - Server-side encryption is being updated.</p>
                *             </li>
                *          </ul>
                */
            Status?: SSEStatus | string;
            /**
                * <p>Server-side encryption type. The only supported value is:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>KMS</code> - Server-side encryption that uses Key Management Service. The
                *                     key is stored in your account and is managed by KMS (KMS charges apply).</p>
                *             </li>
                *          </ul>
                */
            SSEType?: SSEType | string;
            /**
                * <p>The KMS key ARN used for the KMS
                *             encryption.</p>
                */
            KMSMasterKeyArn?: string;
            /**
                * <p>Indicates the time, in UNIX epoch date format, when DynamoDB detected that
                *             the table's KMS key was inaccessible. This attribute will automatically
                *             be cleared when DynamoDB detects that the table's KMS key is accessible
                *             again. DynamoDB will initiate the table archival process when table's KMS key remains inaccessible for more than seven days from this date.</p>
                */
            InaccessibleEncryptionDateTime?: Date;
    }
    export namespace SSEDescription {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SSEDescription) => any;
    }
    export type StreamViewType = "KEYS_ONLY" | "NEW_AND_OLD_IMAGES" | "NEW_IMAGE" | "OLD_IMAGE";
    /**
        * <p>Represents the DynamoDB Streams configuration for a table in DynamoDB.</p>
        */
    export interface StreamSpecification {
            /**
                * <p>Indicates whether DynamoDB Streams is enabled (true) or disabled (false) on the
                *             table.</p>
                */
            StreamEnabled: boolean | undefined;
            /**
                * <p> When an item in the table is modified, <code>StreamViewType</code> determines what
                *             information is written to the stream for this table. Valid values for
                *                 <code>StreamViewType</code> are:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>KEYS_ONLY</code> - Only the key attributes of the modified item are
                *                     written to the stream.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>NEW_IMAGE</code> - The entire item, as it appears after it was modified,
                *                     is written to the stream.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>OLD_IMAGE</code> - The entire item, as it appeared before it was modified,
                *                     is written to the stream.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>NEW_AND_OLD_IMAGES</code> - Both the new and the old item images of the
                *                     item are written to the stream.</p>
                *             </li>
                *          </ul>
                */
            StreamViewType?: StreamViewType | string;
    }
    export namespace StreamSpecification {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StreamSpecification) => any;
    }
    export type TimeToLiveStatus = "DISABLED" | "DISABLING" | "ENABLED" | "ENABLING";
    /**
        * <p>The description of the Time to Live (TTL) status on the specified table. </p>
        */
    export interface TimeToLiveDescription {
            /**
                * <p> The TTL status for the table.</p>
                */
            TimeToLiveStatus?: TimeToLiveStatus | string;
            /**
                * <p> The name of the TTL attribute for items in the table.</p>
                */
            AttributeName?: string;
    }
    export namespace TimeToLiveDescription {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TimeToLiveDescription) => any;
    }
    /**
        * <p>Contains the details of the features enabled on the table when the backup was created.
        *             For example, LSIs, GSIs, streams, TTL. </p>
        */
    export interface SourceTableFeatureDetails {
            /**
                * <p>Represents the LSI properties for the table when the backup was created. It includes
                *             the IndexName, KeySchema and Projection for the LSIs on the table at the time of backup.
                *         </p>
                */
            LocalSecondaryIndexes?: LocalSecondaryIndexInfo[];
            /**
                * <p>Represents the GSI properties for the table when the backup was created. It includes
                *             the IndexName, KeySchema, Projection, and ProvisionedThroughput for the GSIs on the
                *             table at the time of backup. </p>
                */
            GlobalSecondaryIndexes?: GlobalSecondaryIndexInfo[];
            /**
                * <p>Stream settings on the table when the backup was created.</p>
                */
            StreamDescription?: StreamSpecification;
            /**
                * <p>Time to Live settings on the table when the backup was created.</p>
                */
            TimeToLiveDescription?: TimeToLiveDescription;
            /**
                * <p>The description of the server-side encryption status on the table when the backup was
                *             created.</p>
                */
            SSEDescription?: SSEDescription;
    }
    export namespace SourceTableFeatureDetails {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SourceTableFeatureDetails) => any;
    }
    /**
        * <p>Contains the description of the backup created for the table.</p>
        */
    export interface BackupDescription {
            /**
                * <p>Contains the details of the backup created for the table. </p>
                */
            BackupDetails?: BackupDetails;
            /**
                * <p>Contains the details of the table when the backup was created. </p>
                */
            SourceTableDetails?: SourceTableDetails;
            /**
                * <p>Contains the details of the features enabled on the table when the backup was created.
                *             For example, LSIs, GSIs, streams, TTL.</p>
                */
            SourceTableFeatureDetails?: SourceTableFeatureDetails;
    }
    export namespace BackupDescription {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BackupDescription) => any;
    }
    /**
        * <p>There is another ongoing conflicting backup control plane operation on the table.
        *             The backup is either being created, deleted or restored to a table.</p>
        */
    export class BackupInUseException extends __BaseException {
            readonly name: "BackupInUseException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<BackupInUseException, __BaseException>);
    }
    /**
        * <p>Backup not found for the given BackupARN. </p>
        */
    export class BackupNotFoundException extends __BaseException {
            readonly name: "BackupNotFoundException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<BackupNotFoundException, __BaseException>);
    }
    /**
        * <p>Contains details for the backup.</p>
        */
    export interface BackupSummary {
            /**
                * <p>Name of the table.</p>
                */
            TableName?: string;
            /**
                * <p>Unique identifier for the table.</p>
                */
            TableId?: string;
            /**
                * <p>ARN associated with the table.</p>
                */
            TableArn?: string;
            /**
                * <p>ARN associated with the backup.</p>
                */
            BackupArn?: string;
            /**
                * <p>Name of the specified backup.</p>
                */
            BackupName?: string;
            /**
                * <p>Time at which the backup was created.</p>
                */
            BackupCreationDateTime?: Date;
            /**
                * <p>Time at which the automatic on-demand backup created by DynamoDB will
                *             expire. This <code>SYSTEM</code> on-demand backup expires automatically 35 days after
                *             its creation.</p>
                */
            BackupExpiryDateTime?: Date;
            /**
                * <p>Backup can be in one of the following states: CREATING, ACTIVE, DELETED.</p>
                */
            BackupStatus?: BackupStatus | string;
            /**
                * <p>BackupType:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>USER</code> - You create and manage these using the on-demand backup
                *                     feature.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>SYSTEM</code> - If you delete a table with point-in-time recovery enabled,
                *                     a <code>SYSTEM</code> backup is automatically created and is retained for 35
                *                     days (at no additional cost). System backups allow you to restore the deleted
                *                     table to the state it was in just before the point of deletion. </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>AWS_BACKUP</code> - On-demand backup created by you from Backup service.</p>
                *             </li>
                *          </ul>
                */
            BackupType?: BackupType | string;
            /**
                * <p>Size of the backup in bytes.</p>
                */
            BackupSizeBytes?: number;
    }
    export namespace BackupSummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BackupSummary) => any;
    }
    export enum BackupTypeFilter {
            ALL = "ALL",
            AWS_BACKUP = "AWS_BACKUP",
            SYSTEM = "SYSTEM",
            USER = "USER"
    }
    export type ReturnConsumedCapacity = "INDEXES" | "NONE" | "TOTAL";
    /**
        * <p>Represents the amount of provisioned throughput capacity consumed on a table or an
        *             index.</p>
        */
    export interface Capacity {
            /**
                * <p>The total number of read capacity units consumed on a table or an index.</p>
                */
            ReadCapacityUnits?: number;
            /**
                * <p>The total number of write capacity units consumed on a table or an index.</p>
                */
            WriteCapacityUnits?: number;
            /**
                * <p>The total number of capacity units consumed on a table or an index.</p>
                */
            CapacityUnits?: number;
    }
    export namespace Capacity {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Capacity) => any;
    }
    /**
        * <p>The capacity units consumed by an operation. The data returned includes the total
        *             provisioned throughput consumed, along with statistics for the table and any indexes
        *             involved in the operation. <code>ConsumedCapacity</code> is only returned if the request
        *             asked for it. For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughputIntro.html">Provisioned Throughput</a> in the <i>Amazon DynamoDB Developer
        *                 Guide</i>.</p>
        */
    export interface ConsumedCapacity {
            /**
                * <p>The name of the table that was affected by the operation.</p>
                */
            TableName?: string;
            /**
                * <p>The total number of capacity units consumed by the operation.</p>
                */
            CapacityUnits?: number;
            /**
                * <p>The total number of read capacity units consumed by the operation.</p>
                */
            ReadCapacityUnits?: number;
            /**
                * <p>The total number of write capacity units consumed by the operation.</p>
                */
            WriteCapacityUnits?: number;
            /**
                * <p>The amount of throughput consumed on the table affected by the operation.</p>
                */
            Table?: Capacity;
            /**
                * <p>The amount of throughput consumed on each local index affected by the
                *             operation.</p>
                */
            LocalSecondaryIndexes?: Record<string, Capacity>;
            /**
                * <p>The amount of throughput consumed on each global index affected by the
                *             operation.</p>
                */
            GlobalSecondaryIndexes?: Record<string, Capacity>;
    }
    export namespace ConsumedCapacity {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ConsumedCapacity) => any;
    }
    export enum BatchStatementErrorCodeEnum {
            AccessDenied = "AccessDenied",
            ConditionalCheckFailed = "ConditionalCheckFailed",
            DuplicateItem = "DuplicateItem",
            InternalServerError = "InternalServerError",
            ItemCollectionSizeLimitExceeded = "ItemCollectionSizeLimitExceeded",
            ProvisionedThroughputExceeded = "ProvisionedThroughputExceeded",
            RequestLimitExceeded = "RequestLimitExceeded",
            ResourceNotFound = "ResourceNotFound",
            ThrottlingError = "ThrottlingError",
            TransactionConflict = "TransactionConflict",
            ValidationError = "ValidationError"
    }
    /**
        * <p> An error associated with a statement in a PartiQL batch that was run. </p>
        */
    export interface BatchStatementError {
            /**
                * <p> The error code associated with the failed PartiQL batch statement. </p>
                */
            Code?: BatchStatementErrorCodeEnum | string;
            /**
                * <p> The error message associated with the PartiQL batch resposne. </p>
                */
            Message?: string;
    }
    export namespace BatchStatementError {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchStatementError) => any;
    }
    /**
        * <p>An error occurred on the server side.</p>
        */
    export class InternalServerError extends __BaseException {
            readonly name: "InternalServerError";
            readonly $fault: "server";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InternalServerError, __BaseException>);
    }
    /**
        * <p>Throughput exceeds the current throughput quota for your account. Please contact
        *                 <a href="https://aws.amazon.com/support">Amazon Web Services Support</a> to request a
        *             quota increase.</p>
        */
    export class RequestLimitExceeded extends __BaseException {
            readonly name: "RequestLimitExceeded";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<RequestLimitExceeded, __BaseException>);
    }
    export class InvalidEndpointException extends __BaseException {
            readonly name: "InvalidEndpointException";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidEndpointException, __BaseException>);
    }
    /**
        * <p>Your request rate is too high. The Amazon Web Services SDKs for DynamoDB
        *             automatically retry requests that receive this exception. Your request is eventually
        *             successful, unless your retry queue is too large to finish. Reduce the frequency of
        *             requests and use exponential backoff. For more information, go to <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Programming.Errors.html#Programming.Errors.RetryAndBackoff">Error Retries and Exponential Backoff</a> in the <i>Amazon DynamoDB Developer Guide</i>.</p>
        */
    export class ProvisionedThroughputExceededException extends __BaseException {
            readonly name: "ProvisionedThroughputExceededException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ProvisionedThroughputExceededException, __BaseException>);
    }
    /**
        * <p>The operation tried to access a nonexistent table or index. The resource might not
        *             be specified correctly, or its status might not be <code>ACTIVE</code>.</p>
        */
    export class ResourceNotFoundException extends __BaseException {
            readonly name: "ResourceNotFoundException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ResourceNotFoundException, __BaseException>);
    }
    export type ReturnItemCollectionMetrics = "NONE" | "SIZE";
    /**
        * <p>An item collection is too large. This exception is only returned for tables that
        *             have one or more local secondary indexes.</p>
        */
    export class ItemCollectionSizeLimitExceededException extends __BaseException {
            readonly name: "ItemCollectionSizeLimitExceededException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ItemCollectionSizeLimitExceededException, __BaseException>);
    }
    /**
        * <p>Contains the details for the read/write capacity mode.</p>
        */
    export interface BillingModeSummary {
            /**
                * <p>Controls how you are charged for read and write throughput and how you manage
                *             capacity. This setting can be changed later.</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>PROVISIONED</code> - Sets the read/write capacity mode to
                *                         <code>PROVISIONED</code>. We recommend using <code>PROVISIONED</code> for
                *                     predictable workloads.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>PAY_PER_REQUEST</code> - Sets the read/write capacity mode to
                *                         <code>PAY_PER_REQUEST</code>. We recommend using
                *                         <code>PAY_PER_REQUEST</code> for unpredictable workloads. </p>
                *             </li>
                *          </ul>
                */
            BillingMode?: BillingMode | string;
            /**
                * <p>Represents the time when <code>PAY_PER_REQUEST</code> was last set as the read/write
                *             capacity mode.</p>
                */
            LastUpdateToPayPerRequestDateTime?: Date;
    }
    export namespace BillingModeSummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BillingModeSummary) => any;
    }
    export type ComparisonOperator = "BEGINS_WITH" | "BETWEEN" | "CONTAINS" | "EQ" | "GE" | "GT" | "IN" | "LE" | "LT" | "NE" | "NOT_CONTAINS" | "NOT_NULL" | "NULL";
    /**
        * <p>A condition specified in the operation could not be evaluated.</p>
        */
    export class ConditionalCheckFailedException extends __BaseException {
            readonly name: "ConditionalCheckFailedException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ConditionalCheckFailedException, __BaseException>);
    }
    export type ConditionalOperator = "AND" | "OR";
    export type ReturnValuesOnConditionCheckFailure = "ALL_OLD" | "NONE";
    export type ContinuousBackupsStatus = "DISABLED" | "ENABLED";
    export type PointInTimeRecoveryStatus = "DISABLED" | "ENABLED";
    /**
        * <p>The description of the point in time settings applied to the table.</p>
        */
    export interface PointInTimeRecoveryDescription {
            /**
                * <p>The current state of point in time recovery:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>ENABLED</code> - Point in time recovery is enabled.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>DISABLED</code> - Point in time recovery is disabled.</p>
                *             </li>
                *          </ul>
                */
            PointInTimeRecoveryStatus?: PointInTimeRecoveryStatus | string;
            /**
                * <p>Specifies the earliest point in time you can restore your table to. You can restore
                *             your table to any point in time during the last 35 days. </p>
                */
            EarliestRestorableDateTime?: Date;
            /**
                * <p>
                *             <code>LatestRestorableDateTime</code> is typically 5 minutes before the current time.
                *         </p>
                */
            LatestRestorableDateTime?: Date;
    }
    export namespace PointInTimeRecoveryDescription {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PointInTimeRecoveryDescription) => any;
    }
    /**
        * <p>Represents the continuous backups and point in time recovery settings on the
        *             table.</p>
        */
    export interface ContinuousBackupsDescription {
            /**
                * <p>
                *             <code>ContinuousBackupsStatus</code> can be one of the following states: ENABLED,
                *             DISABLED</p>
                */
            ContinuousBackupsStatus: ContinuousBackupsStatus | string | undefined;
            /**
                * <p>The description of the point in time recovery settings applied to the table.</p>
                */
            PointInTimeRecoveryDescription?: PointInTimeRecoveryDescription;
    }
    export namespace ContinuousBackupsDescription {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ContinuousBackupsDescription) => any;
    }
    /**
        * <p>Backups have not yet been enabled for this table.</p>
        */
    export class ContinuousBackupsUnavailableException extends __BaseException {
            readonly name: "ContinuousBackupsUnavailableException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ContinuousBackupsUnavailableException, __BaseException>);
    }
    export type ContributorInsightsAction = "DISABLE" | "ENABLE";
    export type ContributorInsightsStatus = "DISABLED" | "DISABLING" | "ENABLED" | "ENABLING" | "FAILED";
    /**
        * <p>Represents a Contributor Insights summary entry.</p>
        */
    export interface ContributorInsightsSummary {
            /**
                * <p>Name of the table associated with the summary.</p>
                */
            TableName?: string;
            /**
                * <p>Name of the index associated with the summary, if any.</p>
                */
            IndexName?: string;
            /**
                * <p>Describes the current status for contributor insights for the given table and index,
                *             if applicable.</p>
                */
            ContributorInsightsStatus?: ContributorInsightsStatus | string;
    }
    export namespace ContributorInsightsSummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ContributorInsightsSummary) => any;
    }
    export interface CreateBackupInput {
            /**
                * <p>The name of the table.</p>
                */
            TableName: string | undefined;
            /**
                * <p>Specified name for the backup.</p>
                */
            BackupName: string | undefined;
    }
    export namespace CreateBackupInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateBackupInput) => any;
    }
    export interface CreateBackupOutput {
            /**
                * <p>Contains the details of the backup created for the table.</p>
                */
            BackupDetails?: BackupDetails;
    }
    export namespace CreateBackupOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateBackupOutput) => any;
    }
    /**
        * <p>There is no limit to the number of daily on-demand backups that can be taken. </p>
        *         <p>Up to 500 simultaneous table operations are allowed per account. These operations
        *             include <code>CreateTable</code>, <code>UpdateTable</code>,
        *                 <code>DeleteTable</code>,<code>UpdateTimeToLive</code>,
        *                 <code>RestoreTableFromBackup</code>, and <code>RestoreTableToPointInTime</code>. </p>
        *         <p>The only exception is when you are creating a table with one or more secondary
        *             indexes. You can have up to 250 such requests running at a time; however, if the table or
        *             index specifications are complex, DynamoDB might temporarily reduce the number
        *             of concurrent operations.</p>
        *         <p>There is a soft account quota of 2,500 tables.</p>
        */
    export class LimitExceededException extends __BaseException {
            readonly name: "LimitExceededException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<LimitExceededException, __BaseException>);
    }
    /**
        * <p>A target table with the specified name is either being created or deleted.
        *         </p>
        */
    export class TableInUseException extends __BaseException {
            readonly name: "TableInUseException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TableInUseException, __BaseException>);
    }
    /**
        * <p>A source table with the name <code>TableName</code> does not currently exist within
        *             the subscriber's account or the subscriber is operating in the wrong Amazon Web Services Region.</p>
        */
    export class TableNotFoundException extends __BaseException {
            readonly name: "TableNotFoundException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TableNotFoundException, __BaseException>);
    }
    /**
        * <p>Represents a new global secondary index to be added to an existing table.</p>
        */
    export interface CreateGlobalSecondaryIndexAction {
            /**
                * <p>The name of the global secondary index to be created.</p>
                */
            IndexName: string | undefined;
            /**
                * <p>The key schema for the global secondary index.</p>
                */
            KeySchema: KeySchemaElement[] | undefined;
            /**
                * <p>Represents attributes that are copied (projected) from the table into an index. These
                *             are in addition to the primary key attributes and index key attributes, which are
                *             automatically projected.</p>
                */
            Projection: Projection | undefined;
            /**
                * <p>Represents the provisioned throughput settings for the specified global secondary
                *             index.</p>
                *         <p>For current minimum and maximum provisioned throughput values, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html">Service,
                *                 Account, and Table Quotas</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>.</p>
                */
            ProvisionedThroughput?: ProvisionedThroughput;
    }
    export namespace CreateGlobalSecondaryIndexAction {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateGlobalSecondaryIndexAction) => any;
    }
    /**
        * <p>Represents the properties of a replica.</p>
        */
    export interface Replica {
            /**
                * <p>The Region where the replica needs to be created.</p>
                */
            RegionName?: string;
    }
    export namespace Replica {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Replica) => any;
    }
    export interface CreateGlobalTableInput {
            /**
                * <p>The global table name.</p>
                */
            GlobalTableName: string | undefined;
            /**
                * <p>The Regions where the global table needs to be created.</p>
                */
            ReplicationGroup: Replica[] | undefined;
    }
    export namespace CreateGlobalTableInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateGlobalTableInput) => any;
    }
    export type GlobalTableStatus = "ACTIVE" | "CREATING" | "DELETING" | "UPDATING";
    /**
        * <p>Replica-specific provisioned throughput settings. If not specified, uses the source
        *             table's provisioned throughput settings.</p>
        */
    export interface ProvisionedThroughputOverride {
            /**
                * <p>Replica-specific read capacity units. If not specified, uses the source table's read
                *             capacity settings.</p>
                */
            ReadCapacityUnits?: number;
    }
    export namespace ProvisionedThroughputOverride {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ProvisionedThroughputOverride) => any;
    }
    /**
        * <p>Represents the properties of a replica global secondary index.</p>
        */
    export interface ReplicaGlobalSecondaryIndexDescription {
            /**
                * <p>The name of the global secondary index.</p>
                */
            IndexName?: string;
            /**
                * <p>If not described, uses the source table GSI's read capacity settings.</p>
                */
            ProvisionedThroughputOverride?: ProvisionedThroughputOverride;
    }
    export namespace ReplicaGlobalSecondaryIndexDescription {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ReplicaGlobalSecondaryIndexDescription) => any;
    }
    export type ReplicaStatus = "ACTIVE" | "CREATING" | "CREATION_FAILED" | "DELETING" | "INACCESSIBLE_ENCRYPTION_CREDENTIALS" | "REGION_DISABLED" | "UPDATING";
    export enum TableClass {
            STANDARD = "STANDARD",
            STANDARD_INFREQUENT_ACCESS = "STANDARD_INFREQUENT_ACCESS"
    }
    /**
        * <p>Contains details of the table class.</p>
        */
    export interface TableClassSummary {
            /**
                * <p>The table class of the specified table. Valid values are <code>STANDARD</code> and
                *                 <code>STANDARD_INFREQUENT_ACCESS</code>.</p>
                */
            TableClass?: TableClass | string;
            /**
                * <p>The date and time at which the table class was last updated.</p>
                */
            LastUpdateDateTime?: Date;
    }
    export namespace TableClassSummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TableClassSummary) => any;
    }
    /**
        * <p>Contains the details of the replica.</p>
        */
    export interface ReplicaDescription {
            /**
                * <p>The name of the Region.</p>
                */
            RegionName?: string;
            /**
                * <p>The current state of the replica:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>CREATING</code> - The replica is being created.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>UPDATING</code> - The replica is being updated.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>DELETING</code> - The replica is being deleted.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>ACTIVE</code> - The replica is ready for use.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>REGION_DISABLED</code> - The replica is inaccessible because the Amazon Web Services Region has been disabled.</p>
                *                 <note>
                *                     <p>If the Amazon Web Services Region remains inaccessible for more than 20
                *                         hours, DynamoDB will remove this replica from the replication
                *                         group. The replica will not be deleted and replication will stop from and to
                *                         this region.</p>
                *                 </note>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>INACCESSIBLE_ENCRYPTION_CREDENTIALS </code> - The KMS key
                *                     used to encrypt the table is inaccessible.</p>
                *                 <note>
                *                     <p>If the KMS key remains inaccessible for more than 20 hours,
                *                             DynamoDB will remove this replica from the replication group.
                *                         The replica will not be deleted and replication will stop from and to this
                *                         region.</p>
                *                 </note>
                *             </li>
                *          </ul>
                */
            ReplicaStatus?: ReplicaStatus | string;
            /**
                * <p>Detailed information about the replica status.</p>
                */
            ReplicaStatusDescription?: string;
            /**
                * <p>Specifies the progress of a Create, Update, or Delete action on the replica as a
                *             percentage.</p>
                */
            ReplicaStatusPercentProgress?: string;
            /**
                * <p>The KMS key of the replica that will be used for
                *                 KMS encryption.</p>
                */
            KMSMasterKeyId?: string;
            /**
                * <p>Replica-specific provisioned throughput. If not described, uses the source table's
                *             provisioned throughput settings.</p>
                */
            ProvisionedThroughputOverride?: ProvisionedThroughputOverride;
            /**
                * <p>Replica-specific global secondary index settings.</p>
                */
            GlobalSecondaryIndexes?: ReplicaGlobalSecondaryIndexDescription[];
            /**
                * <p>The time at which the replica was first detected as inaccessible. To determine cause
                *             of inaccessibility check the <code>ReplicaStatus</code> property.</p>
                */
            ReplicaInaccessibleDateTime?: Date;
            /**
                * <p>Contains details of the table class.</p>
                */
            ReplicaTableClassSummary?: TableClassSummary;
    }
    export namespace ReplicaDescription {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ReplicaDescription) => any;
    }
    /**
        * <p>Contains details about the global table.</p>
        */
    export interface GlobalTableDescription {
            /**
                * <p>The Regions where the global table has replicas.</p>
                */
            ReplicationGroup?: ReplicaDescription[];
            /**
                * <p>The unique identifier of the global table.</p>
                */
            GlobalTableArn?: string;
            /**
                * <p>The creation time of the global table.</p>
                */
            CreationDateTime?: Date;
            /**
                * <p>The current state of the global table:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>CREATING</code> - The global table is being created.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>UPDATING</code> - The global table is being updated.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>DELETING</code> - The global table is being deleted.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>ACTIVE</code> - The global table is ready for use.</p>
                *             </li>
                *          </ul>
                */
            GlobalTableStatus?: GlobalTableStatus | string;
            /**
                * <p>The global table name.</p>
                */
            GlobalTableName?: string;
    }
    export namespace GlobalTableDescription {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GlobalTableDescription) => any;
    }
    export interface CreateGlobalTableOutput {
            /**
                * <p>Contains the details of the global table.</p>
                */
            GlobalTableDescription?: GlobalTableDescription;
    }
    export namespace CreateGlobalTableOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateGlobalTableOutput) => any;
    }
    /**
        * <p>The specified global table already exists.</p>
        */
    export class GlobalTableAlreadyExistsException extends __BaseException {
            readonly name: "GlobalTableAlreadyExistsException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<GlobalTableAlreadyExistsException, __BaseException>);
    }
    /**
        * <p>Represents a replica to be added.</p>
        */
    export interface CreateReplicaAction {
            /**
                * <p>The Region of the replica to be added.</p>
                */
            RegionName: string | undefined;
    }
    export namespace CreateReplicaAction {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateReplicaAction) => any;
    }
    /**
        * <p>Represents the properties of a replica global secondary index.</p>
        */
    export interface ReplicaGlobalSecondaryIndex {
            /**
                * <p>The name of the global secondary index.</p>
                */
            IndexName: string | undefined;
            /**
                * <p>Replica table GSI-specific provisioned throughput. If not specified, uses the source
                *             table GSI's read capacity settings.</p>
                */
            ProvisionedThroughputOverride?: ProvisionedThroughputOverride;
    }
    export namespace ReplicaGlobalSecondaryIndex {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ReplicaGlobalSecondaryIndex) => any;
    }
    /**
        * <p>Represents a replica to be created.</p>
        */
    export interface CreateReplicationGroupMemberAction {
            /**
                * <p>The Region where the new replica will be created.</p>
                */
            RegionName: string | undefined;
            /**
                * <p>The KMS key that should be used for KMS encryption in
                *             the new replica. To specify a key, use its key ID, Amazon Resource Name (ARN), alias
                *             name, or alias ARN. Note that you should only provide this parameter if the key is
                *             different from the default DynamoDB KMS key
                *             <code>alias/aws/dynamodb</code>.</p>
                */
            KMSMasterKeyId?: string;
            /**
                * <p>Replica-specific provisioned throughput. If not specified, uses the source table's
                *             provisioned throughput settings.</p>
                */
            ProvisionedThroughputOverride?: ProvisionedThroughputOverride;
            /**
                * <p>Replica-specific global secondary index settings.</p>
                */
            GlobalSecondaryIndexes?: ReplicaGlobalSecondaryIndex[];
            /**
                * <p>Replica-specific table class. If not specified, uses the source table's
                *             table class.</p>
                */
            TableClassOverride?: TableClass | string;
    }
    export namespace CreateReplicationGroupMemberAction {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateReplicationGroupMemberAction) => any;
    }
    /**
        * <p>Represents the properties of a global secondary index.</p>
        */
    export interface GlobalSecondaryIndex {
            /**
                * <p>The name of the global secondary index. The name must be unique among all other
                *             indexes on this table.</p>
                */
            IndexName: string | undefined;
            /**
                * <p>The complete key schema for a global secondary index, which consists of one or more
                *             pairs of attribute names and key types:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>HASH</code> - partition key</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>RANGE</code> - sort key</p>
                *             </li>
                *          </ul>
                *         <note>
                *             <p>The partition key of an item is also known as its <i>hash
                *                     attribute</i>. The term "hash attribute" derives from DynamoDB's usage of
                *                 an internal hash function to evenly distribute data items across partitions, based
                *                 on their partition key values.</p>
                *             <p>The sort key of an item is also known as its <i>range attribute</i>.
                *                 The term "range attribute" derives from the way DynamoDB stores items with the same
                *                 partition key physically close together, in sorted order by the sort key
                *                 value.</p>
                *         </note>
                */
            KeySchema: KeySchemaElement[] | undefined;
            /**
                * <p>Represents attributes that are copied (projected) from the table into the global
                *             secondary index. These are in addition to the primary key attributes and index key
                *             attributes, which are automatically projected. </p>
                */
            Projection: Projection | undefined;
            /**
                * <p>Represents the provisioned throughput settings for the specified global secondary
                *             index.</p>
                *         <p>For current minimum and maximum provisioned throughput values, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html">Service,
                *                 Account, and Table Quotas</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>.</p>
                */
            ProvisionedThroughput?: ProvisionedThroughput;
    }
    export namespace GlobalSecondaryIndex {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GlobalSecondaryIndex) => any;
    }
    /**
        * <p>Represents the properties of a local secondary index.</p>
        */
    export interface LocalSecondaryIndex {
            /**
                * <p>The name of the local secondary index. The name must be unique among all other indexes
                *             on this table.</p>
                */
            IndexName: string | undefined;
            /**
                * <p>The complete key schema for the local secondary index, consisting of one or more pairs
                *             of attribute names and key types:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>HASH</code> - partition key</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>RANGE</code> - sort key</p>
                *             </li>
                *          </ul>
                *         <note>
                *             <p>The partition key of an item is also known as its <i>hash
                *                     attribute</i>. The term "hash attribute" derives from DynamoDB's usage of
                *                 an internal hash function to evenly distribute data items across partitions, based
                *                 on their partition key values.</p>
                *             <p>The sort key of an item is also known as its <i>range attribute</i>.
                *                 The term "range attribute" derives from the way DynamoDB stores items with the same
                *                 partition key physically close together, in sorted order by the sort key
                *                 value.</p>
                *         </note>
                */
            KeySchema: KeySchemaElement[] | undefined;
            /**
                * <p>Represents attributes that are copied (projected) from the table into the local
                *             secondary index. These are in addition to the primary key attributes and index key
                *             attributes, which are automatically projected. </p>
                */
            Projection: Projection | undefined;
    }
    export namespace LocalSecondaryIndex {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: LocalSecondaryIndex) => any;
    }
    /**
        * <p>Represents the settings used to enable server-side encryption.</p>
        */
    export interface SSESpecification {
            /**
                * <p>Indicates whether server-side encryption is done using an Amazon Web Services managed
                *             key or an Amazon Web Services owned key. If enabled (true), server-side encryption type
                *             is set to <code>KMS</code> and an Amazon Web Services managed key is used (KMS charges apply). If disabled (false) or not specified, server-side
                *             encryption is set to Amazon Web Services owned key.</p>
                */
            Enabled?: boolean;
            /**
                * <p>Server-side encryption type. The only supported value is:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>KMS</code> - Server-side encryption that uses Key Management Service. The
                *                     key is stored in your account and is managed by KMS (KMS charges apply).</p>
                *             </li>
                *          </ul>
                */
            SSEType?: SSEType | string;
            /**
                * <p>The KMS key that should be used for the KMS encryption.
                *             To specify a key, use its key ID, Amazon Resource Name (ARN), alias name, or alias ARN.
                *             Note that you should only provide this parameter if the key is different from the
                *             default DynamoDB key <code>alias/aws/dynamodb</code>.</p>
                */
            KMSMasterKeyId?: string;
    }
    export namespace SSESpecification {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: SSESpecification) => any;
    }
    /**
        * <p>Describes a tag. A tag is a key-value pair. You can add up to 50 tags to a single
        *             DynamoDB table. </p>
        *         <p>Amazon Web Services-assigned tag names and values are automatically assigned the
        *                 <code>aws:</code> prefix, which the user cannot assign. Amazon Web Services-assigned
        *             tag names do not count towards the tag limit of 50. User-assigned tag names have the
        *             prefix <code>user:</code> in the Cost Allocation Report. You cannot backdate the
        *             application of a tag.</p>
        *         <p>For an overview on tagging DynamoDB resources, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Tagging.html">Tagging
        *                 for DynamoDB</a> in the <i>Amazon DynamoDB Developer
        *                 Guide</i>.</p>
        */
    export interface Tag {
            /**
                * <p>The key of the tag. Tag keys are case sensitive. Each DynamoDB table can
                *             only have up to one tag with the same key. If you try to add an existing tag (same key),
                *             the existing tag value will be updated to the new value.</p>
                */
            Key: string | undefined;
            /**
                * <p>The value of the tag. Tag values are case-sensitive and can be null.</p>
                */
            Value: string | undefined;
    }
    export namespace Tag {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Tag) => any;
    }
    /**
        * <p>Represents the input of a <code>CreateTable</code> operation.</p>
        */
    export interface CreateTableInput {
            /**
                * <p>An array of attributes that describe the key schema for the table and indexes.</p>
                */
            AttributeDefinitions: AttributeDefinition[] | undefined;
            /**
                * <p>The name of the table to create.</p>
                */
            TableName: string | undefined;
            /**
                * <p>Specifies the attributes that make up the primary key for a table or an index. The
                *             attributes in <code>KeySchema</code> must also be defined in the
                *                 <code>AttributeDefinitions</code> array. For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DataModel.html">Data
                *                 Model</a> in the <i>Amazon DynamoDB Developer Guide</i>.</p>
                *         <p>Each <code>KeySchemaElement</code> in the array is composed of:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>AttributeName</code> - The name of this key attribute.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>KeyType</code> - The role that the key attribute will assume:</p>
                *                 <ul>
                *                   <li>
                *                         <p>
                *                             <code>HASH</code> - partition key</p>
                *                     </li>
                *                   <li>
                *                         <p>
                *                             <code>RANGE</code> - sort key</p>
                *                     </li>
                *                </ul>
                *             </li>
                *          </ul>
                *         <note>
                *             <p>The partition key of an item is also known as its <i>hash
                *                     attribute</i>. The term "hash attribute" derives from the DynamoDB usage
                *                 of an internal hash function to evenly distribute data items across partitions,
                *                 based on their partition key values.</p>
                *             <p>The sort key of an item is also known as its <i>range attribute</i>.
                *                 The term "range attribute" derives from the way DynamoDB stores items with the same
                *                 partition key physically close together, in sorted order by the sort key
                *                 value.</p>
                *         </note>
                *
                *         <p>For a simple primary key (partition key), you must provide exactly one element with a
                *                 <code>KeyType</code> of <code>HASH</code>.</p>
                *         <p>For a composite primary key (partition key and sort key), you must provide exactly two
                *             elements, in this order: The first element must have a <code>KeyType</code> of
                *                 <code>HASH</code>, and the second element must have a <code>KeyType</code> of
                *                 <code>RANGE</code>.</p>
                *         <p>For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html#WorkingWithTables.primary.key">Working with Tables</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>.</p>
                */
            KeySchema: KeySchemaElement[] | undefined;
            /**
                * <p>One or more local secondary indexes (the maximum is 5) to be created on the table.
                *             Each index is scoped to a given partition key value. There is a 10 GB size limit per
                *             partition key value; otherwise, the size of a local secondary index is
                *             unconstrained.</p>
                *         <p>Each local secondary index in the array includes the following:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>IndexName</code> - The name of the local secondary index. Must be unique
                *                     only for this table.</p>
                *                 <p></p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>KeySchema</code> - Specifies the key schema for the local secondary index.
                *                     The key schema must begin with the same partition key as the table.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>Projection</code> - Specifies attributes that are copied (projected) from
                *                     the table into the index. These are in addition to the primary key attributes
                *                     and index key attributes, which are automatically projected. Each attribute
                *                     specification is composed of:</p>
                *                 <ul>
                *                   <li>
                *                         <p>
                *                             <code>ProjectionType</code> - One of the following:</p>
                *                         <ul>
                *                         <li>
                *                                 <p>
                *                                     <code>KEYS_ONLY</code> - Only the index and primary keys are
                *                                     projected into the index.</p>
                *                             </li>
                *                         <li>
                *                                 <p>
                *                                     <code>INCLUDE</code> - Only the specified table attributes are
                *                                     projected into the index. The list of projected attributes is in
                *                                         <code>NonKeyAttributes</code>.</p>
                *                             </li>
                *                         <li>
                *                                 <p>
                *                                     <code>ALL</code> - All of the table attributes are projected
                *                                     into the index.</p>
                *                             </li>
                *                      </ul>
                *                     </li>
                *                   <li>
                *                         <p>
                *                             <code>NonKeyAttributes</code> - A list of one or more non-key attribute
                *                             names that are projected into the secondary index. The total count of
                *                             attributes provided in <code>NonKeyAttributes</code>, summed across all
                *                             of the secondary indexes, must not exceed 100. If you project the same
                *                             attribute into two different indexes, this counts as two distinct
                *                             attributes when determining the total.</p>
                *                     </li>
                *                </ul>
                *             </li>
                *          </ul>
                */
            LocalSecondaryIndexes?: LocalSecondaryIndex[];
            /**
                * <p>One or more global secondary indexes (the maximum is 20) to be created on the table.
                *             Each global secondary index in the array includes the following:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>IndexName</code> - The name of the global secondary index. Must be unique
                *                     only for this table.</p>
                *                 <p></p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>KeySchema</code> - Specifies the key schema for the global secondary
                *                     index.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>Projection</code> - Specifies attributes that are copied (projected) from
                *                     the table into the index. These are in addition to the primary key attributes
                *                     and index key attributes, which are automatically projected. Each attribute
                *                     specification is composed of:</p>
                *                 <ul>
                *                   <li>
                *                         <p>
                *                             <code>ProjectionType</code> - One of the following:</p>
                *                         <ul>
                *                         <li>
                *                                 <p>
                *                                     <code>KEYS_ONLY</code> - Only the index and primary keys are
                *                                     projected into the index.</p>
                *                             </li>
                *                         <li>
                *                                 <p>
                *                                     <code>INCLUDE</code> - Only the specified table attributes are
                *                                     projected into the index. The list of projected attributes is in
                *                                         <code>NonKeyAttributes</code>.</p>
                *                             </li>
                *                         <li>
                *                                 <p>
                *                                     <code>ALL</code> - All of the table attributes are projected
                *                                     into the index.</p>
                *                             </li>
                *                      </ul>
                *                     </li>
                *                   <li>
                *                         <p>
                *                             <code>NonKeyAttributes</code> - A list of one or more non-key attribute
                *                             names that are projected into the secondary index. The total count of
                *                             attributes provided in <code>NonKeyAttributes</code>, summed across all
                *                             of the secondary indexes, must not exceed 100. If you project the same
                *                             attribute into two different indexes, this counts as two distinct
                *                             attributes when determining the total.</p>
                *                     </li>
                *                </ul>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>ProvisionedThroughput</code> - The provisioned throughput settings for the
                *                     global secondary index, consisting of read and write capacity units.</p>
                *             </li>
                *          </ul>
                */
            GlobalSecondaryIndexes?: GlobalSecondaryIndex[];
            /**
                * <p>Controls how you are charged for read and write throughput and how you manage
                *             capacity. This setting can be changed later.</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>PROVISIONED</code> - We recommend using <code>PROVISIONED</code> for
                *                     predictable workloads. <code>PROVISIONED</code> sets the billing mode to <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadWriteCapacityMode.html#HowItWorks.ProvisionedThroughput.Manual">Provisioned Mode</a>.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>PAY_PER_REQUEST</code> - We recommend using <code>PAY_PER_REQUEST</code>
                *                     for unpredictable workloads. <code>PAY_PER_REQUEST</code> sets the billing mode
                *                     to <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadWriteCapacityMode.html#HowItWorks.OnDemand">On-Demand Mode</a>. </p>
                *             </li>
                *          </ul>
                */
            BillingMode?: BillingMode | string;
            /**
                * <p>Represents the provisioned throughput settings for a specified table or index. The
                *             settings can be modified using the <code>UpdateTable</code> operation.</p>
                *         <p> If you set BillingMode as <code>PROVISIONED</code>, you must specify this property.
                *             If you set BillingMode as <code>PAY_PER_REQUEST</code>, you cannot specify this
                *             property.</p>
                *         <p>For current minimum and maximum provisioned throughput values, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html">Service,
                *                 Account, and Table Quotas</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>.</p>
                */
            ProvisionedThroughput?: ProvisionedThroughput;
            /**
                * <p>The settings for DynamoDB Streams on the table. These settings consist of:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>StreamEnabled</code> - Indicates whether DynamoDB Streams is to be enabled
                *                     (true) or disabled (false).</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>StreamViewType</code> - When an item in the table is modified,
                *                         <code>StreamViewType</code> determines what information is written to the
                *                     table's stream. Valid values for <code>StreamViewType</code> are:</p>
                *                 <ul>
                *                   <li>
                *                         <p>
                *                             <code>KEYS_ONLY</code> - Only the key attributes of the modified item
                *                             are written to the stream.</p>
                *                     </li>
                *                   <li>
                *                         <p>
                *                             <code>NEW_IMAGE</code> - The entire item, as it appears after it was
                *                             modified, is written to the stream.</p>
                *                     </li>
                *                   <li>
                *                         <p>
                *                             <code>OLD_IMAGE</code> - The entire item, as it appeared before it was
                *                             modified, is written to the stream.</p>
                *                     </li>
                *                   <li>
                *                         <p>
                *                             <code>NEW_AND_OLD_IMAGES</code> - Both the new and the old item images
                *                             of the item are written to the stream.</p>
                *                     </li>
                *                </ul>
                *             </li>
                *          </ul>
                */
            StreamSpecification?: StreamSpecification;
            /**
                * <p>Represents the settings used to enable server-side encryption.</p>
                */
            SSESpecification?: SSESpecification;
            /**
                * <p>A list of key-value pairs to label the table. For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Tagging.html">Tagging
                *                 for DynamoDB</a>.</p>
                */
            Tags?: Tag[];
            /**
                * <p>The table class of the new table. Valid values are <code>STANDARD</code> and
                *                 <code>STANDARD_INFREQUENT_ACCESS</code>.</p>
                */
            TableClass?: TableClass | string;
    }
    export namespace CreateTableInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateTableInput) => any;
    }
    export type IndexStatus = "ACTIVE" | "CREATING" | "DELETING" | "UPDATING";
    /**
        * <p>Represents the provisioned throughput settings for the table, consisting of read and
        *             write capacity units, along with data about increases and decreases.</p>
        */
    export interface ProvisionedThroughputDescription {
            /**
                * <p>The date and time of the last provisioned throughput increase for this table.</p>
                */
            LastIncreaseDateTime?: Date;
            /**
                * <p>The date and time of the last provisioned throughput decrease for this table.</p>
                */
            LastDecreaseDateTime?: Date;
            /**
                * <p>The number of provisioned throughput decreases for this table during this UTC calendar
                *             day. For current maximums on provisioned throughput decreases, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html">Service,
                *                 Account, and Table Quotas</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>.</p>
                */
            NumberOfDecreasesToday?: number;
            /**
                * <p>The maximum number of strongly consistent reads consumed per second before DynamoDB
                *             returns a <code>ThrottlingException</code>. Eventually consistent reads require less
                *             effort than strongly consistent reads, so a setting of 50 <code>ReadCapacityUnits</code>
                *             per second provides 100 eventually consistent <code>ReadCapacityUnits</code> per
                *             second.</p>
                */
            ReadCapacityUnits?: number;
            /**
                * <p>The maximum number of writes consumed per second before DynamoDB returns a
                *                 <code>ThrottlingException</code>.</p>
                */
            WriteCapacityUnits?: number;
    }
    export namespace ProvisionedThroughputDescription {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ProvisionedThroughputDescription) => any;
    }
    /**
        * <p>Represents the properties of a global secondary index.</p>
        */
    export interface GlobalSecondaryIndexDescription {
            /**
                * <p>The name of the global secondary index.</p>
                */
            IndexName?: string;
            /**
                * <p>The complete key schema for a global secondary index, which consists of one or more
                *             pairs of attribute names and key types:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>HASH</code> - partition key</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>RANGE</code> - sort key</p>
                *             </li>
                *          </ul>
                *         <note>
                *             <p>The partition key of an item is also known as its <i>hash
                *                     attribute</i>. The term "hash attribute" derives from DynamoDB's usage of an internal hash function to evenly distribute data items across
                *                 partitions, based on their partition key values.</p>
                *             <p>The sort key of an item is also known as its <i>range attribute</i>.
                *                 The term "range attribute" derives from the way DynamoDB stores items with
                *                 the same partition key physically close together, in sorted order by the sort key
                *                 value.</p>
                *         </note>
                */
            KeySchema?: KeySchemaElement[];
            /**
                * <p>Represents attributes that are copied (projected) from the table into the global
                *             secondary index. These are in addition to the primary key attributes and index key
                *             attributes, which are automatically projected. </p>
                */
            Projection?: Projection;
            /**
                * <p>The current state of the global secondary index:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>CREATING</code> - The index is being created.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>UPDATING</code> - The index is being updated.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>DELETING</code> - The index is being deleted.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>ACTIVE</code> - The index is ready for use.</p>
                *             </li>
                *          </ul>
                */
            IndexStatus?: IndexStatus | string;
            /**
                * <p>Indicates whether the index is currently backfilling. <i>Backfilling</i>
                *             is the process of reading items from the table and determining whether they can be added
                *             to the index. (Not all items will qualify: For example, a partition key cannot have any
                *             duplicate values.) If an item can be added to the index, DynamoDB will do so. After all
                *             items have been processed, the backfilling operation is complete and
                *                 <code>Backfilling</code> is false.</p>
                *         <p>You can delete an index that is being created during the <code>Backfilling</code>
                *             phase when <code>IndexStatus</code> is set to CREATING and <code>Backfilling</code> is
                *             true. You can't delete the index that is being created when <code>IndexStatus</code> is
                *             set to CREATING and <code>Backfilling</code> is false. </p>
                *         <note>
                *             <p>For indexes that were created during a <code>CreateTable</code> operation, the
                *                     <code>Backfilling</code> attribute does not appear in the
                *                     <code>DescribeTable</code> output.</p>
                *         </note>
                */
            Backfilling?: boolean;
            /**
                * <p>Represents the provisioned throughput settings for the specified global secondary
                *             index.</p>
                *         <p>For current minimum and maximum provisioned throughput values, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html">Service,
                *                 Account, and Table Quotas</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>.</p>
                */
            ProvisionedThroughput?: ProvisionedThroughputDescription;
            /**
                * <p>The total size of the specified index, in bytes. DynamoDB updates this value
                *             approximately every six hours. Recent changes might not be reflected in this
                *             value.</p>
                */
            IndexSizeBytes?: number;
            /**
                * <p>The number of items in the specified index. DynamoDB updates this value approximately
                *             every six hours. Recent changes might not be reflected in this value.</p>
                */
            ItemCount?: number;
            /**
                * <p>The Amazon Resource Name (ARN) that uniquely identifies the index.</p>
                */
            IndexArn?: string;
    }
    export namespace GlobalSecondaryIndexDescription {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GlobalSecondaryIndexDescription) => any;
    }
    /**
        * <p>Represents the properties of a local secondary index.</p>
        */
    export interface LocalSecondaryIndexDescription {
            /**
                * <p>Represents the name of the local secondary index.</p>
                */
            IndexName?: string;
            /**
                * <p>The complete key schema for the local secondary index, consisting of one or more pairs
                *             of attribute names and key types:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>HASH</code> - partition key</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>RANGE</code> - sort key</p>
                *             </li>
                *          </ul>
                *         <note>
                *             <p>The partition key of an item is also known as its <i>hash
                *                     attribute</i>. The term "hash attribute" derives from DynamoDB's usage of
                *                 an internal hash function to evenly distribute data items across partitions, based
                *                 on their partition key values.</p>
                *             <p>The sort key of an item is also known as its <i>range attribute</i>.
                *                 The term "range attribute" derives from the way DynamoDB stores items with the same
                *                 partition key physically close together, in sorted order by the sort key
                *                 value.</p>
                *         </note>
                */
            KeySchema?: KeySchemaElement[];
            /**
                * <p>Represents attributes that are copied (projected) from the table into the global
                *             secondary index. These are in addition to the primary key attributes and index key
                *             attributes, which are automatically projected. </p>
                */
            Projection?: Projection;
            /**
                * <p>The total size of the specified index, in bytes. DynamoDB updates this value
                *             approximately every six hours. Recent changes might not be reflected in this
                *             value.</p>
                */
            IndexSizeBytes?: number;
            /**
                * <p>The number of items in the specified index. DynamoDB updates this value
                *             approximately every six hours. Recent changes might not be reflected in this
                *             value.</p>
                */
            ItemCount?: number;
            /**
                * <p>The Amazon Resource Name (ARN) that uniquely identifies the index.</p>
                */
            IndexArn?: string;
    }
    export namespace LocalSecondaryIndexDescription {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: LocalSecondaryIndexDescription) => any;
    }
    /**
        * <p>Contains details for the restore.</p>
        */
    export interface RestoreSummary {
            /**
                * <p>The Amazon Resource Name (ARN) of the backup from which the table was restored.</p>
                */
            SourceBackupArn?: string;
            /**
                * <p>The ARN of the source table of the backup that is being restored.</p>
                */
            SourceTableArn?: string;
            /**
                * <p>Point in time or source backup time.</p>
                */
            RestoreDateTime: Date | undefined;
            /**
                * <p>Indicates if a restore is in progress or not.</p>
                */
            RestoreInProgress: boolean | undefined;
    }
    export namespace RestoreSummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RestoreSummary) => any;
    }
    export type TableStatus = "ACTIVE" | "ARCHIVED" | "ARCHIVING" | "CREATING" | "DELETING" | "INACCESSIBLE_ENCRYPTION_CREDENTIALS" | "UPDATING";
    /**
        * <p>Represents the properties of a table.</p>
        */
    export interface TableDescription {
            /**
                * <p>An array of <code>AttributeDefinition</code> objects. Each of these objects describes
                *             one attribute in the table and index key schema.</p>
                *         <p>Each <code>AttributeDefinition</code> object in this array is composed of:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>AttributeName</code> - The name of the attribute.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>AttributeType</code> - The data type for the attribute.</p>
                *             </li>
                *          </ul>
                */
            AttributeDefinitions?: AttributeDefinition[];
            /**
                * <p>The name of the table.</p>
                */
            TableName?: string;
            /**
                * <p>The primary key structure for the table. Each <code>KeySchemaElement</code> consists
                *             of:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>AttributeName</code> - The name of the attribute.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>KeyType</code> - The role of the attribute:</p>
                *                 <ul>
                *                   <li>
                *                         <p>
                *                             <code>HASH</code> - partition key</p>
                *                     </li>
                *                   <li>
                *                         <p>
                *                             <code>RANGE</code> - sort key</p>
                *                     </li>
                *                </ul>
                *                 <note>
                *                     <p>The partition key of an item is also known as its <i>hash
                *                             attribute</i>. The term "hash attribute" derives from DynamoDB's
                *                         usage of an internal hash function to evenly distribute data items across
                *                         partitions, based on their partition key values.</p>
                *                     <p>The sort key of an item is also known as its <i>range
                *                             attribute</i>. The term "range attribute" derives from the way
                *                         DynamoDB stores items with the same partition key physically close together,
                *                         in sorted order by the sort key value.</p>
                *                 </note>
                *
                *             </li>
                *          </ul>
                *         <p>For more information about primary keys, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DataModel.html#DataModelPrimaryKey">Primary Key</a> in the <i>Amazon DynamoDB Developer
                *             Guide</i>.</p>
                */
            KeySchema?: KeySchemaElement[];
            /**
                * <p>The current state of the table:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>CREATING</code> - The table is being created.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>UPDATING</code> - The table is being updated.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>DELETING</code> - The table is being deleted.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>ACTIVE</code> - The table is ready for use.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>INACCESSIBLE_ENCRYPTION_CREDENTIALS</code> - The KMS key
                *                     used to encrypt the table in inaccessible. Table operations may fail due to
                *                     failure to use the KMS key. DynamoDB will initiate the
                *                     table archival process when a table's KMS key remains
                *                     inaccessible for more than seven days. </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>ARCHIVING</code> - The table is being archived. Operations are not allowed
                *                     until archival is complete. </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>ARCHIVED</code> - The table has been archived. See the ArchivalReason for
                *                     more information. </p>
                *             </li>
                *          </ul>
                */
            TableStatus?: TableStatus | string;
            /**
                * <p>The date and time when the table was created, in <a href="http://www.epochconverter.com/">UNIX epoch time</a> format.</p>
                */
            CreationDateTime?: Date;
            /**
                * <p>The provisioned throughput settings for the table, consisting of read and write
                *             capacity units, along with data about increases and decreases.</p>
                */
            ProvisionedThroughput?: ProvisionedThroughputDescription;
            /**
                * <p>The total size of the specified table, in bytes. DynamoDB updates this value
                *             approximately every six hours. Recent changes might not be reflected in this
                *             value.</p>
                */
            TableSizeBytes?: number;
            /**
                * <p>The number of items in the specified table. DynamoDB updates this value approximately
                *             every six hours. Recent changes might not be reflected in this value.</p>
                */
            ItemCount?: number;
            /**
                * <p>The Amazon Resource Name (ARN) that uniquely identifies the table.</p>
                */
            TableArn?: string;
            /**
                * <p>Unique identifier for the table for which the backup was created. </p>
                */
            TableId?: string;
            /**
                * <p>Contains the details for the read/write capacity mode.</p>
                */
            BillingModeSummary?: BillingModeSummary;
            /**
                * <p>Represents one or more local secondary indexes on the table. Each index is scoped to a
                *             given partition key value. Tables with one or more local secondary indexes are subject
                *             to an item collection size limit, where the amount of data within a given item
                *             collection cannot exceed 10 GB. Each element is composed of:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>IndexName</code> - The name of the local secondary index.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>KeySchema</code> - Specifies the complete index key schema. The attribute
                *                     names in the key schema must be between 1 and 255 characters (inclusive). The
                *                     key schema must begin with the same partition key as the table.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>Projection</code> - Specifies attributes that are copied (projected) from
                *                     the table into the index. These are in addition to the primary key attributes
                *                     and index key attributes, which are automatically projected. Each attribute
                *                     specification is composed of:</p>
                *                 <ul>
                *                   <li>
                *                         <p>
                *                             <code>ProjectionType</code> - One of the following:</p>
                *                         <ul>
                *                         <li>
                *                                 <p>
                *                                     <code>KEYS_ONLY</code> - Only the index and primary keys are
                *                                     projected into the index.</p>
                *                             </li>
                *                         <li>
                *                                 <p>
                *                                     <code>INCLUDE</code> - Only the specified table attributes are
                *                                     projected into the index. The list of projected attributes is in
                *                                         <code>NonKeyAttributes</code>.</p>
                *                             </li>
                *                         <li>
                *                                 <p>
                *                                     <code>ALL</code> - All of the table attributes are projected
                *                                     into the index.</p>
                *                             </li>
                *                      </ul>
                *                     </li>
                *                   <li>
                *                         <p>
                *                             <code>NonKeyAttributes</code> - A list of one or more non-key attribute
                *                             names that are projected into the secondary index. The total count of
                *                             attributes provided in <code>NonKeyAttributes</code>, summed across all
                *                             of the secondary indexes, must not exceed 100. If you project the same
                *                             attribute into two different indexes, this counts as two distinct
                *                             attributes when determining the total.</p>
                *                     </li>
                *                </ul>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>IndexSizeBytes</code> - Represents the total size of the index, in bytes.
                *                     DynamoDB updates this value approximately every six hours. Recent changes might
                *                     not be reflected in this value.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>ItemCount</code> - Represents the number of items in the index. DynamoDB
                *                     updates this value approximately every six hours. Recent changes might not be
                *                     reflected in this value.</p>
                *             </li>
                *          </ul>
                *         <p>If the table is in the <code>DELETING</code> state, no information about indexes will
                *             be returned.</p>
                */
            LocalSecondaryIndexes?: LocalSecondaryIndexDescription[];
            /**
                * <p>The global secondary indexes, if any, on the table. Each index is scoped to a given
                *             partition key value. Each element is composed of:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>Backfilling</code> - If true, then the index is currently in the
                *                     backfilling phase. Backfilling occurs only when a new global secondary index is
                *                     added to the table. It is the process by which DynamoDB populates the new index
                *                     with data from the table. (This attribute does not appear for indexes that were
                *                     created during a <code>CreateTable</code> operation.) </p>
                *                 <p> You can delete an index that is being created during the
                *                         <code>Backfilling</code> phase when <code>IndexStatus</code> is set to
                *                     CREATING and <code>Backfilling</code> is true. You can't delete the index that
                *                     is being created when <code>IndexStatus</code> is set to CREATING and
                *                         <code>Backfilling</code> is false. (This attribute does not appear for
                *                     indexes that were created during a <code>CreateTable</code> operation.)</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>IndexName</code> - The name of the global secondary index.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>IndexSizeBytes</code> - The total size of the global secondary index, in
                *                     bytes. DynamoDB updates this value approximately every six hours. Recent changes
                *                     might not be reflected in this value. </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>IndexStatus</code> - The current status of the global secondary
                *                     index:</p>
                *                 <ul>
                *                   <li>
                *                         <p>
                *                             <code>CREATING</code> - The index is being created.</p>
                *                     </li>
                *                   <li>
                *                         <p>
                *                             <code>UPDATING</code> - The index is being updated.</p>
                *                     </li>
                *                   <li>
                *                         <p>
                *                             <code>DELETING</code> - The index is being deleted.</p>
                *                     </li>
                *                   <li>
                *                         <p>
                *                             <code>ACTIVE</code> - The index is ready for use.</p>
                *                     </li>
                *                </ul>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>ItemCount</code> - The number of items in the global secondary index.
                *                     DynamoDB updates this value approximately every six hours. Recent changes might
                *                     not be reflected in this value. </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>KeySchema</code> - Specifies the complete index key schema. The attribute
                *                     names in the key schema must be between 1 and 255 characters (inclusive). The
                *                     key schema must begin with the same partition key as the table.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>Projection</code> - Specifies attributes that are copied (projected) from
                *                     the table into the index. These are in addition to the primary key attributes
                *                     and index key attributes, which are automatically projected. Each attribute
                *                     specification is composed of:</p>
                *                 <ul>
                *                   <li>
                *                         <p>
                *                             <code>ProjectionType</code> - One of the following:</p>
                *                         <ul>
                *                         <li>
                *                                 <p>
                *                                     <code>KEYS_ONLY</code> - Only the index and primary keys are
                *                                     projected into the index.</p>
                *                             </li>
                *                         <li>
                *                                 <p>
                *                                     <code>INCLUDE</code> - In addition to the attributes described
                *                                     in <code>KEYS_ONLY</code>, the secondary index will include
                *                                     other non-key attributes that you specify.</p>
                *                             </li>
                *                         <li>
                *                                 <p>
                *                                     <code>ALL</code> - All of the table attributes are projected
                *                                     into the index.</p>
                *                             </li>
                *                      </ul>
                *                     </li>
                *                   <li>
                *                         <p>
                *                             <code>NonKeyAttributes</code> - A list of one or more non-key attribute
                *                             names that are projected into the secondary index. The total count of
                *                             attributes provided in <code>NonKeyAttributes</code>, summed across all
                *                             of the secondary indexes, must not exceed 100. If you project the same
                *                             attribute into two different indexes, this counts as two distinct
                *                             attributes when determining the total.</p>
                *                     </li>
                *                </ul>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>ProvisionedThroughput</code> - The provisioned throughput settings for the
                *                     global secondary index, consisting of read and write capacity units, along with
                *                     data about increases and decreases. </p>
                *             </li>
                *          </ul>
                *         <p>If the table is in the <code>DELETING</code> state, no information about indexes will
                *             be returned.</p>
                */
            GlobalSecondaryIndexes?: GlobalSecondaryIndexDescription[];
            /**
                * <p>The current DynamoDB Streams configuration for the table.</p>
                */
            StreamSpecification?: StreamSpecification;
            /**
                * <p>A timestamp, in ISO 8601 format, for this stream.</p>
                *
                *         <p>Note that <code>LatestStreamLabel</code> is not a unique identifier for the stream,
                *             because it is possible that a stream from another table might have the same timestamp.
                *             However, the combination of the following three elements is guaranteed to be
                *             unique:</p>
                *         <ul>
                *             <li>
                *                 <p>Amazon Web Services customer ID</p>
                *             </li>
                *             <li>
                *                 <p>Table name</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>StreamLabel</code>
                *                </p>
                *             </li>
                *          </ul>
                */
            LatestStreamLabel?: string;
            /**
                * <p>The Amazon Resource Name (ARN) that uniquely identifies the latest stream for this
                *             table.</p>
                */
            LatestStreamArn?: string;
            /**
                * <p>Represents the version of <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GlobalTables.html">global tables</a>
                *             in use, if the table is replicated across Amazon Web Services Regions.</p>
                */
            GlobalTableVersion?: string;
            /**
                * <p>Represents replicas of the table.</p>
                */
            Replicas?: ReplicaDescription[];
            /**
                * <p>Contains details for the restore.</p>
                */
            RestoreSummary?: RestoreSummary;
            /**
                * <p>The description of the server-side encryption status on the specified table.</p>
                */
            SSEDescription?: SSEDescription;
            /**
                * <p>Contains information about the table archive.</p>
                */
            ArchivalSummary?: ArchivalSummary;
            /**
                * <p>Contains details of the table class.</p>
                */
            TableClassSummary?: TableClassSummary;
    }
    export namespace TableDescription {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TableDescription) => any;
    }
    /**
        * <p>Represents the output of a <code>CreateTable</code> operation.</p>
        */
    export interface CreateTableOutput {
            /**
                * <p>Represents the properties of the table.</p>
                */
            TableDescription?: TableDescription;
    }
    export namespace CreateTableOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CreateTableOutput) => any;
    }
    /**
        * <p>The operation conflicts with the resource's availability. For example, you
        *             attempted to recreate an existing table, or tried to delete a table currently in the
        *                 <code>CREATING</code> state.</p>
        */
    export class ResourceInUseException extends __BaseException {
            readonly name: "ResourceInUseException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ResourceInUseException, __BaseException>);
    }
    export interface DeleteBackupInput {
            /**
                * <p>The ARN associated with the backup.</p>
                */
            BackupArn: string | undefined;
    }
    export namespace DeleteBackupInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteBackupInput) => any;
    }
    export interface DeleteBackupOutput {
            /**
                * <p>Contains the description of the backup created for the table.</p>
                */
            BackupDescription?: BackupDescription;
    }
    export namespace DeleteBackupOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteBackupOutput) => any;
    }
    /**
        * <p>Represents a global secondary index to be deleted from an existing table.</p>
        */
    export interface DeleteGlobalSecondaryIndexAction {
            /**
                * <p>The name of the global secondary index to be deleted.</p>
                */
            IndexName: string | undefined;
    }
    export namespace DeleteGlobalSecondaryIndexAction {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteGlobalSecondaryIndexAction) => any;
    }
    export type ReturnValue = "ALL_NEW" | "ALL_OLD" | "NONE" | "UPDATED_NEW" | "UPDATED_OLD";
    /**
        * <p>Operation was rejected because there is an ongoing transaction for the
        *             item.</p>
        */
    export class TransactionConflictException extends __BaseException {
            readonly name: "TransactionConflictException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TransactionConflictException, __BaseException>);
    }
    /**
        * <p>Represents a replica to be removed.</p>
        */
    export interface DeleteReplicaAction {
            /**
                * <p>The Region of the replica to be removed.</p>
                */
            RegionName: string | undefined;
    }
    export namespace DeleteReplicaAction {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteReplicaAction) => any;
    }
    /**
        * <p>Represents a replica to be deleted.</p>
        */
    export interface DeleteReplicationGroupMemberAction {
            /**
                * <p>The Region where the replica exists.</p>
                */
            RegionName: string | undefined;
    }
    export namespace DeleteReplicationGroupMemberAction {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteReplicationGroupMemberAction) => any;
    }
    /**
        * <p>Represents the input of a <code>DeleteTable</code> operation.</p>
        */
    export interface DeleteTableInput {
            /**
                * <p>The name of the table to delete.</p>
                */
            TableName: string | undefined;
    }
    export namespace DeleteTableInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteTableInput) => any;
    }
    /**
        * <p>Represents the output of a <code>DeleteTable</code> operation.</p>
        */
    export interface DeleteTableOutput {
            /**
                * <p>Represents the properties of a table.</p>
                */
            TableDescription?: TableDescription;
    }
    export namespace DeleteTableOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteTableOutput) => any;
    }
    export interface DescribeBackupInput {
            /**
                * <p>The Amazon Resource Name (ARN) associated with the backup.</p>
                */
            BackupArn: string | undefined;
    }
    export namespace DescribeBackupInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeBackupInput) => any;
    }
    export interface DescribeBackupOutput {
            /**
                * <p>Contains the description of the backup created for the table.</p>
                */
            BackupDescription?: BackupDescription;
    }
    export namespace DescribeBackupOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeBackupOutput) => any;
    }
    export interface DescribeContinuousBackupsInput {
            /**
                * <p>Name of the table for which the customer wants to check the continuous backups and
                *             point in time recovery settings.</p>
                */
            TableName: string | undefined;
    }
    export namespace DescribeContinuousBackupsInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeContinuousBackupsInput) => any;
    }
    export interface DescribeContinuousBackupsOutput {
            /**
                * <p>Represents the continuous backups and point in time recovery settings on the
                *             table.</p>
                */
            ContinuousBackupsDescription?: ContinuousBackupsDescription;
    }
    export namespace DescribeContinuousBackupsOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeContinuousBackupsOutput) => any;
    }
    export interface DescribeContributorInsightsInput {
            /**
                * <p>The name of the table to describe.</p>
                */
            TableName: string | undefined;
            /**
                * <p>The name of the global secondary index to describe, if applicable.</p>
                */
            IndexName?: string;
    }
    export namespace DescribeContributorInsightsInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeContributorInsightsInput) => any;
    }
    /**
        * <p>Represents a failure a contributor insights operation.</p>
        */
    export interface FailureException {
            /**
                * <p>Exception name.</p>
                */
            ExceptionName?: string;
            /**
                * <p>Description of the failure.</p>
                */
            ExceptionDescription?: string;
    }
    export namespace FailureException {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: FailureException) => any;
    }
    export interface DescribeContributorInsightsOutput {
            /**
                * <p>The name of the table being described.</p>
                */
            TableName?: string;
            /**
                * <p>The name of the global secondary index being described.</p>
                */
            IndexName?: string;
            /**
                * <p>List of names of the associated contributor insights rules.</p>
                */
            ContributorInsightsRuleList?: string[];
            /**
                * <p>Current status of contributor insights.</p>
                */
            ContributorInsightsStatus?: ContributorInsightsStatus | string;
            /**
                * <p>Timestamp of the last time the status was changed.</p>
                */
            LastUpdateDateTime?: Date;
            /**
                * <p>Returns information about the last failure that was encountered.</p>
                *         <p>The most common exceptions for a FAILED status are:</p>
                *         <ul>
                *             <li>
                *                 <p>LimitExceededException - Per-account Amazon CloudWatch Contributor Insights
                *                     rule limit reached. Please disable Contributor Insights for other tables/indexes
                *                     OR disable Contributor Insights rules before retrying.</p>
                *             </li>
                *             <li>
                *                 <p>AccessDeniedException - Amazon CloudWatch Contributor Insights rules cannot be
                *                     modified due to insufficient permissions.</p>
                *             </li>
                *             <li>
                *                 <p>AccessDeniedException - Failed to create service-linked role for Contributor
                *                     Insights due to insufficient permissions.</p>
                *             </li>
                *             <li>
                *                 <p>InternalServerError - Failed to create Amazon CloudWatch Contributor Insights
                *                     rules. Please retry request.</p>
                *             </li>
                *          </ul>
                */
            FailureException?: FailureException;
    }
    export namespace DescribeContributorInsightsOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeContributorInsightsOutput) => any;
    }
    export interface DescribeEndpointsRequest {
    }
    export namespace DescribeEndpointsRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeEndpointsRequest) => any;
    }
    /**
        * <p>An endpoint information details.</p>
        */
    export interface Endpoint {
            /**
                * <p>IP address of the endpoint.</p>
                */
            Address: string | undefined;
            /**
                * <p>Endpoint cache time to live (TTL) value.</p>
                */
            CachePeriodInMinutes: number | undefined;
    }
    export namespace Endpoint {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Endpoint) => any;
    }
    export interface DescribeEndpointsResponse {
            /**
                * <p>List of endpoints.</p>
                */
            Endpoints: Endpoint[] | undefined;
    }
    export namespace DescribeEndpointsResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeEndpointsResponse) => any;
    }
    export interface DescribeExportInput {
            /**
                * <p>The Amazon Resource Name (ARN) associated with the export.</p>
                */
            ExportArn: string | undefined;
    }
    export namespace DescribeExportInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeExportInput) => any;
    }
    export enum ExportFormat {
            DYNAMODB_JSON = "DYNAMODB_JSON",
            ION = "ION"
    }
    export enum ExportStatus {
            COMPLETED = "COMPLETED",
            FAILED = "FAILED",
            IN_PROGRESS = "IN_PROGRESS"
    }
    export type S3SseAlgorithm = "AES256" | "KMS";
    /**
        * <p>Represents the properties of the exported table.</p>
        */
    export interface ExportDescription {
            /**
                * <p>The Amazon Resource Name (ARN) of the table export.</p>
                */
            ExportArn?: string;
            /**
                * <p>Export can be in one of the following states: IN_PROGRESS, COMPLETED, or
                *             FAILED.</p>
                */
            ExportStatus?: ExportStatus | string;
            /**
                * <p>The time at which the export task began.</p>
                */
            StartTime?: Date;
            /**
                * <p>The time at which the export task completed.</p>
                */
            EndTime?: Date;
            /**
                * <p>The name of the manifest file for the export task.</p>
                */
            ExportManifest?: string;
            /**
                * <p>The Amazon Resource Name (ARN) of the table that was exported.</p>
                */
            TableArn?: string;
            /**
                * <p>Unique ID of the table that was exported.</p>
                */
            TableId?: string;
            /**
                * <p>Point in time from which table data was exported.</p>
                */
            ExportTime?: Date;
            /**
                * <p>The client token that was provided for the export task. A client token makes calls to
                *                 <code>ExportTableToPointInTimeInput</code> idempotent, meaning that multiple
                *             identical calls have the same effect as one single call.</p>
                */
            ClientToken?: string;
            /**
                * <p>The name of the Amazon S3 bucket containing the export.</p>
                */
            S3Bucket?: string;
            /**
                * <p>The ID of the Amazon Web Services account that owns the bucket containing the
                *             export.</p>
                */
            S3BucketOwner?: string;
            /**
                * <p>The Amazon S3 bucket prefix used as the file name and path of the exported
                *             snapshot.</p>
                */
            S3Prefix?: string;
            /**
                * <p>Type of encryption used on the bucket where export data is stored. Valid values for
                *                 <code>S3SseAlgorithm</code> are:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                   <code>AES256</code> - server-side encryption with Amazon S3 managed
                *                     keys</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>KMS</code> - server-side encryption with KMS managed
                *                     keys</p>
                *             </li>
                *          </ul>
                */
            S3SseAlgorithm?: S3SseAlgorithm | string;
            /**
                * <p>The ID of the KMS managed key used to encrypt the S3 bucket where
                *             export data is stored (if applicable).</p>
                */
            S3SseKmsKeyId?: string;
            /**
                * <p>Status code for the result of the failed export.</p>
                */
            FailureCode?: string;
            /**
                * <p>Export failure reason description.</p>
                */
            FailureMessage?: string;
            /**
                * <p>The format of the exported data. Valid values for <code>ExportFormat</code> are
                *                 <code>DYNAMODB_JSON</code> or <code>ION</code>.</p>
                */
            ExportFormat?: ExportFormat | string;
            /**
                * <p>The billable size of the table export.</p>
                */
            BilledSizeBytes?: number;
            /**
                * <p>The number of items exported.</p>
                */
            ItemCount?: number;
    }
    export namespace ExportDescription {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ExportDescription) => any;
    }
    export interface DescribeExportOutput {
            /**
                * <p>Represents the properties of the export.</p>
                */
            ExportDescription?: ExportDescription;
    }
    export namespace DescribeExportOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeExportOutput) => any;
    }
    /**
        * <p>The specified export was not found.</p>
        */
    export class ExportNotFoundException extends __BaseException {
            readonly name: "ExportNotFoundException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ExportNotFoundException, __BaseException>);
    }
    export interface DescribeGlobalTableInput {
            /**
                * <p>The name of the global table.</p>
                */
            GlobalTableName: string | undefined;
    }
    export namespace DescribeGlobalTableInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeGlobalTableInput) => any;
    }
    export interface DescribeGlobalTableOutput {
            /**
                * <p>Contains the details of the global table.</p>
                */
            GlobalTableDescription?: GlobalTableDescription;
    }
    export namespace DescribeGlobalTableOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeGlobalTableOutput) => any;
    }
    /**
        * <p>The specified global table does not exist.</p>
        */
    export class GlobalTableNotFoundException extends __BaseException {
            readonly name: "GlobalTableNotFoundException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<GlobalTableNotFoundException, __BaseException>);
    }
    export interface DescribeGlobalTableSettingsInput {
            /**
                * <p>The name of the global table to describe.</p>
                */
            GlobalTableName: string | undefined;
    }
    export namespace DescribeGlobalTableSettingsInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeGlobalTableSettingsInput) => any;
    }
    /**
        * <p>Represents the properties of a global secondary index.</p>
        */
    export interface ReplicaGlobalSecondaryIndexSettingsDescription {
            /**
                * <p>The name of the global secondary index. The name must be unique among all other
                *             indexes on this table.</p>
                */
            IndexName: string | undefined;
            /**
                * <p> The current status of the global secondary index:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>CREATING</code> - The global secondary index is being created.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>UPDATING</code> - The global secondary index is being updated.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>DELETING</code> - The global secondary index is being deleted.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>ACTIVE</code> - The global secondary index is ready for use.</p>
                *             </li>
                *          </ul>
                */
            IndexStatus?: IndexStatus | string;
            /**
                * <p>The maximum number of strongly consistent reads consumed per second before DynamoDB
                *             returns a <code>ThrottlingException</code>.</p>
                */
            ProvisionedReadCapacityUnits?: number;
            /**
                * <p>Auto scaling settings for a global secondary index replica's read capacity
                *             units.</p>
                */
            ProvisionedReadCapacityAutoScalingSettings?: AutoScalingSettingsDescription;
            /**
                * <p>The maximum number of writes consumed per second before DynamoDB returns a
                *                 <code>ThrottlingException</code>.</p>
                */
            ProvisionedWriteCapacityUnits?: number;
            /**
                * <p>Auto scaling settings for a global secondary index replica's write capacity
                *             units.</p>
                */
            ProvisionedWriteCapacityAutoScalingSettings?: AutoScalingSettingsDescription;
    }
    export namespace ReplicaGlobalSecondaryIndexSettingsDescription {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ReplicaGlobalSecondaryIndexSettingsDescription) => any;
    }
    /**
        * <p>Represents the properties of a replica.</p>
        */
    export interface ReplicaSettingsDescription {
            /**
                * <p>The Region name of the replica.</p>
                */
            RegionName: string | undefined;
            /**
                * <p>The current state of the Region:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>CREATING</code> - The Region is being created.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>UPDATING</code> - The Region is being updated.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>DELETING</code> - The Region is being deleted.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>ACTIVE</code> - The Region is ready for use.</p>
                *             </li>
                *          </ul>
                */
            ReplicaStatus?: ReplicaStatus | string;
            /**
                * <p>The read/write capacity mode of the replica.</p>
                */
            ReplicaBillingModeSummary?: BillingModeSummary;
            /**
                * <p>The maximum number of strongly consistent reads consumed per second before DynamoDB
                *             returns a <code>ThrottlingException</code>. For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html#ProvisionedThroughput">Specifying Read and Write Requirements</a> in the <i>Amazon DynamoDB
                *                 Developer Guide</i>. </p>
                */
            ReplicaProvisionedReadCapacityUnits?: number;
            /**
                * <p>Auto scaling settings for a global table replica's read capacity units.</p>
                */
            ReplicaProvisionedReadCapacityAutoScalingSettings?: AutoScalingSettingsDescription;
            /**
                * <p>The maximum number of writes consumed per second before DynamoDB returns a
                *                 <code>ThrottlingException</code>. For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html#ProvisionedThroughput">Specifying Read and Write Requirements</a> in the <i>Amazon DynamoDB
                *                 Developer Guide</i>.</p>
                */
            ReplicaProvisionedWriteCapacityUnits?: number;
            /**
                * <p>Auto scaling settings for a global table replica's write capacity units.</p>
                */
            ReplicaProvisionedWriteCapacityAutoScalingSettings?: AutoScalingSettingsDescription;
            /**
                * <p>Replica global secondary index settings for the global table.</p>
                */
            ReplicaGlobalSecondaryIndexSettings?: ReplicaGlobalSecondaryIndexSettingsDescription[];
            /**
                * <p>Contains details of the table class.</p>
                */
            ReplicaTableClassSummary?: TableClassSummary;
    }
    export namespace ReplicaSettingsDescription {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ReplicaSettingsDescription) => any;
    }
    export interface DescribeGlobalTableSettingsOutput {
            /**
                * <p>The name of the global table.</p>
                */
            GlobalTableName?: string;
            /**
                * <p>The Region-specific settings for the global table.</p>
                */
            ReplicaSettings?: ReplicaSettingsDescription[];
    }
    export namespace DescribeGlobalTableSettingsOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeGlobalTableSettingsOutput) => any;
    }
    export interface DescribeKinesisStreamingDestinationInput {
            /**
                * <p>The name of the table being described.</p>
                */
            TableName: string | undefined;
    }
    export namespace DescribeKinesisStreamingDestinationInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeKinesisStreamingDestinationInput) => any;
    }
    export type DestinationStatus = "ACTIVE" | "DISABLED" | "DISABLING" | "ENABLE_FAILED" | "ENABLING";
    /**
        * <p>Describes a Kinesis data stream destination.</p>
        */
    export interface KinesisDataStreamDestination {
            /**
                * <p>The ARN for a specific Kinesis data stream.</p>
                */
            StreamArn?: string;
            /**
                * <p>The current status of replication.</p>
                */
            DestinationStatus?: DestinationStatus | string;
            /**
                * <p>The human-readable string that corresponds to the replica status.</p>
                */
            DestinationStatusDescription?: string;
    }
    export namespace KinesisDataStreamDestination {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: KinesisDataStreamDestination) => any;
    }
    export interface DescribeKinesisStreamingDestinationOutput {
            /**
                * <p>The name of the table being described.</p>
                */
            TableName?: string;
            /**
                * <p>The list of replica structures for the table being described.</p>
                */
            KinesisDataStreamDestinations?: KinesisDataStreamDestination[];
    }
    export namespace DescribeKinesisStreamingDestinationOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeKinesisStreamingDestinationOutput) => any;
    }
    /**
        * <p>Represents the input of a <code>DescribeLimits</code> operation. Has no
        *             content.</p>
        */
    export interface DescribeLimitsInput {
    }
    export namespace DescribeLimitsInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeLimitsInput) => any;
    }
    /**
        * <p>Represents the output of a <code>DescribeLimits</code> operation.</p>
        */
    export interface DescribeLimitsOutput {
            /**
                * <p>The maximum total read capacity units that your account allows you to provision across
                *             all of your tables in this Region.</p>
                */
            AccountMaxReadCapacityUnits?: number;
            /**
                * <p>The maximum total write capacity units that your account allows you to provision
                *             across all of your tables in this Region.</p>
                */
            AccountMaxWriteCapacityUnits?: number;
            /**
                * <p>The maximum read capacity units that your account allows you to provision for a new
                *             table that you are creating in this Region, including the read capacity units
                *             provisioned for its global secondary indexes (GSIs).</p>
                */
            TableMaxReadCapacityUnits?: number;
            /**
                * <p>The maximum write capacity units that your account allows you to provision for a new
                *             table that you are creating in this Region, including the write capacity units
                *             provisioned for its global secondary indexes (GSIs).</p>
                */
            TableMaxWriteCapacityUnits?: number;
    }
    export namespace DescribeLimitsOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeLimitsOutput) => any;
    }
    /**
        * <p>Represents the input of a <code>DescribeTable</code> operation.</p>
        */
    export interface DescribeTableInput {
            /**
                * <p>The name of the table to describe.</p>
                */
            TableName: string | undefined;
    }
    export namespace DescribeTableInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeTableInput) => any;
    }
    /**
        * <p>Represents the output of a <code>DescribeTable</code> operation.</p>
        */
    export interface DescribeTableOutput {
            /**
                * <p>The properties of the table.</p>
                */
            Table?: TableDescription;
    }
    export namespace DescribeTableOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeTableOutput) => any;
    }
    export interface DescribeTableReplicaAutoScalingInput {
            /**
                * <p>The name of the table.</p>
                */
            TableName: string | undefined;
    }
    export namespace DescribeTableReplicaAutoScalingInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeTableReplicaAutoScalingInput) => any;
    }
    /**
        * <p>Represents the auto scaling configuration for a replica global secondary index.</p>
        */
    export interface ReplicaGlobalSecondaryIndexAutoScalingDescription {
            /**
                * <p>The name of the global secondary index.</p>
                */
            IndexName?: string;
            /**
                * <p>The current state of the replica global secondary index:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>CREATING</code> - The index is being created.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>UPDATING</code> - The index is being updated.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>DELETING</code> - The index is being deleted.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>ACTIVE</code> - The index is ready for use.</p>
                *             </li>
                *          </ul>
                */
            IndexStatus?: IndexStatus | string;
            /**
                * <p>Represents the auto scaling settings for a global table or global secondary
                *             index.</p>
                */
            ProvisionedReadCapacityAutoScalingSettings?: AutoScalingSettingsDescription;
            /**
                * <p>Represents the auto scaling settings for a global table or global secondary
                *             index.</p>
                */
            ProvisionedWriteCapacityAutoScalingSettings?: AutoScalingSettingsDescription;
    }
    export namespace ReplicaGlobalSecondaryIndexAutoScalingDescription {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ReplicaGlobalSecondaryIndexAutoScalingDescription) => any;
    }
    /**
        * <p>Represents the auto scaling settings of the replica.</p>
        */
    export interface ReplicaAutoScalingDescription {
            /**
                * <p>The Region where the replica exists.</p>
                */
            RegionName?: string;
            /**
                * <p>Replica-specific global secondary index auto scaling settings.</p>
                */
            GlobalSecondaryIndexes?: ReplicaGlobalSecondaryIndexAutoScalingDescription[];
            /**
                * <p>Represents the auto scaling settings for a global table or global secondary
                *             index.</p>
                */
            ReplicaProvisionedReadCapacityAutoScalingSettings?: AutoScalingSettingsDescription;
            /**
                * <p>Represents the auto scaling settings for a global table or global secondary
                *             index.</p>
                */
            ReplicaProvisionedWriteCapacityAutoScalingSettings?: AutoScalingSettingsDescription;
            /**
                * <p>The current state of the replica:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>CREATING</code> - The replica is being created.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>UPDATING</code> - The replica is being updated.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>DELETING</code> - The replica is being deleted.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>ACTIVE</code> - The replica is ready for use.</p>
                *             </li>
                *          </ul>
                */
            ReplicaStatus?: ReplicaStatus | string;
    }
    export namespace ReplicaAutoScalingDescription {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ReplicaAutoScalingDescription) => any;
    }
    /**
        * <p>Represents the auto scaling configuration for a global table.</p>
        */
    export interface TableAutoScalingDescription {
            /**
                * <p>The name of the table.</p>
                */
            TableName?: string;
            /**
                * <p>The current state of the table:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>CREATING</code> - The table is being created.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>UPDATING</code> - The table is being updated.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>DELETING</code> - The table is being deleted.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>ACTIVE</code> - The table is ready for use.</p>
                *             </li>
                *          </ul>
                */
            TableStatus?: TableStatus | string;
            /**
                * <p>Represents replicas of the global table.</p>
                */
            Replicas?: ReplicaAutoScalingDescription[];
    }
    export namespace TableAutoScalingDescription {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TableAutoScalingDescription) => any;
    }
    export interface DescribeTableReplicaAutoScalingOutput {
            /**
                * <p>Represents the auto scaling properties of the table.</p>
                */
            TableAutoScalingDescription?: TableAutoScalingDescription;
    }
    export namespace DescribeTableReplicaAutoScalingOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeTableReplicaAutoScalingOutput) => any;
    }
    export interface DescribeTimeToLiveInput {
            /**
                * <p>The name of the table to be described.</p>
                */
            TableName: string | undefined;
    }
    export namespace DescribeTimeToLiveInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeTimeToLiveInput) => any;
    }
    export interface DescribeTimeToLiveOutput {
            /**
                * <p></p>
                */
            TimeToLiveDescription?: TimeToLiveDescription;
    }
    export namespace DescribeTimeToLiveOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DescribeTimeToLiveOutput) => any;
    }
    export interface KinesisStreamingDestinationInput {
            /**
                * <p>The name of the DynamoDB table.</p>
                */
            TableName: string | undefined;
            /**
                * <p>The ARN for a Kinesis data stream.</p>
                */
            StreamArn: string | undefined;
    }
    export namespace KinesisStreamingDestinationInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: KinesisStreamingDestinationInput) => any;
    }
    export interface KinesisStreamingDestinationOutput {
            /**
                * <p>The name of the table being modified.</p>
                */
            TableName?: string;
            /**
                * <p>The ARN for the specific Kinesis data stream.</p>
                */
            StreamArn?: string;
            /**
                * <p>The current status of the replication.</p>
                */
            DestinationStatus?: DestinationStatus | string;
    }
    export namespace KinesisStreamingDestinationOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: KinesisStreamingDestinationOutput) => any;
    }
    /**
        * <p> There was an attempt to insert an item with the same primary key as an item that
        *             already exists in the DynamoDB table.</p>
        */
    export class DuplicateItemException extends __BaseException {
            readonly name: "DuplicateItemException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<DuplicateItemException, __BaseException>);
    }
    /**
        * <p>DynamoDB rejected the request because you retried a request with a
        *             different payload but with an idempotent token that was already used.</p>
        */
    export class IdempotentParameterMismatchException extends __BaseException {
            readonly name: "IdempotentParameterMismatchException";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<IdempotentParameterMismatchException, __BaseException>);
    }
    /**
        * <p>The transaction with the given request token is already in progress.</p>
        */
    export class TransactionInProgressException extends __BaseException {
            readonly name: "TransactionInProgressException";
            readonly $fault: "client";
            Message?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TransactionInProgressException, __BaseException>);
    }
    /**
        * <p>There was a conflict when writing to the specified S3 bucket.</p>
        */
    export class ExportConflictException extends __BaseException {
            readonly name: "ExportConflictException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ExportConflictException, __BaseException>);
    }
    export interface ExportTableToPointInTimeInput {
            /**
                * <p>The Amazon Resource Name (ARN) associated with the table to export.</p>
                */
            TableArn: string | undefined;
            /**
                * <p>Time in the past from which to export table data, counted in seconds from the start of
                *             the Unix epoch. The table export will be a snapshot of the table's state at this point
                *             in time.</p>
                */
            ExportTime?: Date;
            /**
                * <p>Providing a <code>ClientToken</code> makes the call to
                *                 <code>ExportTableToPointInTimeInput</code> idempotent, meaning that multiple
                *             identical calls have the same effect as one single call.</p>
                *         <p>A client token is valid for 8 hours after the first request that uses it is completed.
                *             After 8 hours, any request with the same client token is treated as a new request. Do
                *             not resubmit the same request with the same client token for more than 8 hours, or the
                *             result might not be idempotent.</p>
                *         <p>If you submit a request with the same client token but a change in other parameters
                *             within the 8-hour idempotency window, DynamoDB returns an
                *                 <code>IdempotentParameterMismatch</code> exception.</p>
                */
            ClientToken?: string;
            /**
                * <p>The name of the Amazon S3 bucket to export the snapshot to.</p>
                */
            S3Bucket: string | undefined;
            /**
                * <p>The ID of the Amazon Web Services account that owns the bucket the export will be
                *             stored in.</p>
                */
            S3BucketOwner?: string;
            /**
                * <p>The Amazon S3 bucket prefix to use as the file name and path of the exported
                *             snapshot.</p>
                */
            S3Prefix?: string;
            /**
                * <p>Type of encryption used on the bucket where export data will be stored. Valid values
                *             for <code>S3SseAlgorithm</code> are:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                   <code>AES256</code> - server-side encryption with Amazon S3 managed
                *                     keys</p>
                *             </li>
                *             <li>
                *                 <p>
                *                   <code>KMS</code> - server-side encryption with KMS managed
                *                     keys</p>
                *             </li>
                *          </ul>
                */
            S3SseAlgorithm?: S3SseAlgorithm | string;
            /**
                * <p>The ID of the KMS managed key used to encrypt the S3 bucket where
                *             export data will be stored (if applicable).</p>
                */
            S3SseKmsKeyId?: string;
            /**
                * <p>The format for the exported data. Valid values for <code>ExportFormat</code> are
                *                 <code>DYNAMODB_JSON</code> or <code>ION</code>.</p>
                */
            ExportFormat?: ExportFormat | string;
    }
    export namespace ExportTableToPointInTimeInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ExportTableToPointInTimeInput) => any;
    }
    export interface ExportTableToPointInTimeOutput {
            /**
                * <p>Contains a description of the table export.</p>
                */
            ExportDescription?: ExportDescription;
    }
    export namespace ExportTableToPointInTimeOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ExportTableToPointInTimeOutput) => any;
    }
    /**
        * <p>The specified <code>ExportTime</code> is outside of the point in time recovery
        *             window.</p>
        */
    export class InvalidExportTimeException extends __BaseException {
            readonly name: "InvalidExportTimeException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidExportTimeException, __BaseException>);
    }
    /**
        * <p>Point in time recovery has not yet been enabled for this source table.</p>
        */
    export class PointInTimeRecoveryUnavailableException extends __BaseException {
            readonly name: "PointInTimeRecoveryUnavailableException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<PointInTimeRecoveryUnavailableException, __BaseException>);
    }
    export interface ListBackupsInput {
            /**
                * <p>The backups from the table specified by <code>TableName</code> are listed. </p>
                */
            TableName?: string;
            /**
                * <p>Maximum number of backups to return at once.</p>
                */
            Limit?: number;
            /**
                * <p>Only backups created after this time are listed. <code>TimeRangeLowerBound</code> is
                *             inclusive.</p>
                */
            TimeRangeLowerBound?: Date;
            /**
                * <p>Only backups created before this time are listed. <code>TimeRangeUpperBound</code> is
                *             exclusive. </p>
                */
            TimeRangeUpperBound?: Date;
            /**
                * <p>
                *             <code>LastEvaluatedBackupArn</code> is the Amazon Resource Name (ARN) of the backup last
                *             evaluated when the current page of results was returned, inclusive of the current page
                *             of results. This value may be specified as the <code>ExclusiveStartBackupArn</code> of a
                *             new <code>ListBackups</code> operation in order to fetch the next page of results.
                *         </p>
                */
            ExclusiveStartBackupArn?: string;
            /**
                * <p>The backups from the table specified by <code>BackupType</code> are listed.</p>
                *         <p>Where <code>BackupType</code> can be:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>USER</code> - On-demand backup created by you. (The default setting if no other backup types are specified.)</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>SYSTEM</code> - On-demand backup automatically created by DynamoDB.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>ALL</code> - All types of on-demand backups (USER and SYSTEM).</p>
                *             </li>
                *          </ul>
                */
            BackupType?: BackupTypeFilter | string;
    }
    export namespace ListBackupsInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListBackupsInput) => any;
    }
    export interface ListBackupsOutput {
            /**
                * <p>List of <code>BackupSummary</code> objects.</p>
                */
            BackupSummaries?: BackupSummary[];
            /**
                * <p> The ARN of the backup last evaluated when the current page of results was returned,
                *             inclusive of the current page of results. This value may be specified as the
                *                 <code>ExclusiveStartBackupArn</code> of a new <code>ListBackups</code> operation in
                *             order to fetch the next page of results. </p>
                *         <p> If <code>LastEvaluatedBackupArn</code> is empty, then the last page of results has
                *             been processed and there are no more results to be retrieved. </p>
                *         <p> If <code>LastEvaluatedBackupArn</code> is not empty, this may or may not indicate
                *             that there is more data to be returned. All results are guaranteed to have been returned
                *             if and only if no value for <code>LastEvaluatedBackupArn</code> is returned. </p>
                */
            LastEvaluatedBackupArn?: string;
    }
    export namespace ListBackupsOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListBackupsOutput) => any;
    }
    export interface ListContributorInsightsInput {
            /**
                * <p>The name of the table.</p>
                */
            TableName?: string;
            /**
                * <p>A token to for the desired page, if there is one.</p>
                */
            NextToken?: string;
            /**
                * <p>Maximum number of results to return per page.</p>
                */
            MaxResults?: number;
    }
    export namespace ListContributorInsightsInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListContributorInsightsInput) => any;
    }
    export interface ListContributorInsightsOutput {
            /**
                * <p>A list of ContributorInsightsSummary.</p>
                */
            ContributorInsightsSummaries?: ContributorInsightsSummary[];
            /**
                * <p>A token to go to the next page if there is one.</p>
                */
            NextToken?: string;
    }
    export namespace ListContributorInsightsOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListContributorInsightsOutput) => any;
    }
    export interface ListExportsInput {
            /**
                * <p>The Amazon Resource Name (ARN) associated with the exported table.</p>
                */
            TableArn?: string;
            /**
                * <p>Maximum number of results to return per page.</p>
                */
            MaxResults?: number;
            /**
                * <p>An optional string that, if supplied, must be copied from the output of a previous
                *             call to <code>ListExports</code>. When provided in this manner, the API fetches the next
                *             page of results.</p>
                */
            NextToken?: string;
    }
    export namespace ListExportsInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListExportsInput) => any;
    }
    /**
        * <p>Summary information about an export task.</p>
        */
    export interface ExportSummary {
            /**
                * <p>The Amazon Resource Name (ARN) of the export.</p>
                */
            ExportArn?: string;
            /**
                * <p>Export can be in one of the following states: IN_PROGRESS, COMPLETED, or
                *             FAILED.</p>
                */
            ExportStatus?: ExportStatus | string;
    }
    export namespace ExportSummary {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ExportSummary) => any;
    }
    export interface ListExportsOutput {
            /**
                * <p>A list of <code>ExportSummary</code> objects.</p>
                */
            ExportSummaries?: ExportSummary[];
            /**
                * <p>If this value is returned, there are additional results to be displayed. To retrieve
                *             them, call <code>ListExports</code> again, with <code>NextToken</code> set to this
                *             value.</p>
                */
            NextToken?: string;
    }
    export namespace ListExportsOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListExportsOutput) => any;
    }
    export interface ListGlobalTablesInput {
            /**
                * <p>The first global table name that this operation will evaluate.</p>
                */
            ExclusiveStartGlobalTableName?: string;
            /**
                * <p>The maximum number of table names to return, if the parameter is not specified
                *             DynamoDB defaults to 100.</p>
                *         <p>If the number of global tables DynamoDB finds reaches this limit, it stops the
                *             operation and returns the table names collected up to that point, with a table name in
                *             the <code>LastEvaluatedGlobalTableName</code> to apply in a subsequent operation to the
                *                 <code>ExclusiveStartGlobalTableName</code> parameter.</p>
                */
            Limit?: number;
            /**
                * <p>Lists the global tables in a specific Region.</p>
                */
            RegionName?: string;
    }
    export namespace ListGlobalTablesInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListGlobalTablesInput) => any;
    }
    /**
        * <p>Represents the properties of a global table.</p>
        */
    export interface GlobalTable {
            /**
                * <p>The global table name.</p>
                */
            GlobalTableName?: string;
            /**
                * <p>The Regions where the global table has replicas.</p>
                */
            ReplicationGroup?: Replica[];
    }
    export namespace GlobalTable {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GlobalTable) => any;
    }
    export interface ListGlobalTablesOutput {
            /**
                * <p>List of global table names.</p>
                */
            GlobalTables?: GlobalTable[];
            /**
                * <p>Last evaluated global table name.</p>
                */
            LastEvaluatedGlobalTableName?: string;
    }
    export namespace ListGlobalTablesOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListGlobalTablesOutput) => any;
    }
    /**
        * <p>Represents the input of a <code>ListTables</code> operation.</p>
        */
    export interface ListTablesInput {
            /**
                * <p>The first table name that this operation will evaluate. Use the value that was
                *             returned for <code>LastEvaluatedTableName</code> in a previous operation, so that you
                *             can obtain the next page of results.</p>
                */
            ExclusiveStartTableName?: string;
            /**
                * <p>A maximum number of table names to return. If this parameter is not specified, the
                *             limit is 100.</p>
                */
            Limit?: number;
    }
    export namespace ListTablesInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTablesInput) => any;
    }
    /**
        * <p>Represents the output of a <code>ListTables</code> operation.</p>
        */
    export interface ListTablesOutput {
            /**
                * <p>The names of the tables associated with the current account at the current endpoint.
                *             The maximum size of this array is 100.</p>
                *         <p>If <code>LastEvaluatedTableName</code> also appears in the output, you can use this
                *             value as the <code>ExclusiveStartTableName</code> parameter in a subsequent
                *                 <code>ListTables</code> request and obtain the next page of results.</p>
                */
            TableNames?: string[];
            /**
                * <p>The name of the last table in the current page of results. Use this value as the
                *                 <code>ExclusiveStartTableName</code> in a new request to obtain the next page of
                *             results, until all the table names are returned.</p>
                *         <p>If you do not receive a <code>LastEvaluatedTableName</code> value in the response,
                *             this means that there are no more table names to be retrieved.</p>
                */
            LastEvaluatedTableName?: string;
    }
    export namespace ListTablesOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTablesOutput) => any;
    }
    export interface ListTagsOfResourceInput {
            /**
                * <p>The Amazon DynamoDB resource with tags to be listed. This value is an Amazon Resource
                *             Name (ARN).</p>
                */
            ResourceArn: string | undefined;
            /**
                * <p>An optional string that, if supplied, must be copied from the output of a previous
                *             call to ListTagOfResource. When provided in this manner, this API fetches the next page
                *             of results.</p>
                */
            NextToken?: string;
    }
    export namespace ListTagsOfResourceInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTagsOfResourceInput) => any;
    }
    export interface ListTagsOfResourceOutput {
            /**
                * <p>The tags currently associated with the Amazon DynamoDB resource.</p>
                */
            Tags?: Tag[];
            /**
                * <p>If this value is returned, there are additional results to be displayed. To retrieve
                *             them, call ListTagsOfResource again, with NextToken set to this value.</p>
                */
            NextToken?: string;
    }
    export namespace ListTagsOfResourceOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ListTagsOfResourceOutput) => any;
    }
    export type Select = "ALL_ATTRIBUTES" | "ALL_PROJECTED_ATTRIBUTES" | "COUNT" | "SPECIFIC_ATTRIBUTES";
    export interface RestoreTableFromBackupInput {
            /**
                * <p>The name of the new table to which the backup must be restored.</p>
                */
            TargetTableName: string | undefined;
            /**
                * <p>The Amazon Resource Name (ARN) associated with the backup.</p>
                */
            BackupArn: string | undefined;
            /**
                * <p>The billing mode of the restored table.</p>
                */
            BillingModeOverride?: BillingMode | string;
            /**
                * <p>List of global secondary indexes for the restored table. The indexes provided should
                *             match existing secondary indexes. You can choose to exclude some or all of the indexes
                *             at the time of restore.</p>
                */
            GlobalSecondaryIndexOverride?: GlobalSecondaryIndex[];
            /**
                * <p>List of local secondary indexes for the restored table. The indexes provided should
                *             match existing secondary indexes. You can choose to exclude some or all of the indexes
                *             at the time of restore.</p>
                */
            LocalSecondaryIndexOverride?: LocalSecondaryIndex[];
            /**
                * <p>Provisioned throughput settings for the restored table.</p>
                */
            ProvisionedThroughputOverride?: ProvisionedThroughput;
            /**
                * <p>The new server-side encryption settings for the restored table.</p>
                */
            SSESpecificationOverride?: SSESpecification;
    }
    export namespace RestoreTableFromBackupInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RestoreTableFromBackupInput) => any;
    }
    export interface RestoreTableFromBackupOutput {
            /**
                * <p>The description of the table created from an existing backup.</p>
                */
            TableDescription?: TableDescription;
    }
    export namespace RestoreTableFromBackupOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RestoreTableFromBackupOutput) => any;
    }
    /**
        * <p>A target table with the specified name already exists. </p>
        */
    export class TableAlreadyExistsException extends __BaseException {
            readonly name: "TableAlreadyExistsException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TableAlreadyExistsException, __BaseException>);
    }
    /**
        * <p>An invalid restore time was specified. RestoreDateTime must be between
        *             EarliestRestorableDateTime and LatestRestorableDateTime.</p>
        */
    export class InvalidRestoreTimeException extends __BaseException {
            readonly name: "InvalidRestoreTimeException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidRestoreTimeException, __BaseException>);
    }
    export interface RestoreTableToPointInTimeInput {
            /**
                * <p>The DynamoDB table that will be restored. This value is an Amazon Resource Name
                *             (ARN).</p>
                */
            SourceTableArn?: string;
            /**
                * <p>Name of the source table that is being restored.</p>
                */
            SourceTableName?: string;
            /**
                * <p>The name of the new table to which it must be restored to.</p>
                */
            TargetTableName: string | undefined;
            /**
                * <p>Restore the table to the latest possible time. <code>LatestRestorableDateTime</code>
                *             is typically 5 minutes before the current time. </p>
                */
            UseLatestRestorableTime?: boolean;
            /**
                * <p>Time in the past to restore the table to.</p>
                */
            RestoreDateTime?: Date;
            /**
                * <p>The billing mode of the restored table.</p>
                */
            BillingModeOverride?: BillingMode | string;
            /**
                * <p>List of global secondary indexes for the restored table. The indexes provided should
                *             match existing secondary indexes. You can choose to exclude some or all of the indexes
                *             at the time of restore.</p>
                */
            GlobalSecondaryIndexOverride?: GlobalSecondaryIndex[];
            /**
                * <p>List of local secondary indexes for the restored table. The indexes provided should
                *             match existing secondary indexes. You can choose to exclude some or all of the indexes
                *             at the time of restore.</p>
                */
            LocalSecondaryIndexOverride?: LocalSecondaryIndex[];
            /**
                * <p>Provisioned throughput settings for the restored table.</p>
                */
            ProvisionedThroughputOverride?: ProvisionedThroughput;
            /**
                * <p>The new server-side encryption settings for the restored table.</p>
                */
            SSESpecificationOverride?: SSESpecification;
    }
    export namespace RestoreTableToPointInTimeInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RestoreTableToPointInTimeInput) => any;
    }
    export interface RestoreTableToPointInTimeOutput {
            /**
                * <p>Represents the properties of a table.</p>
                */
            TableDescription?: TableDescription;
    }
    export namespace RestoreTableToPointInTimeOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: RestoreTableToPointInTimeOutput) => any;
    }
    export interface TagResourceInput {
            /**
                * <p>Identifies the Amazon DynamoDB resource to which tags should be added. This value is
                *             an Amazon Resource Name (ARN).</p>
                */
            ResourceArn: string | undefined;
            /**
                * <p>The tags to be assigned to the Amazon DynamoDB resource.</p>
                */
            Tags: Tag[] | undefined;
    }
    export namespace TagResourceInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TagResourceInput) => any;
    }
    export interface UntagResourceInput {
            /**
                * <p>The DynamoDB resource that the tags will be removed from. This value is an Amazon
                *             Resource Name (ARN).</p>
                */
            ResourceArn: string | undefined;
            /**
                * <p>A list of tag keys. Existing tags of the resource whose keys are members of this list
                *             will be removed from the DynamoDB resource.</p>
                */
            TagKeys: string[] | undefined;
    }
    export namespace UntagResourceInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UntagResourceInput) => any;
    }
    /**
        * <p>Represents the settings used to enable point in time recovery.</p>
        */
    export interface PointInTimeRecoverySpecification {
            /**
                * <p>Indicates whether point in time recovery is enabled (true) or disabled (false) on the
                *             table.</p>
                */
            PointInTimeRecoveryEnabled: boolean | undefined;
    }
    export namespace PointInTimeRecoverySpecification {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PointInTimeRecoverySpecification) => any;
    }
    export interface UpdateContinuousBackupsInput {
            /**
                * <p>The name of the table.</p>
                */
            TableName: string | undefined;
            /**
                * <p>Represents the settings used to enable point in time recovery.</p>
                */
            PointInTimeRecoverySpecification: PointInTimeRecoverySpecification | undefined;
    }
    export namespace UpdateContinuousBackupsInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateContinuousBackupsInput) => any;
    }
    export interface UpdateContinuousBackupsOutput {
            /**
                * <p>Represents the continuous backups and point in time recovery settings on the
                *             table.</p>
                */
            ContinuousBackupsDescription?: ContinuousBackupsDescription;
    }
    export namespace UpdateContinuousBackupsOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateContinuousBackupsOutput) => any;
    }
    export interface UpdateContributorInsightsInput {
            /**
                * <p>The name of the table.</p>
                */
            TableName: string | undefined;
            /**
                * <p>The global secondary index name, if applicable.</p>
                */
            IndexName?: string;
            /**
                * <p>Represents the contributor insights action.</p>
                */
            ContributorInsightsAction: ContributorInsightsAction | string | undefined;
    }
    export namespace UpdateContributorInsightsInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateContributorInsightsInput) => any;
    }
    export interface UpdateContributorInsightsOutput {
            /**
                * <p>The name of the table.</p>
                */
            TableName?: string;
            /**
                * <p>The name of the global secondary index, if applicable.</p>
                */
            IndexName?: string;
            /**
                * <p>The status of contributor insights</p>
                */
            ContributorInsightsStatus?: ContributorInsightsStatus | string;
    }
    export namespace UpdateContributorInsightsOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateContributorInsightsOutput) => any;
    }
    /**
        * <p>The specified replica is already part of the global table.</p>
        */
    export class ReplicaAlreadyExistsException extends __BaseException {
            readonly name: "ReplicaAlreadyExistsException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ReplicaAlreadyExistsException, __BaseException>);
    }
    /**
        * <p>The specified replica is no longer part of the global table.</p>
        */
    export class ReplicaNotFoundException extends __BaseException {
            readonly name: "ReplicaNotFoundException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ReplicaNotFoundException, __BaseException>);
    }
    /**
        * <p>Represents one of the following:</p>
        *         <ul>
        *             <li>
        *                 <p>A new replica to be added to an existing global table.</p>
        *             </li>
        *             <li>
        *                 <p>New parameters for an existing replica.</p>
        *             </li>
        *             <li>
        *                 <p>An existing replica to be removed from an existing global table.</p>
        *             </li>
        *          </ul>
        */
    export interface ReplicaUpdate {
            /**
                * <p>The parameters required for creating a replica on an existing global table.</p>
                */
            Create?: CreateReplicaAction;
            /**
                * <p>The name of the existing replica to be removed.</p>
                */
            Delete?: DeleteReplicaAction;
    }
    export namespace ReplicaUpdate {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ReplicaUpdate) => any;
    }
    export interface UpdateGlobalTableInput {
            /**
                * <p>The global table name.</p>
                */
            GlobalTableName: string | undefined;
            /**
                * <p>A list of Regions that should be added or removed from the global table.</p>
                */
            ReplicaUpdates: ReplicaUpdate[] | undefined;
    }
    export namespace UpdateGlobalTableInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateGlobalTableInput) => any;
    }
    export interface UpdateGlobalTableOutput {
            /**
                * <p>Contains the details of the global table.</p>
                */
            GlobalTableDescription?: GlobalTableDescription;
    }
    export namespace UpdateGlobalTableOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateGlobalTableOutput) => any;
    }
    /**
        * <p>The operation tried to access a nonexistent index.</p>
        */
    export class IndexNotFoundException extends __BaseException {
            readonly name: "IndexNotFoundException";
            readonly $fault: "client";
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<IndexNotFoundException, __BaseException>);
    }
    /**
        * <p>Represents the settings of a global secondary index for a global table that will be
        *             modified.</p>
        */
    export interface GlobalTableGlobalSecondaryIndexSettingsUpdate {
            /**
                * <p>The name of the global secondary index. The name must be unique among all other
                *             indexes on this table.</p>
                */
            IndexName: string | undefined;
            /**
                * <p>The maximum number of writes consumed per second before DynamoDB returns a
                *                 <code>ThrottlingException.</code>
                *          </p>
                */
            ProvisionedWriteCapacityUnits?: number;
            /**
                * <p>Auto scaling settings for managing a global secondary index's write capacity
                *             units.</p>
                */
            ProvisionedWriteCapacityAutoScalingSettingsUpdate?: AutoScalingSettingsUpdate;
    }
    export namespace GlobalTableGlobalSecondaryIndexSettingsUpdate {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GlobalTableGlobalSecondaryIndexSettingsUpdate) => any;
    }
    /**
        * <p>Represents the settings of a global secondary index for a global table that will be
        *             modified.</p>
        */
    export interface ReplicaGlobalSecondaryIndexSettingsUpdate {
            /**
                * <p>The name of the global secondary index. The name must be unique among all other
                *             indexes on this table.</p>
                */
            IndexName: string | undefined;
            /**
                * <p>The maximum number of strongly consistent reads consumed per second before DynamoDB
                *             returns a <code>ThrottlingException</code>.</p>
                */
            ProvisionedReadCapacityUnits?: number;
            /**
                * <p>Auto scaling settings for managing a global secondary index replica's read capacity
                *             units.</p>
                */
            ProvisionedReadCapacityAutoScalingSettingsUpdate?: AutoScalingSettingsUpdate;
    }
    export namespace ReplicaGlobalSecondaryIndexSettingsUpdate {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ReplicaGlobalSecondaryIndexSettingsUpdate) => any;
    }
    /**
        * <p>Represents the settings for a global table in a Region that will be modified.</p>
        */
    export interface ReplicaSettingsUpdate {
            /**
                * <p>The Region of the replica to be added.</p>
                */
            RegionName: string | undefined;
            /**
                * <p>The maximum number of strongly consistent reads consumed per second before DynamoDB
                *             returns a <code>ThrottlingException</code>. For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html#ProvisionedThroughput">Specifying Read and Write Requirements</a> in the <i>Amazon DynamoDB
                *                 Developer Guide</i>. </p>
                */
            ReplicaProvisionedReadCapacityUnits?: number;
            /**
                * <p>Auto scaling settings for managing a global table replica's read capacity
                *             units.</p>
                */
            ReplicaProvisionedReadCapacityAutoScalingSettingsUpdate?: AutoScalingSettingsUpdate;
            /**
                * <p>Represents the settings of a global secondary index for a global table that will be
                *             modified.</p>
                */
            ReplicaGlobalSecondaryIndexSettingsUpdate?: ReplicaGlobalSecondaryIndexSettingsUpdate[];
            /**
                * <p>Replica-specific table class. If not specified, uses the source table's
                *             table class.</p>
                */
            ReplicaTableClass?: TableClass | string;
    }
    export namespace ReplicaSettingsUpdate {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ReplicaSettingsUpdate) => any;
    }
    export interface UpdateGlobalTableSettingsInput {
            /**
                * <p>The name of the global table</p>
                */
            GlobalTableName: string | undefined;
            /**
                * <p>The billing mode of the global table. If <code>GlobalTableBillingMode</code> is not
                *             specified, the global table defaults to <code>PROVISIONED</code> capacity billing
                *             mode.</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>PROVISIONED</code> - We recommend using <code>PROVISIONED</code> for
                *                     predictable workloads. <code>PROVISIONED</code> sets the billing mode to <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadWriteCapacityMode.html#HowItWorks.ProvisionedThroughput.Manual">Provisioned Mode</a>.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>PAY_PER_REQUEST</code> - We recommend using <code>PAY_PER_REQUEST</code>
                *                     for unpredictable workloads. <code>PAY_PER_REQUEST</code> sets the billing mode
                *                     to <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadWriteCapacityMode.html#HowItWorks.OnDemand">On-Demand Mode</a>. </p>
                *             </li>
                *          </ul>
                */
            GlobalTableBillingMode?: BillingMode | string;
            /**
                * <p>The maximum number of writes consumed per second before DynamoDB returns a
                *                 <code>ThrottlingException.</code>
                *          </p>
                */
            GlobalTableProvisionedWriteCapacityUnits?: number;
            /**
                * <p>Auto scaling settings for managing provisioned write capacity for the global
                *             table.</p>
                */
            GlobalTableProvisionedWriteCapacityAutoScalingSettingsUpdate?: AutoScalingSettingsUpdate;
            /**
                * <p>Represents the settings of a global secondary index for a global table that will be
                *             modified.</p>
                */
            GlobalTableGlobalSecondaryIndexSettingsUpdate?: GlobalTableGlobalSecondaryIndexSettingsUpdate[];
            /**
                * <p>Represents the settings for a global table in a Region that will be modified.</p>
                */
            ReplicaSettingsUpdate?: ReplicaSettingsUpdate[];
    }
    export namespace UpdateGlobalTableSettingsInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateGlobalTableSettingsInput) => any;
    }
    export interface UpdateGlobalTableSettingsOutput {
            /**
                * <p>The name of the global table.</p>
                */
            GlobalTableName?: string;
            /**
                * <p>The Region-specific settings for the global table.</p>
                */
            ReplicaSettings?: ReplicaSettingsDescription[];
    }
    export namespace UpdateGlobalTableSettingsOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateGlobalTableSettingsOutput) => any;
    }
    /**
        * <p>Represents the new provisioned throughput settings to be applied to a global secondary
        *             index.</p>
        */
    export interface UpdateGlobalSecondaryIndexAction {
            /**
                * <p>The name of the global secondary index to be updated.</p>
                */
            IndexName: string | undefined;
            /**
                * <p>Represents the provisioned throughput settings for the specified global secondary
                *             index.</p>
                *         <p>For current minimum and maximum provisioned throughput values, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html">Service,
                *                 Account, and Table Quotas</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>.</p>
                */
            ProvisionedThroughput: ProvisionedThroughput | undefined;
    }
    export namespace UpdateGlobalSecondaryIndexAction {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateGlobalSecondaryIndexAction) => any;
    }
    /**
        * <p>Represents one of the following:</p>
        *         <ul>
        *             <li>
        *                 <p>A new global secondary index to be added to an existing table.</p>
        *             </li>
        *             <li>
        *                 <p>New provisioned throughput parameters for an existing global secondary
        *                     index.</p>
        *             </li>
        *             <li>
        *                 <p>An existing global secondary index to be removed from an existing
        *                     table.</p>
        *             </li>
        *          </ul>
        */
    export interface GlobalSecondaryIndexUpdate {
            /**
                * <p>The name of an existing global secondary index, along with new provisioned throughput
                *             settings to be applied to that index.</p>
                */
            Update?: UpdateGlobalSecondaryIndexAction;
            /**
                * <p>The parameters required for creating a global secondary index on an existing
                *             table:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>IndexName </code>
                *                 </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>KeySchema </code>
                *                 </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>AttributeDefinitions </code>
                *                 </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>Projection </code>
                *                 </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>ProvisionedThroughput </code>
                *                 </p>
                *             </li>
                *          </ul>
                */
            Create?: CreateGlobalSecondaryIndexAction;
            /**
                * <p>The name of an existing global secondary index to be removed.</p>
                */
            Delete?: DeleteGlobalSecondaryIndexAction;
    }
    export namespace GlobalSecondaryIndexUpdate {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GlobalSecondaryIndexUpdate) => any;
    }
    /**
        * <p>Represents a replica to be modified.</p>
        */
    export interface UpdateReplicationGroupMemberAction {
            /**
                * <p>The Region where the replica exists.</p>
                */
            RegionName: string | undefined;
            /**
                * <p>The KMS key of the replica that should be used
                *             for KMS encryption. To specify a key, use its key ID, Amazon Resource
                *             Name (ARN), alias name, or alias ARN. Note that you should only provide this parameter
                *             if the key is different from the default DynamoDB KMS key
                *                 <code>alias/aws/dynamodb</code>.</p>
                */
            KMSMasterKeyId?: string;
            /**
                * <p>Replica-specific provisioned throughput. If not specified, uses the source table's
                *             provisioned throughput settings.</p>
                */
            ProvisionedThroughputOverride?: ProvisionedThroughputOverride;
            /**
                * <p>Replica-specific global secondary index settings.</p>
                */
            GlobalSecondaryIndexes?: ReplicaGlobalSecondaryIndex[];
            /**
                * <p>Replica-specific table class. If not specified, uses the source table's
                *             table class.</p>
                */
            TableClassOverride?: TableClass | string;
    }
    export namespace UpdateReplicationGroupMemberAction {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateReplicationGroupMemberAction) => any;
    }
    /**
        * <p>Represents one of the following:</p>
        *         <ul>
        *             <li>
        *                 <p>A new replica to be added to an existing regional table or global table. This
        *                     request invokes the <code>CreateTableReplica</code> action in the destination
        *                     Region.</p>
        *             </li>
        *             <li>
        *                 <p>New parameters for an existing replica. This request invokes the
        *                         <code>UpdateTable</code> action in the destination Region.</p>
        *             </li>
        *             <li>
        *                 <p>An existing replica to be deleted. The request invokes the
        *                         <code>DeleteTableReplica</code> action in the destination Region, deleting
        *                     the replica and all if its items in the destination Region.</p>
        *             </li>
        *          </ul>
        *         <note>
        *             <p>When you manually remove a table or global table replica, you do not
        *                 automatically remove any associated scalable targets, scaling policies, or
        *                 CloudWatch alarms.</p>
        *         </note>
        */
    export interface ReplicationGroupUpdate {
            /**
                * <p>The parameters required for creating a replica for the table.</p>
                */
            Create?: CreateReplicationGroupMemberAction;
            /**
                * <p>The parameters required for updating a replica for the table.</p>
                */
            Update?: UpdateReplicationGroupMemberAction;
            /**
                * <p>The parameters required for deleting a replica for the table.</p>
                */
            Delete?: DeleteReplicationGroupMemberAction;
    }
    export namespace ReplicationGroupUpdate {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ReplicationGroupUpdate) => any;
    }
    /**
        * <p>Represents the input of an <code>UpdateTable</code> operation.</p>
        */
    export interface UpdateTableInput {
            /**
                * <p>An array of attributes that describe the key schema for the table and indexes. If you
                *             are adding a new global secondary index to the table, <code>AttributeDefinitions</code>
                *             must include the key element(s) of the new index.</p>
                */
            AttributeDefinitions?: AttributeDefinition[];
            /**
                * <p>The name of the table to be updated.</p>
                */
            TableName: string | undefined;
            /**
                * <p>Controls how you are charged for read and write throughput and how you manage
                *             capacity. When switching from pay-per-request to provisioned capacity, initial
                *             provisioned capacity values must be set. The initial provisioned capacity values are
                *             estimated based on the consumed read and write capacity of your table and global
                *             secondary indexes over the past 30 minutes.</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>PROVISIONED</code> - We recommend using <code>PROVISIONED</code> for
                *                     predictable workloads. <code>PROVISIONED</code> sets the billing mode to <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadWriteCapacityMode.html#HowItWorks.ProvisionedThroughput.Manual">Provisioned Mode</a>.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>PAY_PER_REQUEST</code> - We recommend using <code>PAY_PER_REQUEST</code>
                *                     for unpredictable workloads. <code>PAY_PER_REQUEST</code> sets the billing mode
                *                     to <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadWriteCapacityMode.html#HowItWorks.OnDemand">On-Demand Mode</a>. </p>
                *             </li>
                *          </ul>
                */
            BillingMode?: BillingMode | string;
            /**
                * <p>The new provisioned throughput settings for the specified table or index.</p>
                */
            ProvisionedThroughput?: ProvisionedThroughput;
            /**
                * <p>An array of one or more global secondary indexes for the table. For each index in the
                *             array, you can request one action:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>Create</code> - add a new global secondary index to the table.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>Update</code> - modify the provisioned throughput settings of an existing
                *                     global secondary index.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>Delete</code> - remove a global secondary index from the table.</p>
                *             </li>
                *          </ul>
                *         <p>You can create or delete only one global secondary index per <code>UpdateTable</code>
                *             operation.</p>
                *         <p>For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GSI.OnlineOps.html">Managing Global
                *                 Secondary Indexes</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>. </p>
                */
            GlobalSecondaryIndexUpdates?: GlobalSecondaryIndexUpdate[];
            /**
                * <p>Represents the DynamoDB Streams configuration for the table.</p>
                *         <note>
                *             <p>You receive a <code>ResourceInUseException</code> if you try to enable a stream on
                *                 a table that already has a stream, or if you try to disable a stream on a table that
                *                 doesn't have a stream.</p>
                *         </note>
                */
            StreamSpecification?: StreamSpecification;
            /**
                * <p>The new server-side encryption settings for the specified table.</p>
                */
            SSESpecification?: SSESpecification;
            /**
                * <p>A list of replica update actions (create, delete, or update) for the table.</p>
                *         <note>
                *             <p>This property only applies to <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.V2.html">Version
                *                     2019.11.21</a> of global tables.</p>
                *         </note>
                */
            ReplicaUpdates?: ReplicationGroupUpdate[];
            /**
                * <p>The table class of the table to be updated. Valid values are <code>STANDARD</code> and
                *                 <code>STANDARD_INFREQUENT_ACCESS</code>.</p>
                */
            TableClass?: TableClass | string;
    }
    export namespace UpdateTableInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateTableInput) => any;
    }
    /**
        * <p>Represents the output of an <code>UpdateTable</code> operation.</p>
        */
    export interface UpdateTableOutput {
            /**
                * <p>Represents the properties of the table.</p>
                */
            TableDescription?: TableDescription;
    }
    export namespace UpdateTableOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateTableOutput) => any;
    }
    /**
        * <p>Represents the auto scaling settings of a global secondary index for a global table
        *             that will be modified.</p>
        */
    export interface GlobalSecondaryIndexAutoScalingUpdate {
            /**
                * <p>The name of the global secondary index.</p>
                */
            IndexName?: string;
            /**
                * <p>Represents the auto scaling settings to be modified for a global table or global
                *             secondary index.</p>
                */
            ProvisionedWriteCapacityAutoScalingUpdate?: AutoScalingSettingsUpdate;
    }
    export namespace GlobalSecondaryIndexAutoScalingUpdate {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GlobalSecondaryIndexAutoScalingUpdate) => any;
    }
    /**
        * <p>Represents the auto scaling settings of a global secondary index for a replica that
        *             will be modified.</p>
        */
    export interface ReplicaGlobalSecondaryIndexAutoScalingUpdate {
            /**
                * <p>The name of the global secondary index.</p>
                */
            IndexName?: string;
            /**
                * <p>Represents the auto scaling settings to be modified for a global table or global
                *             secondary index.</p>
                */
            ProvisionedReadCapacityAutoScalingUpdate?: AutoScalingSettingsUpdate;
    }
    export namespace ReplicaGlobalSecondaryIndexAutoScalingUpdate {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ReplicaGlobalSecondaryIndexAutoScalingUpdate) => any;
    }
    /**
        * <p>Represents the auto scaling settings of a replica that will be modified.</p>
        */
    export interface ReplicaAutoScalingUpdate {
            /**
                * <p>The Region where the replica exists.</p>
                */
            RegionName: string | undefined;
            /**
                * <p>Represents the auto scaling settings of global secondary indexes that will be
                *             modified.</p>
                */
            ReplicaGlobalSecondaryIndexUpdates?: ReplicaGlobalSecondaryIndexAutoScalingUpdate[];
            /**
                * <p>Represents the auto scaling settings to be modified for a global table or global
                *             secondary index.</p>
                */
            ReplicaProvisionedReadCapacityAutoScalingUpdate?: AutoScalingSettingsUpdate;
    }
    export namespace ReplicaAutoScalingUpdate {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ReplicaAutoScalingUpdate) => any;
    }
    export interface UpdateTableReplicaAutoScalingInput {
            /**
                * <p>Represents the auto scaling settings of the global secondary indexes of the replica to
                *             be updated.</p>
                */
            GlobalSecondaryIndexUpdates?: GlobalSecondaryIndexAutoScalingUpdate[];
            /**
                * <p>The name of the global table to be updated.</p>
                */
            TableName: string | undefined;
            /**
                * <p>Represents the auto scaling settings to be modified for a global table or global
                *             secondary index.</p>
                */
            ProvisionedWriteCapacityAutoScalingUpdate?: AutoScalingSettingsUpdate;
            /**
                * <p>Represents the auto scaling settings of replicas of the table that will be
                *             modified.</p>
                */
            ReplicaUpdates?: ReplicaAutoScalingUpdate[];
    }
    export namespace UpdateTableReplicaAutoScalingInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateTableReplicaAutoScalingInput) => any;
    }
    export interface UpdateTableReplicaAutoScalingOutput {
            /**
                * <p>Returns information about the auto scaling settings of a table with replicas.</p>
                */
            TableAutoScalingDescription?: TableAutoScalingDescription;
    }
    export namespace UpdateTableReplicaAutoScalingOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateTableReplicaAutoScalingOutput) => any;
    }
    /**
        * <p>Represents the settings used to enable or disable Time to Live (TTL) for the specified
        *             table.</p>
        */
    export interface TimeToLiveSpecification {
            /**
                * <p>Indicates whether TTL is to be enabled (true) or disabled (false) on the table.</p>
                */
            Enabled: boolean | undefined;
            /**
                * <p>The name of the TTL attribute used to store the expiration time for items in the
                *             table.</p>
                */
            AttributeName: string | undefined;
    }
    export namespace TimeToLiveSpecification {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TimeToLiveSpecification) => any;
    }
    /**
        * <p>Represents the input of an <code>UpdateTimeToLive</code> operation.</p>
        */
    export interface UpdateTimeToLiveInput {
            /**
                * <p>The name of the table to be configured.</p>
                */
            TableName: string | undefined;
            /**
                * <p>Represents the settings used to enable or disable Time to Live for the specified
                *             table.</p>
                */
            TimeToLiveSpecification: TimeToLiveSpecification | undefined;
    }
    export namespace UpdateTimeToLiveInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateTimeToLiveInput) => any;
    }
    export interface UpdateTimeToLiveOutput {
            /**
                * <p>Represents the output of an <code>UpdateTimeToLive</code> operation.</p>
                */
            TimeToLiveSpecification?: TimeToLiveSpecification;
    }
    export namespace UpdateTimeToLiveOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateTimeToLiveOutput) => any;
    }
    /**
        * <p>Represents the data for an attribute.</p>
        *         <p>Each attribute value is described as a name-value pair. The name is the data type, and
        *             the value is the data itself.</p>
        *         <p>For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.NamingRulesDataTypes.html#HowItWorks.DataTypes">Data Types</a> in the <i>Amazon DynamoDB Developer
        *             Guide</i>.</p>
        */
    export type AttributeValue = AttributeValue.BMember | AttributeValue.BOOLMember | AttributeValue.BSMember | AttributeValue.LMember | AttributeValue.MMember | AttributeValue.NMember | AttributeValue.NSMember | AttributeValue.NULLMember | AttributeValue.SMember | AttributeValue.SSMember | AttributeValue.$UnknownMember;
    export namespace AttributeValue {
            /**
                * <p>An attribute of type String. For example:</p>
                *         <p>
                *             <code>"S": "Hello"</code>
                *          </p>
                */
            interface SMember {
                    S: string;
                    N?: never;
                    B?: never;
                    SS?: never;
                    NS?: never;
                    BS?: never;
                    M?: never;
                    L?: never;
                    NULL?: never;
                    BOOL?: never;
                    $unknown?: never;
            }
            /**
                * <p>An attribute of type Number. For example:</p>
                *         <p>
                *             <code>"N": "123.45"</code>
                *          </p>
                *         <p>Numbers are sent across the network to DynamoDB as strings, to maximize compatibility
                *             across languages and libraries. However, DynamoDB treats them as number type attributes
                *             for mathematical operations.</p>
                */
            interface NMember {
                    S?: never;
                    N: string;
                    B?: never;
                    SS?: never;
                    NS?: never;
                    BS?: never;
                    M?: never;
                    L?: never;
                    NULL?: never;
                    BOOL?: never;
                    $unknown?: never;
            }
            /**
                * <p>An attribute of type Binary. For example:</p>
                *         <p>
                *             <code>"B": "dGhpcyB0ZXh0IGlzIGJhc2U2NC1lbmNvZGVk"</code>
                *          </p>
                */
            interface BMember {
                    S?: never;
                    N?: never;
                    B: Uint8Array;
                    SS?: never;
                    NS?: never;
                    BS?: never;
                    M?: never;
                    L?: never;
                    NULL?: never;
                    BOOL?: never;
                    $unknown?: never;
            }
            /**
                * <p>An attribute of type String Set. For example:</p>
                *         <p>
                *             <code>"SS": ["Giraffe", "Hippo" ,"Zebra"]</code>
                *          </p>
                */
            interface SSMember {
                    S?: never;
                    N?: never;
                    B?: never;
                    SS: string[];
                    NS?: never;
                    BS?: never;
                    M?: never;
                    L?: never;
                    NULL?: never;
                    BOOL?: never;
                    $unknown?: never;
            }
            /**
                * <p>An attribute of type Number Set. For example:</p>
                *         <p>
                *             <code>"NS": ["42.2", "-19", "7.5", "3.14"]</code>
                *          </p>
                *         <p>Numbers are sent across the network to DynamoDB as strings, to maximize compatibility
                *             across languages and libraries. However, DynamoDB treats them as number type attributes
                *             for mathematical operations.</p>
                */
            interface NSMember {
                    S?: never;
                    N?: never;
                    B?: never;
                    SS?: never;
                    NS: string[];
                    BS?: never;
                    M?: never;
                    L?: never;
                    NULL?: never;
                    BOOL?: never;
                    $unknown?: never;
            }
            /**
                * <p>An attribute of type Binary Set. For example:</p>
                *         <p>
                *             <code>"BS": ["U3Vubnk=", "UmFpbnk=", "U25vd3k="]</code>
                *          </p>
                */
            interface BSMember {
                    S?: never;
                    N?: never;
                    B?: never;
                    SS?: never;
                    NS?: never;
                    BS: Uint8Array[];
                    M?: never;
                    L?: never;
                    NULL?: never;
                    BOOL?: never;
                    $unknown?: never;
            }
            /**
                * <p>An attribute of type Map. For example:</p>
                *         <p>
                *             <code>"M": {"Name": {"S": "Joe"}, "Age": {"N": "35"}}</code>
                *          </p>
                */
            interface MMember {
                    S?: never;
                    N?: never;
                    B?: never;
                    SS?: never;
                    NS?: never;
                    BS?: never;
                    M: Record<string, AttributeValue>;
                    L?: never;
                    NULL?: never;
                    BOOL?: never;
                    $unknown?: never;
            }
            /**
                * <p>An attribute of type List. For example:</p>
                *         <p>
                *             <code>"L": [ {"S": "Cookies"} , {"S": "Coffee"}, {"N": "3.14159"}]</code>
                *          </p>
                */
            interface LMember {
                    S?: never;
                    N?: never;
                    B?: never;
                    SS?: never;
                    NS?: never;
                    BS?: never;
                    M?: never;
                    L: AttributeValue[];
                    NULL?: never;
                    BOOL?: never;
                    $unknown?: never;
            }
            /**
                * <p>An attribute of type Null. For example:</p>
                *         <p>
                *             <code>"NULL": true</code>
                *          </p>
                */
            interface NULLMember {
                    S?: never;
                    N?: never;
                    B?: never;
                    SS?: never;
                    NS?: never;
                    BS?: never;
                    M?: never;
                    L?: never;
                    NULL: boolean;
                    BOOL?: never;
                    $unknown?: never;
            }
            /**
                * <p>An attribute of type Boolean. For example:</p>
                *         <p>
                *             <code>"BOOL": true</code>
                *          </p>
                */
            interface BOOLMember {
                    S?: never;
                    N?: never;
                    B?: never;
                    SS?: never;
                    NS?: never;
                    BS?: never;
                    M?: never;
                    L?: never;
                    NULL?: never;
                    BOOL: boolean;
                    $unknown?: never;
            }
            interface $UnknownMember {
                    S?: never;
                    N?: never;
                    B?: never;
                    SS?: never;
                    NS?: never;
                    BS?: never;
                    M?: never;
                    L?: never;
                    NULL?: never;
                    BOOL?: never;
                    $unknown: [string, any];
            }
            interface Visitor<T> {
                    S: (value: string) => T;
                    N: (value: string) => T;
                    B: (value: Uint8Array) => T;
                    SS: (value: string[]) => T;
                    NS: (value: string[]) => T;
                    BS: (value: Uint8Array[]) => T;
                    M: (value: Record<string, AttributeValue>) => T;
                    L: (value: AttributeValue[]) => T;
                    NULL: (value: boolean) => T;
                    BOOL: (value: boolean) => T;
                    _: (name: string, value: any) => T;
            }
            const visit: <T>(value: AttributeValue, visitor: Visitor<T>) => T;
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AttributeValue) => any;
    }
    /**
        * <p>For the <code>UpdateItem</code> operation, represents the attributes to be modified,
        *             the action to perform on each, and the new value for each.</p>
        *         <note>
        *             <p>You cannot use <code>UpdateItem</code> to update any primary key attributes.
        *                 Instead, you will need to delete the item, and then use <code>PutItem</code> to
        *                 create a new item with new attributes.</p>
        *         </note>
        *         <p>Attribute values cannot be null; string and binary type attributes must have lengths
        *             greater than zero; and set type attributes must not be empty. Requests with empty values
        *             will be rejected with a <code>ValidationException</code> exception.</p>
        */
    export interface AttributeValueUpdate {
            /**
                * <p>Represents the data for an attribute.</p>
                *         <p>Each attribute value is described as a name-value pair. The name is the data type, and
                *             the value is the data itself.</p>
                *         <p>For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.NamingRulesDataTypes.html#HowItWorks.DataTypes">Data Types</a> in the <i>Amazon DynamoDB Developer Guide</i>.
                *         </p>
                */
            Value?: AttributeValue;
            /**
                * <p>Specifies how to perform the update. Valid values are <code>PUT</code> (default),
                *                 <code>DELETE</code>, and <code>ADD</code>. The behavior depends on whether the
                *             specified primary key already exists in the table.</p>
                *
                *         <p>
                *             <b>If an item with the specified <i>Key</i> is found in
                *                 the table:</b>
                *         </p>
                *
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>PUT</code> - Adds the specified attribute to the item. If the attribute
                *                     already exists, it is replaced by the new value. </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>DELETE</code> - If no value is specified, the attribute and its value are
                *                     removed from the item. The data type of the specified value must match the
                *                     existing value's data type.</p>
                *                 <p>If a <i>set</i> of values is specified, then those values are
                *                     subtracted from the old set. For example, if the attribute value was the set
                *                         <code>[a,b,c]</code> and the <code>DELETE</code> action specified
                *                         <code>[a,c]</code>, then the final attribute value would be
                *                     <code>[b]</code>. Specifying an empty set is an error.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>ADD</code> - If the attribute does not already exist, then the attribute
                *                     and its values are added to the item. If the attribute does exist, then the
                *                     behavior of <code>ADD</code> depends on the data type of the attribute:</p>
                *                 <ul>
                *                   <li>
                *                         <p>If the existing attribute is a number, and if <code>Value</code> is
                *                             also a number, then the <code>Value</code> is mathematically added to
                *                             the existing attribute. If <code>Value</code> is a negative number, then
                *                             it is subtracted from the existing attribute.</p>
                *                         <note>
                *                             <p> If you use <code>ADD</code> to increment or decrement a number
                *                                 value for an item that doesn't exist before the update, DynamoDB
                *                                 uses 0 as the initial value.</p>
                *                             <p>In addition, if you use <code>ADD</code> to update an existing
                *                                 item, and intend to increment or decrement an attribute value which
                *                                 does not yet exist, DynamoDB uses <code>0</code> as the initial
                *                                 value. For example, suppose that the item you want to update does
                *                                 not yet have an attribute named <i>itemcount</i>, but
                *                                 you decide to <code>ADD</code> the number <code>3</code> to this
                *                                 attribute anyway, even though it currently does not exist. DynamoDB
                *                                 will create the <i>itemcount</i> attribute, set its
                *                                 initial value to <code>0</code>, and finally add <code>3</code> to
                *                                 it. The result will be a new <i>itemcount</i>
                *                                 attribute in the item, with a value of <code>3</code>.</p>
                *                         </note>
                *                     </li>
                *                   <li>
                *                         <p>If the existing data type is a set, and if the <code>Value</code> is
                *                             also a set, then the <code>Value</code> is added to the existing set.
                *                             (This is a <i>set</i> operation, not mathematical
                *                             addition.) For example, if the attribute value was the set
                *                                 <code>[1,2]</code>, and the <code>ADD</code> action specified
                *                                 <code>[3]</code>, then the final attribute value would be
                *                                 <code>[1,2,3]</code>. An error occurs if an Add action is specified
                *                             for a set attribute and the attribute type specified does not match the
                *                             existing set type. </p>
                *                         <p>Both sets must have the same primitive data type. For example, if the
                *                             existing data type is a set of strings, the <code>Value</code> must also
                *                             be a set of strings. The same holds true for number sets and binary
                *                             sets.</p>
                *                     </li>
                *                </ul>
                *                 <p>This action is only valid for an existing attribute whose data type is number
                *                     or is a set. Do not use <code>ADD</code> for any other data types.</p>
                *             </li>
                *          </ul>
                *
                *         <p>
                *             <b>If no item with the specified <i>Key</i> is
                *                 found:</b>
                *         </p>
                *
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>PUT</code> - DynamoDB creates a new item with the specified primary key,
                *                     and then adds the attribute. </p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>DELETE</code> - Nothing happens; there is no attribute to delete.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>ADD</code> - DynamoDB creates a new item with the supplied primary key and
                *                     number (or set) for the attribute value. The only data types allowed
                *                     are number, number set, string set or binary set.</p>
                *             </li>
                *          </ul>
                */
            Action?: AttributeAction | string;
    }
    export namespace AttributeValueUpdate {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AttributeValueUpdate) => any;
    }
    /**
        * <p> A PartiQL batch statement request. </p>
        */
    export interface BatchStatementRequest {
            /**
                * <p> A valid PartiQL statement. </p>
                */
            Statement: string | undefined;
            /**
                * <p> The parameters associated with a PartiQL statement in the batch request. </p>
                */
            Parameters?: AttributeValue[];
            /**
                * <p> The read consistency of the PartiQL batch request. </p>
                */
            ConsistentRead?: boolean;
    }
    export namespace BatchStatementRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchStatementRequest) => any;
    }
    /**
        * <p> A PartiQL batch statement response.. </p>
        */
    export interface BatchStatementResponse {
            /**
                * <p> The error associated with a failed PartiQL batch statement. </p>
                */
            Error?: BatchStatementError;
            /**
                * <p> The table name associated with a failed PartiQL batch statement. </p>
                */
            TableName?: string;
            /**
                * <p> A DynamoDB item associated with a BatchStatementResponse </p>
                */
            Item?: Record<string, AttributeValue>;
    }
    export namespace BatchStatementResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchStatementResponse) => any;
    }
    /**
        * <p>An ordered list of errors for each item in the request which caused the transaction to
        *             get cancelled. The values of the list are ordered according to the ordering of the
        *                 <code>TransactWriteItems</code> request parameter. If no error occurred for the
        *             associated item an error with a Null code and Null message will be present. </p>
        */
    export interface CancellationReason {
            /**
                * <p>Item in the request which caused the transaction to get cancelled.</p>
                */
            Item?: Record<string, AttributeValue>;
            /**
                * <p>Status code for the result of the cancelled transaction.</p>
                */
            Code?: string;
            /**
                * <p>Cancellation reason message description.</p>
                */
            Message?: string;
    }
    export namespace CancellationReason {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: CancellationReason) => any;
    }
    /**
        * <p>Represents the selection criteria for a <code>Query</code> or <code>Scan</code>
        *             operation:</p>
        *         <ul>
        *             <li>
        *                 <p>For a <code>Query</code> operation, <code>Condition</code> is used for
        *                     specifying the <code>KeyConditions</code> to use when querying a table or an
        *                     index. For <code>KeyConditions</code>, only the following comparison operators
        *                     are supported:</p>
        *                 <p>
        *                     <code>EQ | LE | LT | GE | GT | BEGINS_WITH | BETWEEN</code>
        *                 </p>
        *                 <p>
        *                     <code>Condition</code> is also used in a <code>QueryFilter</code>, which
        *                     evaluates the query results and returns only the desired values.</p>
        *             </li>
        *             <li>
        *                 <p>For a <code>Scan</code> operation, <code>Condition</code> is used in a
        *                         <code>ScanFilter</code>, which evaluates the scan results and returns only
        *                     the desired values.</p>
        *             </li>
        *          </ul>
        */
    export interface Condition {
            /**
                * <p>One or more values to evaluate against the supplied attribute. The number of values in
                *             the list depends on the <code>ComparisonOperator</code> being used.</p>
                *         <p>For type Number, value comparisons are numeric.</p>
                *         <p>String value comparisons for greater than, equals, or less than are based on ASCII
                *             character code values. For example, <code>a</code> is greater than <code>A</code>, and
                *                 <code>a</code> is greater than <code>B</code>. For a list of code values, see <a href="http://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters">http://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters</a>.</p>
                *         <p>For Binary, DynamoDB treats each byte of the binary data as unsigned when it
                *             compares binary values.</p>
                */
            AttributeValueList?: AttributeValue[];
            /**
                * <p>A comparator for evaluating attributes. For example, equals, greater than, less than,
                *             etc.</p>
                *         <p>The following comparison operators are available:</p>
                *         <p>
                *             <code>EQ | NE | LE | LT | GE | GT | NOT_NULL | NULL | CONTAINS | NOT_CONTAINS |
                *                 BEGINS_WITH | IN | BETWEEN</code>
                *         </p>
                *         <p>The following are descriptions of each comparison operator.</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>EQ</code> : Equal. <code>EQ</code> is supported for all data types,
                *                     including lists and maps.</p>
                *                 <p>
                *                     <code>AttributeValueList</code> can contain only one <code>AttributeValue</code>
                *                     element of type String, Number, Binary, String Set, Number Set, or Binary Set.
                *                     If an item contains an <code>AttributeValue</code> element of a different type
                *                     than the one provided in the request, the value does not match. For example,
                *                         <code>{"S":"6"}</code> does not equal <code>{"N":"6"}</code>. Also,
                *                         <code>{"N":"6"}</code> does not equal <code>{"NS":["6", "2",
                *                     "1"]}</code>.</p>
                *                 <p></p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>NE</code> : Not equal. <code>NE</code> is supported for all data types,
                *                     including lists and maps.</p>
                *                 <p>
                *                     <code>AttributeValueList</code> can contain only one <code>AttributeValue</code>
                *                     of type String, Number, Binary, String Set, Number Set, or Binary Set. If an
                *                     item contains an <code>AttributeValue</code> of a different type than the one
                *                     provided in the request, the value does not match. For example,
                *                         <code>{"S":"6"}</code> does not equal <code>{"N":"6"}</code>. Also,
                *                         <code>{"N":"6"}</code> does not equal <code>{"NS":["6", "2",
                *                     "1"]}</code>.</p>
                *                 <p></p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>LE</code> : Less than or equal. </p>
                *                 <p>
                *                     <code>AttributeValueList</code> can contain only one <code>AttributeValue</code>
                *                     element of type String, Number, or Binary (not a set type). If an item contains
                *                     an <code>AttributeValue</code> element of a different type than the one provided
                *                     in the request, the value does not match. For example, <code>{"S":"6"}</code>
                *                     does not equal <code>{"N":"6"}</code>. Also, <code>{"N":"6"}</code> does not
                *                     compare to <code>{"NS":["6", "2", "1"]}</code>.</p>
                *                 <p></p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>LT</code> : Less than. </p>
                *                 <p>
                *                     <code>AttributeValueList</code> can contain only one <code>AttributeValue</code>
                *                     of type String, Number, or Binary (not a set type). If an item contains an
                *                         <code>AttributeValue</code> element of a different type than the one
                *                     provided in the request, the value does not match. For example,
                *                         <code>{"S":"6"}</code> does not equal <code>{"N":"6"}</code>. Also,
                *                         <code>{"N":"6"}</code> does not compare to <code>{"NS":["6", "2",
                *                         "1"]}</code>.</p>
                *                 <p></p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>GE</code> : Greater than or equal. </p>
                *                 <p>
                *                     <code>AttributeValueList</code> can contain only one <code>AttributeValue</code>
                *                     element of type String, Number, or Binary (not a set type). If an item contains
                *                     an <code>AttributeValue</code> element of a different type than the one provided
                *                     in the request, the value does not match. For example, <code>{"S":"6"}</code>
                *                     does not equal <code>{"N":"6"}</code>. Also, <code>{"N":"6"}</code> does not
                *                     compare to <code>{"NS":["6", "2", "1"]}</code>.</p>
                *                 <p></p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>GT</code> : Greater than. </p>
                *                 <p>
                *                     <code>AttributeValueList</code> can contain only one <code>AttributeValue</code>
                *                     element of type String, Number, or Binary (not a set type). If an item contains
                *                     an <code>AttributeValue</code> element of a different type than the one provided
                *                     in the request, the value does not match. For example, <code>{"S":"6"}</code>
                *                     does not equal <code>{"N":"6"}</code>. Also, <code>{"N":"6"}</code> does not
                *                     compare to <code>{"NS":["6", "2", "1"]}</code>.</p>
                *                 <p></p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>NOT_NULL</code> : The attribute exists. <code>NOT_NULL</code> is supported
                *                     for all data types, including lists and maps.</p>
                *                 <note>
                *                     <p>This operator tests for the existence of an attribute, not its data type.
                *                         If the data type of attribute "<code>a</code>" is null, and you evaluate it
                *                         using <code>NOT_NULL</code>, the result is a Boolean <code>true</code>. This
                *                         result is because the attribute "<code>a</code>" exists; its data type is
                *                         not relevant to the <code>NOT_NULL</code> comparison operator.</p>
                *                 </note>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>NULL</code> : The attribute does not exist. <code>NULL</code> is supported
                *                     for all data types, including lists and maps.</p>
                *                 <note>
                *                     <p>This operator tests for the nonexistence of an attribute, not its data
                *                         type. If the data type of attribute "<code>a</code>" is null, and you
                *                         evaluate it using <code>NULL</code>, the result is a Boolean
                *                             <code>false</code>. This is because the attribute "<code>a</code>"
                *                         exists; its data type is not relevant to the <code>NULL</code> comparison
                *                         operator.</p>
                *                 </note>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>CONTAINS</code> : Checks for a subsequence, or value in a set.</p>
                *                 <p>
                *                     <code>AttributeValueList</code> can contain only one <code>AttributeValue</code>
                *                     element of type String, Number, or Binary (not a set type). If the target
                *                     attribute of the comparison is of type String, then the operator checks for a
                *                     substring match. If the target attribute of the comparison is of type Binary,
                *                     then the operator looks for a subsequence of the target that matches the input.
                *                     If the target attribute of the comparison is a set ("<code>SS</code>",
                *                         "<code>NS</code>", or "<code>BS</code>"), then the operator evaluates to
                *                     true if it finds an exact match with any member of the set.</p>
                *                 <p>CONTAINS is supported for lists: When evaluating "<code>a CONTAINS b</code>",
                *                         "<code>a</code>" can be a list; however, "<code>b</code>" cannot be a set, a
                *                     map, or a list.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>NOT_CONTAINS</code> : Checks for absence of a subsequence, or absence of a
                *                     value in a set.</p>
                *                 <p>
                *                     <code>AttributeValueList</code> can contain only one <code>AttributeValue</code>
                *                     element of type String, Number, or Binary (not a set type). If the target
                *                     attribute of the comparison is a String, then the operator checks for the
                *                     absence of a substring match. If the target attribute of the comparison is
                *                     Binary, then the operator checks for the absence of a subsequence of the target
                *                     that matches the input. If the target attribute of the comparison is a set
                *                         ("<code>SS</code>", "<code>NS</code>", or "<code>BS</code>"), then the
                *                     operator evaluates to true if it <i>does not</i> find an exact
                *                     match with any member of the set.</p>
                *                 <p>NOT_CONTAINS is supported for lists: When evaluating "<code>a NOT CONTAINS
                *                         b</code>", "<code>a</code>" can be a list; however, "<code>b</code>" cannot
                *                     be a set, a map, or a list.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>BEGINS_WITH</code> : Checks for a prefix. </p>
                *                 <p>
                *                     <code>AttributeValueList</code> can contain only one <code>AttributeValue</code>
                *                     of type String or Binary (not a Number or a set type). The target attribute of
                *                     the comparison must be of type String or Binary (not a Number or a set
                *                     type).</p>
                *                 <p></p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>IN</code> : Checks for matching elements in a list.</p>
                *                 <p>
                *                     <code>AttributeValueList</code> can contain one or more
                *                         <code>AttributeValue</code> elements of type String, Number, or Binary.
                *                     These attributes are compared against an existing attribute of an item. If any
                *                     elements of the input are equal to the item attribute, the expression evaluates
                *                     to true.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>BETWEEN</code> : Greater than or equal to the first value, and less than
                *                     or equal to the second value. </p>
                *                 <p>
                *                     <code>AttributeValueList</code> must contain two <code>AttributeValue</code>
                *                     elements of the same type, either String, Number, or Binary (not a set type). A
                *                     target attribute matches if the target value is greater than, or equal to, the
                *                     first element and less than, or equal to, the second element. If an item
                *                     contains an <code>AttributeValue</code> element of a different type than the one
                *                     provided in the request, the value does not match. For example,
                *                         <code>{"S":"6"}</code> does not compare to <code>{"N":"6"}</code>. Also,
                *                         <code>{"N":"6"}</code> does not compare to <code>{"NS":["6", "2",
                *                         "1"]}</code>
                *                 </p>
                *             </li>
                *          </ul>
                *         <p>For usage examples of <code>AttributeValueList</code> and
                *                 <code>ComparisonOperator</code>, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.html">Legacy
                *                 Conditional Parameters</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>.</p>
                */
            ComparisonOperator: ComparisonOperator | string | undefined;
    }
    export namespace Condition {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Condition) => any;
    }
    /**
        * <p>Represents a request to perform a <code>DeleteItem</code> operation on an item.</p>
        */
    export interface DeleteRequest {
            /**
                * <p>A map of attribute name to attribute values, representing the primary key of the item
                *             to delete. All of the table's primary key attributes must be specified, and their data
                *             types must match those of the table's key schema.</p>
                */
            Key: Record<string, AttributeValue> | undefined;
    }
    export namespace DeleteRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteRequest) => any;
    }
    export interface ExecuteStatementInput {
            /**
                * <p>The PartiQL statement representing the operation to run.</p>
                */
            Statement: string | undefined;
            /**
                * <p>The parameters for the PartiQL statement, if any.</p>
                */
            Parameters?: AttributeValue[];
            /**
                * <p>The consistency of a read operation. If set to <code>true</code>, then a strongly
                *             consistent read is used; otherwise, an eventually consistent read is used.</p>
                */
            ConsistentRead?: boolean;
            /**
                * <p>Set this value to get remaining results, if <code>NextToken</code> was returned in the
                *             statement response.</p>
                */
            NextToken?: string;
            /**
                * <p>Determines the level of detail about either provisioned or on-demand throughput
                *             consumption that is returned in the response:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>INDEXES</code> - The response includes the aggregate
                *                         <code>ConsumedCapacity</code> for the operation, together with
                *                         <code>ConsumedCapacity</code> for each table and secondary index that was
                *                     accessed.</p>
                *                 <p>Note that some operations, such as <code>GetItem</code> and
                *                         <code>BatchGetItem</code>, do not access any indexes at all. In these cases,
                *                     specifying <code>INDEXES</code> will only return <code>ConsumedCapacity</code>
                *                     information for table(s).</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>TOTAL</code> - The response includes only the aggregate
                *                         <code>ConsumedCapacity</code> for the operation.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>NONE</code> - No <code>ConsumedCapacity</code> details are included in the
                *                     response.</p>
                *             </li>
                *          </ul>
                */
            ReturnConsumedCapacity?: ReturnConsumedCapacity | string;
            /**
                * <p>The maximum number of items to evaluate (not necessarily the number of matching
                *             items). If DynamoDB processes the number of items up to the limit while processing the
                *             results, it stops the operation and returns the matching values up to that point, along
                *             with a key in <code>LastEvaluatedKey</code> to apply in a subsequent operation so you
                *             can pick up where you left off. Also, if the processed dataset size exceeds 1 MB before
                *             DynamoDB reaches this limit, it stops the operation and returns the matching values up
                *             to the limit, and a key in <code>LastEvaluatedKey</code> to apply in a subsequent
                *             operation to continue the operation. </p>
                */
            Limit?: number;
    }
    export namespace ExecuteStatementInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ExecuteStatementInput) => any;
    }
    /**
        * <p>Specifies an item and related attribute values to retrieve in a
        *                 <code>TransactGetItem</code> object.</p>
        */
    export interface Get {
            /**
                * <p>A map of attribute names to <code>AttributeValue</code> objects that specifies the
                *             primary key of the item to retrieve.</p>
                */
            Key: Record<string, AttributeValue> | undefined;
            /**
                * <p>The name of the table from which to retrieve the specified item.</p>
                */
            TableName: string | undefined;
            /**
                * <p>A string that identifies one or more attributes of the specified item to retrieve from
                *             the table. The attributes in the expression must be separated by commas. If no attribute
                *             names are specified, then all attributes of the specified item are returned. If any of
                *             the requested attributes are not found, they do not appear in the result.</p>
                */
            ProjectionExpression?: string;
            /**
                * <p>One or more substitution tokens for attribute names in the ProjectionExpression
                *             parameter.</p>
                */
            ExpressionAttributeNames?: Record<string, string>;
    }
    export namespace Get {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Get) => any;
    }
    /**
        * <p>Represents the input of a <code>GetItem</code> operation.</p>
        */
    export interface GetItemInput {
            /**
                * <p>The name of the table containing the requested item.</p>
                */
            TableName: string | undefined;
            /**
                * <p>A map of attribute names to <code>AttributeValue</code> objects, representing the
                *             primary key of the item to retrieve.</p>
                *         <p>For the primary key, you must provide all of the attributes. For example, with a
                *             simple primary key, you only need to provide a value for the partition key. For a
                *             composite primary key, you must provide values for both the partition key and the sort
                *             key.</p>
                */
            Key: Record<string, AttributeValue> | undefined;
            /**
                * <p>This is a legacy parameter. Use <code>ProjectionExpression</code> instead. For more
                *             information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.AttributesToGet.html">AttributesToGet</a> in the <i>Amazon DynamoDB Developer
                *             Guide</i>.</p>
                */
            AttributesToGet?: string[];
            /**
                * <p>Determines the read consistency model: If set to <code>true</code>, then the operation
                *             uses strongly consistent reads; otherwise, the operation uses eventually consistent
                *             reads.</p>
                */
            ConsistentRead?: boolean;
            /**
                * <p>Determines the level of detail about either provisioned or on-demand throughput
                *             consumption that is returned in the response:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>INDEXES</code> - The response includes the aggregate
                *                         <code>ConsumedCapacity</code> for the operation, together with
                *                         <code>ConsumedCapacity</code> for each table and secondary index that was
                *                     accessed.</p>
                *                 <p>Note that some operations, such as <code>GetItem</code> and
                *                         <code>BatchGetItem</code>, do not access any indexes at all. In these cases,
                *                     specifying <code>INDEXES</code> will only return <code>ConsumedCapacity</code>
                *                     information for table(s).</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>TOTAL</code> - The response includes only the aggregate
                *                         <code>ConsumedCapacity</code> for the operation.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>NONE</code> - No <code>ConsumedCapacity</code> details are included in the
                *                     response.</p>
                *             </li>
                *          </ul>
                */
            ReturnConsumedCapacity?: ReturnConsumedCapacity | string;
            /**
                * <p>A string that identifies one or more attributes to retrieve from the table. These
                *             attributes can include scalars, sets, or elements of a JSON document. The attributes in
                *             the expression must be separated by commas.</p>
                *         <p>If no attribute names are specified, then all attributes are returned. If any of the
                *             requested attributes are not found, they do not appear in the result.</p>
                *         <p>For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html">Specifying Item Attributes</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>.</p>
                */
            ProjectionExpression?: string;
            /**
                * <p>One or more substitution tokens for attribute names in an expression. The following
                *             are some use cases for using <code>ExpressionAttributeNames</code>:</p>
                *         <ul>
                *             <li>
                *                 <p>To access an attribute whose name conflicts with a DynamoDB reserved
                *                     word.</p>
                *             </li>
                *             <li>
                *                 <p>To create a placeholder for repeating occurrences of an attribute name in an
                *                     expression.</p>
                *             </li>
                *             <li>
                *                 <p>To prevent special characters in an attribute name from being misinterpreted
                *                     in an expression.</p>
                *             </li>
                *          </ul>
                *         <p>Use the <b>#</b> character in an expression to dereference
                *             an attribute name. For example, consider the following attribute name:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>Percentile</code>
                *                 </p>
                *             </li>
                *          </ul>
                *         <p>The name of this attribute conflicts with a reserved word, so it cannot be used
                *             directly in an expression. (For the complete list of reserved words, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html">Reserved Words</a> in the <i>Amazon DynamoDB Developer
                *             Guide</i>). To work around this, you could specify the following for
                *                 <code>ExpressionAttributeNames</code>:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>{"#P":"Percentile"}</code>
                *                 </p>
                *             </li>
                *          </ul>
                *         <p>You could then use this substitution in an expression, as in this example:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>#P = :val</code>
                *                 </p>
                *             </li>
                *          </ul>
                *         <note>
                *             <p>Tokens that begin with the <b>:</b> character are
                *                     <i>expression attribute values</i>, which are placeholders for the
                *                 actual value at runtime.</p>
                *         </note>
                *         <p>For more information on expression attribute names, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html">Specifying Item Attributes</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>.</p>
                */
            ExpressionAttributeNames?: Record<string, string>;
    }
    export namespace GetItemInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetItemInput) => any;
    }
    /**
        * <p>Represents the output of a <code>GetItem</code> operation.</p>
        */
    export interface GetItemOutput {
            /**
                * <p>A map of attribute names to <code>AttributeValue</code> objects, as specified by
                *                 <code>ProjectionExpression</code>.</p>
                */
            Item?: Record<string, AttributeValue>;
            /**
                * <p>The capacity units consumed by the <code>GetItem</code> operation. The data returned
                *             includes the total provisioned throughput consumed, along with statistics for the table
                *             and any indexes involved in the operation. <code>ConsumedCapacity</code> is only
                *             returned if the <code>ReturnConsumedCapacity</code> parameter was specified. For more
                *             information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughputIntro.html">Read/Write Capacity Mode</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>.</p>
                */
            ConsumedCapacity?: ConsumedCapacity;
    }
    export namespace GetItemOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetItemOutput) => any;
    }
    /**
        * <p>Information about item collections, if any, that were affected by the operation.
        *                 <code>ItemCollectionMetrics</code> is only returned if the request asked for it. If
        *             the table does not have any local secondary indexes, this information is not returned in
        *             the response.</p>
        */
    export interface ItemCollectionMetrics {
            /**
                * <p>The partition key value of the item collection. This value is the same as the
                *             partition key value of the item.</p>
                */
            ItemCollectionKey?: Record<string, AttributeValue>;
            /**
                * <p>An estimate of item collection size, in gigabytes. This value is a two-element array
                *             containing a lower bound and an upper bound for the estimate. The estimate includes the
                *             size of all the items in the table, plus the size of all attributes projected into all
                *             of the local secondary indexes on that table. Use this estimate to measure whether a
                *             local secondary index is approaching its size limit.</p>
                *         <p>The estimate is subject to change over time; therefore, do not rely on the precision
                *             or accuracy of the estimate.</p>
                */
            SizeEstimateRangeGB?: number[];
    }
    export namespace ItemCollectionMetrics {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ItemCollectionMetrics) => any;
    }
    /**
        * <p>Details for the requested item.</p>
        */
    export interface ItemResponse {
            /**
                * <p>Map of attribute data consisting of the data type and attribute value.</p>
                */
            Item?: Record<string, AttributeValue>;
    }
    export namespace ItemResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ItemResponse) => any;
    }
    /**
        * <p> Represents a PartiQL statment that uses parameters. </p>
        */
    export interface ParameterizedStatement {
            /**
                * <p> A PartiQL statment that uses parameters. </p>
                */
            Statement: string | undefined;
            /**
                * <p> The parameter values. </p>
                */
            Parameters?: AttributeValue[];
    }
    export namespace ParameterizedStatement {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ParameterizedStatement) => any;
    }
    /**
        * <p>Represents a request to perform a <code>PutItem</code> operation on an item.</p>
        */
    export interface PutRequest {
            /**
                * <p>A map of attribute name to attribute values, representing the primary key of an item
                *             to be processed by <code>PutItem</code>. All of the table's primary key attributes must
                *             be specified, and their data types must match those of the table's key schema. If any
                *             attributes are present in the item that are part of an index key schema for the table,
                *             their types must match the index key schema.</p>
                */
            Item: Record<string, AttributeValue> | undefined;
    }
    export namespace PutRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutRequest) => any;
    }
    /**
        * <p>Represents a set of primary keys and, for each key, the attributes to retrieve from
        *             the table.</p>
        *         <p>For each primary key, you must provide <i>all</i> of the key attributes.
        *             For example, with a simple primary key, you only need to provide the partition key. For
        *             a composite primary key, you must provide <i>both</i> the partition key
        *             and the sort key.</p>
        */
    export interface KeysAndAttributes {
            /**
                * <p>The primary key attribute values that define the items and the attributes associated
                *             with the items.</p>
                */
            Keys: Record<string, AttributeValue>[] | undefined;
            /**
                * <p>This is a legacy parameter. Use <code>ProjectionExpression</code> instead. For more
                *             information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.html">Legacy
                *                 Conditional Parameters</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>.</p>
                */
            AttributesToGet?: string[];
            /**
                * <p>The consistency of a read operation. If set to <code>true</code>, then a strongly
                *             consistent read is used; otherwise, an eventually consistent read is used.</p>
                */
            ConsistentRead?: boolean;
            /**
                * <p>A string that identifies one or more attributes to retrieve from the table. These
                *             attributes can include scalars, sets, or elements of a JSON document. The attributes in
                *             the <code>ProjectionExpression</code> must be separated by commas.</p>
                *         <p>If no attribute names are specified, then all attributes will be returned. If any of
                *             the requested attributes are not found, they will not appear in the result.</p>
                *         <p>For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html">Accessing Item Attributes</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>.</p>
                */
            ProjectionExpression?: string;
            /**
                * <p>One or more substitution tokens for attribute names in an expression. The following
                *             are some use cases for using <code>ExpressionAttributeNames</code>:</p>
                *         <ul>
                *             <li>
                *                 <p>To access an attribute whose name conflicts with a DynamoDB reserved
                *                     word.</p>
                *             </li>
                *             <li>
                *                 <p>To create a placeholder for repeating occurrences of an attribute name in an
                *                     expression.</p>
                *             </li>
                *             <li>
                *                 <p>To prevent special characters in an attribute name from being misinterpreted
                *                     in an expression.</p>
                *             </li>
                *          </ul>
                *         <p>Use the <b>#</b> character in an expression to dereference
                *             an attribute name. For example, consider the following attribute name:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>Percentile</code>
                *                 </p>
                *             </li>
                *          </ul>
                *         <p>The name of this attribute conflicts with a reserved word, so it cannot be used
                *             directly in an expression. (For the complete list of reserved words, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html">Reserved Words</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>). To work around this, you could specify the following for
                *                 <code>ExpressionAttributeNames</code>:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>{"#P":"Percentile"}</code>
                *                 </p>
                *             </li>
                *          </ul>
                *         <p>You could then use this substitution in an expression, as in this example:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>#P = :val</code>
                *                 </p>
                *             </li>
                *          </ul>
                *         <note>
                *             <p>Tokens that begin with the <b>:</b> character are
                *                     <i>expression attribute values</i>, which are placeholders for the
                *                 actual value at runtime.</p>
                *         </note>
                *         <p>For more information on expression attribute names, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html">Accessing Item Attributes</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>.</p>
                */
            ExpressionAttributeNames?: Record<string, string>;
    }
    export namespace KeysAndAttributes {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: KeysAndAttributes) => any;
    }
    /**
        * <p>Specifies an item to be retrieved as part of the transaction.</p>
        */
    export interface TransactGetItem {
            /**
                * <p>Contains the primary key that identifies the item to get, together with the name of
                *             the table that contains the item, and optionally the specific attributes of the item to
                *             retrieve.</p>
                */
            Get: Get | undefined;
    }
    export namespace TransactGetItem {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TransactGetItem) => any;
    }
    export interface BatchExecuteStatementInput {
            /**
                * <p>The list of PartiQL statements representing the batch to run.</p>
                */
            Statements: BatchStatementRequest[] | undefined;
            /**
                * <p>Determines the level of detail about either provisioned or on-demand throughput
                *             consumption that is returned in the response:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>INDEXES</code> - The response includes the aggregate
                *                         <code>ConsumedCapacity</code> for the operation, together with
                *                         <code>ConsumedCapacity</code> for each table and secondary index that was
                *                     accessed.</p>
                *                 <p>Note that some operations, such as <code>GetItem</code> and
                *                         <code>BatchGetItem</code>, do not access any indexes at all. In these cases,
                *                     specifying <code>INDEXES</code> will only return <code>ConsumedCapacity</code>
                *                     information for table(s).</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>TOTAL</code> - The response includes only the aggregate
                *                         <code>ConsumedCapacity</code> for the operation.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>NONE</code> - No <code>ConsumedCapacity</code> details are included in the
                *                     response.</p>
                *             </li>
                *          </ul>
                */
            ReturnConsumedCapacity?: ReturnConsumedCapacity | string;
    }
    export namespace BatchExecuteStatementInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchExecuteStatementInput) => any;
    }
    export interface BatchExecuteStatementOutput {
            /**
                * <p>The response to each PartiQL statement in the batch.</p>
                */
            Responses?: BatchStatementResponse[];
            /**
                * <p>The capacity units consumed by the entire operation. The values of the list are
                *             ordered according to the ordering of the statements.</p>
                */
            ConsumedCapacity?: ConsumedCapacity[];
    }
    export namespace BatchExecuteStatementOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchExecuteStatementOutput) => any;
    }
    export interface ExecuteTransactionInput {
            /**
                * <p>The list of PartiQL statements representing the transaction to run.</p>
                */
            TransactStatements: ParameterizedStatement[] | undefined;
            /**
                * <p>Set this value to get remaining results, if <code>NextToken</code> was returned in the
                *             statement response.</p>
                */
            ClientRequestToken?: string;
            /**
                * <p>Determines the level of detail about either provisioned or on-demand throughput
                *             consumption that is returned in the response. For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_TransactGetItems.html">TransactGetItems</a> and <a href="https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_TransactWriteItems.html">TransactWriteItems</a>.</p>
                */
            ReturnConsumedCapacity?: ReturnConsumedCapacity | string;
    }
    export namespace ExecuteTransactionInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ExecuteTransactionInput) => any;
    }
    export interface ExecuteTransactionOutput {
            /**
                * <p>The response to a PartiQL transaction.</p>
                */
            Responses?: ItemResponse[];
            /**
                * <p>The capacity units consumed by the entire operation. The values of the list are
                *             ordered according to the ordering of the statements.</p>
                */
            ConsumedCapacity?: ConsumedCapacity[];
    }
    export namespace ExecuteTransactionOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ExecuteTransactionOutput) => any;
    }
    export interface TransactGetItemsOutput {
            /**
                * <p>If the <i>ReturnConsumedCapacity</i> value was <code>TOTAL</code>, this
                *             is an array of <code>ConsumedCapacity</code> objects, one for each table addressed by
                *                 <code>TransactGetItem</code> objects in the <i>TransactItems</i>
                *             parameter. These <code>ConsumedCapacity</code> objects report the read-capacity units
                *             consumed by the <code>TransactGetItems</code> call in that table.</p>
                */
            ConsumedCapacity?: ConsumedCapacity[];
            /**
                * <p>An ordered array of up to 25 <code>ItemResponse</code> objects, each of which
                *             corresponds to the <code>TransactGetItem</code> object in the same position in the
                *                 <i>TransactItems</i> array. Each <code>ItemResponse</code> object
                *             contains a Map of the name-value pairs that are the projected attributes of the
                *             requested item.</p>
                *         <p>If a requested item could not be retrieved, the corresponding
                *                 <code>ItemResponse</code> object is Null, or if the requested item has no projected
                *             attributes, the corresponding <code>ItemResponse</code> object is an empty Map. </p>
                */
            Responses?: ItemResponse[];
    }
    export namespace TransactGetItemsOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TransactGetItemsOutput) => any;
    }
    /**
        * <p>The entire transaction request was canceled.</p>
        *         <p>DynamoDB cancels a <code>TransactWriteItems</code> request under the following
        *             circumstances:</p>
        *         <ul>
        *             <li>
        *                 <p>A condition in one of the condition expressions is not met.</p>
        *             </li>
        *             <li>
        *                 <p>A table in the <code>TransactWriteItems</code> request is in a different
        *                     account or region.</p>
        *             </li>
        *             <li>
        *                 <p>More than one action in the <code>TransactWriteItems</code> operation
        *                     targets the same item.</p>
        *             </li>
        *             <li>
        *                 <p>There is insufficient provisioned capacity for the transaction to be
        *                     completed.</p>
        *             </li>
        *             <li>
        *                 <p>An item size becomes too large (larger than 400 KB), or a local secondary
        *                     index (LSI) becomes too large, or a similar validation error occurs because of
        *                     changes made by the transaction.</p>
        *             </li>
        *             <li>
        *                 <p>There is a user error, such as an invalid data format.</p>
        *             </li>
        *          </ul>
        *
        *         <p>DynamoDB cancels a <code>TransactGetItems</code> request under the
        *             following circumstances:</p>
        *         <ul>
        *             <li>
        *                 <p>There is an ongoing <code>TransactGetItems</code> operation that conflicts
        *                     with a concurrent <code>PutItem</code>, <code>UpdateItem</code>,
        *                         <code>DeleteItem</code> or <code>TransactWriteItems</code> request. In this
        *                     case the <code>TransactGetItems</code> operation fails with a
        *                         <code>TransactionCanceledException</code>.</p>
        *             </li>
        *             <li>
        *                 <p>A table in the <code>TransactGetItems</code> request is in a different
        *                     account or region.</p>
        *             </li>
        *             <li>
        *                 <p>There is insufficient provisioned capacity for the transaction to be
        *                     completed.</p>
        *             </li>
        *             <li>
        *                 <p>There is a user error, such as an invalid data format.</p>
        *             </li>
        *          </ul>
        *
        *         <note>
        *             <p>If using Java, DynamoDB lists the cancellation reasons on the
        *                     <code>CancellationReasons</code> property. This property is not set for other
        *                 languages. Transaction cancellation reasons are ordered in the order of requested
        *                 items, if an item has no error it will have <code>None</code> code and
        *                     <code>Null</code> message.</p>
        *         </note>
        *         <p>Cancellation reason codes and possible error messages:</p>
        *         <ul>
        *             <li>
        *                 <p>No Errors:</p>
        *                 <ul>
        *                   <li>
        *                         <p>Code: <code>None</code>
        *                         </p>
        *                     </li>
        *                   <li>
        *                         <p>Message: <code>null</code>
        *                         </p>
        *                     </li>
        *                </ul>
        *             </li>
        *             <li>
        *                 <p>Conditional Check Failed:</p>
        *                 <ul>
        *                   <li>
        *                         <p>Code: <code>ConditionalCheckFailed</code>
        *                         </p>
        *                     </li>
        *                   <li>
        *                         <p>Message: The conditional request failed. </p>
        *                     </li>
        *                </ul>
        *             </li>
        *             <li>
        *                 <p>Item Collection Size Limit Exceeded:</p>
        *                 <ul>
        *                   <li>
        *                         <p>Code: <code>ItemCollectionSizeLimitExceeded</code>
        *                         </p>
        *                     </li>
        *                   <li>
        *                         <p>Message: Collection size exceeded.</p>
        *                     </li>
        *                </ul>
        *             </li>
        *             <li>
        *                 <p>Transaction Conflict:</p>
        *                 <ul>
        *                   <li>
        *                         <p>Code: <code>TransactionConflict</code>
        *                         </p>
        *                     </li>
        *                   <li>
        *                         <p>Message: Transaction is ongoing for the item.</p>
        *                     </li>
        *                </ul>
        *             </li>
        *             <li>
        *                 <p>Provisioned Throughput Exceeded:</p>
        *                 <ul>
        *                   <li>
        *                         <p>Code: <code>ProvisionedThroughputExceeded</code>
        *                         </p>
        *                     </li>
        *                   <li>
        *                         <p>Messages:</p>
        *                         <ul>
        *                         <li>
        *                                 <p>The level of configured provisioned throughput for the
        *                                     table was exceeded. Consider increasing your provisioning level
        *                                     with the UpdateTable API.</p>
        *                                 <note>
        *                                     <p>This Message is received when provisioned throughput is
        *                                         exceeded is on a provisioned DynamoDB
        *                                         table.</p>
        *                                 </note>
        *                             </li>
        *                         <li>
        *                                 <p>The level of configured provisioned throughput for one or
        *                                     more global secondary indexes of the table was exceeded.
        *                                     Consider increasing your provisioning level for the
        *                                     under-provisioned global secondary indexes with the UpdateTable
        *                                     API.</p>
        *                                 <note>
        *                                     <p>This message is returned when provisioned throughput is
        *                                         exceeded is on a provisioned GSI.</p>
        *                                 </note>
        *                             </li>
        *                      </ul>
        *
        *                     </li>
        *                </ul>
        *             </li>
        *             <li>
        *                 <p>Throttling Error:</p>
        *                 <ul>
        *                   <li>
        *                         <p>Code: <code>ThrottlingError</code>
        *                         </p>
        *                     </li>
        *                   <li>
        *                         <p>Messages: </p>
        *                         <ul>
        *                         <li>
        *                                 <p>Throughput exceeds the current capacity of your table or
        *                                     index. DynamoDB is automatically scaling your table or
        *                                     index so please try again shortly. If exceptions persist, check
        *                                     if you have a hot key:
        *                                     https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-partition-key-design.html.</p>
        *                                 <note>
        *                                     <p>This message is returned when writes get throttled on an
        *                                         On-Demand table as DynamoDB is automatically
        *                                         scaling the table.</p>
        *                                 </note>
        *                             </li>
        *                         <li>
        *                                 <p>Throughput exceeds the current capacity for one or more
        *                                     global secondary indexes. DynamoDB is automatically
        *                                     scaling your index so please try again shortly.</p>
        *                                 <note>
        *                                     <p>This message is returned when when writes get throttled on
        *                                         an On-Demand GSI as DynamoDB is automatically
        *                                         scaling the GSI.</p>
        *                                 </note>
        *                             </li>
        *                      </ul>
        *
        *                     </li>
        *                </ul>
        *             </li>
        *             <li>
        *                 <p>Validation Error:</p>
        *                 <ul>
        *                   <li>
        *                         <p>Code: <code>ValidationError</code>
        *                         </p>
        *                     </li>
        *                   <li>
        *                         <p>Messages: </p>
        *                         <ul>
        *                         <li>
        *                                 <p>One or more parameter values were invalid.</p>
        *                             </li>
        *                         <li>
        *                                 <p>The update expression attempted to update the secondary
        *                                     index key beyond allowed size limits.</p>
        *                             </li>
        *                         <li>
        *                                 <p>The update expression attempted to update the secondary
        *                                     index key to unsupported type.</p>
        *                             </li>
        *                         <li>
        *                                 <p>An operand in the update expression has an incorrect data
        *                                     type.</p>
        *                             </li>
        *                         <li>
        *                                 <p>Item size to update has exceeded the maximum allowed
        *                                     size.</p>
        *                             </li>
        *                         <li>
        *                                 <p>Number overflow. Attempting to store a number with
        *                                     magnitude larger than supported range.</p>
        *                             </li>
        *                         <li>
        *                                 <p>Type mismatch for attribute to update.</p>
        *                             </li>
        *                         <li>
        *                                 <p>Nesting Levels have exceeded supported limits.</p>
        *                             </li>
        *                         <li>
        *                                 <p>The document path provided in the update expression is
        *                                     invalid for update.</p>
        *                             </li>
        *                         <li>
        *                                 <p>The provided expression refers to an attribute that does
        *                                     not exist in the item.</p>
        *                             </li>
        *                      </ul>
        *
        *                     </li>
        *                </ul>
        *             </li>
        *          </ul>
        */
    export class TransactionCanceledException extends __BaseException {
            readonly name: "TransactionCanceledException";
            readonly $fault: "client";
            Message?: string;
            /**
                * <p>A list of cancellation reasons.</p>
                */
            CancellationReasons?: CancellationReason[];
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<TransactionCanceledException, __BaseException>);
    }
    /**
        * <p>Represents the input of a <code>BatchGetItem</code> operation.</p>
        */
    export interface BatchGetItemInput {
            /**
                * <p>A map of one or more table names and, for each table, a map that describes one or more
                *             items to retrieve from that table. Each table name can be used only once per
                *                 <code>BatchGetItem</code> request.</p>
                *         <p>Each element in the map of items to retrieve consists of the following:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>ConsistentRead</code> - If <code>true</code>, a strongly consistent read
                *                     is used; if <code>false</code> (the default), an eventually consistent read is
                *                     used.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>ExpressionAttributeNames</code> - One or more substitution tokens for
                *                     attribute names in the <code>ProjectionExpression</code> parameter. The
                *                     following are some use cases for using
                *                     <code>ExpressionAttributeNames</code>:</p>
                *                 <ul>
                *                   <li>
                *                         <p>To access an attribute whose name conflicts with a DynamoDB reserved
                *                             word.</p>
                *                     </li>
                *                   <li>
                *                         <p>To create a placeholder for repeating occurrences of an attribute name
                *                             in an expression.</p>
                *                     </li>
                *                   <li>
                *                         <p>To prevent special characters in an attribute name from being
                *                             misinterpreted in an expression.</p>
                *                     </li>
                *                </ul>
                *                 <p>Use the <b>#</b> character in an expression to
                *                     dereference an attribute name. For example, consider the following attribute
                *                     name:</p>
                *                 <ul>
                *                   <li>
                *                         <p>
                *                             <code>Percentile</code>
                *                         </p>
                *                     </li>
                *                </ul>
                *                 <p>The name of this attribute conflicts with a reserved word, so it cannot be
                *                     used directly in an expression. (For the complete list of reserved words, see
                *                         <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html">Reserved
                *                         Words</a> in the <i>Amazon DynamoDB Developer Guide</i>).
                *                     To work around this, you could specify the following for
                *                         <code>ExpressionAttributeNames</code>:</p>
                *                 <ul>
                *                   <li>
                *                         <p>
                *                             <code>{"#P":"Percentile"}</code>
                *                         </p>
                *                     </li>
                *                </ul>
                *                 <p>You could then use this substitution in an expression, as in this
                *                     example:</p>
                *                 <ul>
                *                   <li>
                *                         <p>
                *                             <code>#P = :val</code>
                *                         </p>
                *                     </li>
                *                </ul>
                *                 <note>
                *                     <p>Tokens that begin with the <b>:</b> character
                *                         are <i>expression attribute values</i>, which are placeholders
                *                         for the actual value at runtime.</p>
                *                 </note>
                *                 <p>For more information about expression attribute names, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html">Accessing Item Attributes</a> in the <i>Amazon DynamoDB
                *                         Developer Guide</i>.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>Keys</code> - An array of primary key attribute values that define
                *                     specific items in the table. For each primary key, you must provide
                *                         <i>all</i> of the key attributes. For example, with a simple
                *                     primary key, you only need to provide the partition key value. For a composite
                *                     key, you must provide <i>both</i> the partition key value and the
                *                     sort key value.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>ProjectionExpression</code> - A string that identifies one or more
                *                     attributes to retrieve from the table. These attributes can include scalars,
                *                     sets, or elements of a JSON document. The attributes in the expression must be
                *                     separated by commas.</p>
                *                 <p>If no attribute names are specified, then all attributes are returned. If any
                *                     of the requested attributes are not found, they do not appear in the
                *                     result.</p>
                *                 <p>For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html">Accessing Item Attributes</a> in the <i>Amazon DynamoDB
                *                         Developer Guide</i>.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>AttributesToGet</code> - This is a legacy parameter. Use
                *                         <code>ProjectionExpression</code> instead. For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.AttributesToGet.html">AttributesToGet</a> in the <i>Amazon DynamoDB Developer
                *                         Guide</i>. </p>
                *
                *             </li>
                *          </ul>
                */
            RequestItems: Record<string, KeysAndAttributes> | undefined;
            /**
                * <p>Determines the level of detail about either provisioned or on-demand throughput
                *             consumption that is returned in the response:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>INDEXES</code> - The response includes the aggregate
                *                         <code>ConsumedCapacity</code> for the operation, together with
                *                         <code>ConsumedCapacity</code> for each table and secondary index that was
                *                     accessed.</p>
                *                 <p>Note that some operations, such as <code>GetItem</code> and
                *                         <code>BatchGetItem</code>, do not access any indexes at all. In these cases,
                *                     specifying <code>INDEXES</code> will only return <code>ConsumedCapacity</code>
                *                     information for table(s).</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>TOTAL</code> - The response includes only the aggregate
                *                         <code>ConsumedCapacity</code> for the operation.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>NONE</code> - No <code>ConsumedCapacity</code> details are included in the
                *                     response.</p>
                *             </li>
                *          </ul>
                */
            ReturnConsumedCapacity?: ReturnConsumedCapacity | string;
    }
    export namespace BatchGetItemInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchGetItemInput) => any;
    }
    /**
        * <p>Represents a condition to be compared with an attribute value. This condition can be
        *             used with <code>DeleteItem</code>, <code>PutItem</code>, or <code>UpdateItem</code>
        *             operations; if the comparison evaluates to true, the operation succeeds; if not, the
        *             operation fails. You can use <code>ExpectedAttributeValue</code> in one of two different
        *             ways:</p>
        *         <ul>
        *             <li>
        *                 <p>Use <code>AttributeValueList</code> to specify one or more values to compare
        *                     against an attribute. Use <code>ComparisonOperator</code> to specify how you
        *                     want to perform the comparison. If the comparison evaluates to true, then the
        *                     conditional operation succeeds.</p>
        *             </li>
        *             <li>
        *                 <p>Use <code>Value</code> to specify a value that DynamoDB will compare against
        *                     an attribute. If the values match, then <code>ExpectedAttributeValue</code>
        *                     evaluates to true and the conditional operation succeeds. Optionally, you can
        *                     also set <code>Exists</code> to false, indicating that you <i>do
        *                         not</i> expect to find the attribute value in the table. In this
        *                     case, the conditional operation succeeds only if the comparison evaluates to
        *                     false.</p>
        *             </li>
        *          </ul>
        *         <p>
        *             <code>Value</code> and <code>Exists</code> are incompatible with
        *                 <code>AttributeValueList</code> and <code>ComparisonOperator</code>. Note that if
        *             you use both sets of parameters at once, DynamoDB will return a
        *                 <code>ValidationException</code> exception.</p>
        */
    export interface ExpectedAttributeValue {
            /**
                * <p>Represents the data for the expected attribute.</p>
                *         <p>Each attribute value is described as a name-value pair. The name is the data type, and
                *             the value is the data itself.</p>
                *         <p>For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.NamingRulesDataTypes.html#HowItWorks.DataTypes">Data Types</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>.</p>
                */
            Value?: AttributeValue;
            /**
                * <p>Causes DynamoDB to evaluate the value before attempting a conditional
                *             operation:</p>
                *         <ul>
                *             <li>
                *                 <p>If <code>Exists</code> is <code>true</code>, DynamoDB will check to
                *                     see if that attribute value already exists in the table. If it is found, then
                *                     the operation succeeds. If it is not found, the operation fails with a
                *                         <code>ConditionCheckFailedException</code>.</p>
                *             </li>
                *             <li>
                *                 <p>If <code>Exists</code> is <code>false</code>, DynamoDB assumes that
                *                     the attribute value does not exist in the table. If in fact the value does not
                *                     exist, then the assumption is valid and the operation succeeds. If the value is
                *                     found, despite the assumption that it does not exist, the operation fails with a
                *                         <code>ConditionCheckFailedException</code>.</p>
                *             </li>
                *          </ul>
                *         <p>The default setting for <code>Exists</code> is <code>true</code>. If you supply a
                *                 <code>Value</code> all by itself, DynamoDB assumes the attribute exists:
                *             You don't have to set <code>Exists</code> to <code>true</code>, because it is
                *             implied.</p>
                *         <p>DynamoDB returns a <code>ValidationException</code> if:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>Exists</code> is <code>true</code> but there is no <code>Value</code> to
                *                     check. (You expect a value to exist, but don't specify what that value
                *                     is.)</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>Exists</code> is <code>false</code> but you also provide a
                *                         <code>Value</code>. (You cannot expect an attribute to have a value, while
                *                     also expecting it not to exist.)</p>
                *             </li>
                *          </ul>
                */
            Exists?: boolean;
            /**
                * <p>A comparator for evaluating attributes in the <code>AttributeValueList</code>. For
                *             example, equals, greater than, less than, etc.</p>
                *         <p>The following comparison operators are available:</p>
                *         <p>
                *             <code>EQ | NE | LE | LT | GE | GT | NOT_NULL | NULL | CONTAINS | NOT_CONTAINS |
                *                 BEGINS_WITH | IN | BETWEEN</code>
                *         </p>
                *         <p>The following are descriptions of each comparison operator.</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>EQ</code> : Equal. <code>EQ</code> is supported for all data types,
                *                     including lists and maps.</p>
                *                 <p>
                *                     <code>AttributeValueList</code> can contain only one <code>AttributeValue</code>
                *                     element of type String, Number, Binary, String Set, Number Set, or Binary Set.
                *                     If an item contains an <code>AttributeValue</code> element of a different type
                *                     than the one provided in the request, the value does not match. For example,
                *                         <code>{"S":"6"}</code> does not equal <code>{"N":"6"}</code>. Also,
                *                         <code>{"N":"6"}</code> does not equal <code>{"NS":["6", "2",
                *                     "1"]}</code>.</p>
                *                 <p></p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>NE</code> : Not equal. <code>NE</code> is supported for all data types,
                *                     including lists and maps.</p>
                *                 <p>
                *                     <code>AttributeValueList</code> can contain only one <code>AttributeValue</code>
                *                     of type String, Number, Binary, String Set, Number Set, or Binary Set. If an
                *                     item contains an <code>AttributeValue</code> of a different type than the one
                *                     provided in the request, the value does not match. For example,
                *                         <code>{"S":"6"}</code> does not equal <code>{"N":"6"}</code>. Also,
                *                         <code>{"N":"6"}</code> does not equal <code>{"NS":["6", "2",
                *                     "1"]}</code>.</p>
                *                 <p></p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>LE</code> : Less than or equal. </p>
                *                 <p>
                *                     <code>AttributeValueList</code> can contain only one <code>AttributeValue</code>
                *                     element of type String, Number, or Binary (not a set type). If an item contains
                *                     an <code>AttributeValue</code> element of a different type than the one provided
                *                     in the request, the value does not match. For example, <code>{"S":"6"}</code>
                *                     does not equal <code>{"N":"6"}</code>. Also, <code>{"N":"6"}</code> does not
                *                     compare to <code>{"NS":["6", "2", "1"]}</code>.</p>
                *                 <p></p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>LT</code> : Less than. </p>
                *                 <p>
                *                     <code>AttributeValueList</code> can contain only one <code>AttributeValue</code>
                *                     of type String, Number, or Binary (not a set type). If an item contains an
                *                         <code>AttributeValue</code> element of a different type than the one
                *                     provided in the request, the value does not match. For example,
                *                         <code>{"S":"6"}</code> does not equal <code>{"N":"6"}</code>. Also,
                *                         <code>{"N":"6"}</code> does not compare to <code>{"NS":["6", "2",
                *                         "1"]}</code>.</p>
                *                 <p></p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>GE</code> : Greater than or equal. </p>
                *                 <p>
                *                     <code>AttributeValueList</code> can contain only one <code>AttributeValue</code>
                *                     element of type String, Number, or Binary (not a set type). If an item contains
                *                     an <code>AttributeValue</code> element of a different type than the one provided
                *                     in the request, the value does not match. For example, <code>{"S":"6"}</code>
                *                     does not equal <code>{"N":"6"}</code>. Also, <code>{"N":"6"}</code> does not
                *                     compare to <code>{"NS":["6", "2", "1"]}</code>.</p>
                *                 <p></p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>GT</code> : Greater than. </p>
                *                 <p>
                *                     <code>AttributeValueList</code> can contain only one <code>AttributeValue</code>
                *                     element of type String, Number, or Binary (not a set type). If an item contains
                *                     an <code>AttributeValue</code> element of a different type than the one provided
                *                     in the request, the value does not match. For example, <code>{"S":"6"}</code>
                *                     does not equal <code>{"N":"6"}</code>. Also, <code>{"N":"6"}</code> does not
                *                     compare to <code>{"NS":["6", "2", "1"]}</code>.</p>
                *                 <p></p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>NOT_NULL</code> : The attribute exists. <code>NOT_NULL</code> is supported
                *                     for all data types, including lists and maps.</p>
                *                 <note>
                *                     <p>This operator tests for the existence of an attribute, not its data type.
                *                         If the data type of attribute "<code>a</code>" is null, and you evaluate it
                *                         using <code>NOT_NULL</code>, the result is a Boolean <code>true</code>. This
                *                         result is because the attribute "<code>a</code>" exists; its data type is
                *                         not relevant to the <code>NOT_NULL</code> comparison operator.</p>
                *                 </note>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>NULL</code> : The attribute does not exist. <code>NULL</code> is supported
                *                     for all data types, including lists and maps.</p>
                *                 <note>
                *                     <p>This operator tests for the nonexistence of an attribute, not its data
                *                         type. If the data type of attribute "<code>a</code>" is null, and you
                *                         evaluate it using <code>NULL</code>, the result is a Boolean
                *                             <code>false</code>. This is because the attribute "<code>a</code>"
                *                         exists; its data type is not relevant to the <code>NULL</code> comparison
                *                         operator.</p>
                *                 </note>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>CONTAINS</code> : Checks for a subsequence, or value in a set.</p>
                *                 <p>
                *                     <code>AttributeValueList</code> can contain only one <code>AttributeValue</code>
                *                     element of type String, Number, or Binary (not a set type). If the target
                *                     attribute of the comparison is of type String, then the operator checks for a
                *                     substring match. If the target attribute of the comparison is of type Binary,
                *                     then the operator looks for a subsequence of the target that matches the input.
                *                     If the target attribute of the comparison is a set ("<code>SS</code>",
                *                         "<code>NS</code>", or "<code>BS</code>"), then the operator evaluates to
                *                     true if it finds an exact match with any member of the set.</p>
                *                 <p>CONTAINS is supported for lists: When evaluating "<code>a CONTAINS b</code>",
                *                         "<code>a</code>" can be a list; however, "<code>b</code>" cannot be a set, a
                *                     map, or a list.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>NOT_CONTAINS</code> : Checks for absence of a subsequence, or absence of a
                *                     value in a set.</p>
                *                 <p>
                *                     <code>AttributeValueList</code> can contain only one <code>AttributeValue</code>
                *                     element of type String, Number, or Binary (not a set type). If the target
                *                     attribute of the comparison is a String, then the operator checks for the
                *                     absence of a substring match. If the target attribute of the comparison is
                *                     Binary, then the operator checks for the absence of a subsequence of the target
                *                     that matches the input. If the target attribute of the comparison is a set
                *                         ("<code>SS</code>", "<code>NS</code>", or "<code>BS</code>"), then the
                *                     operator evaluates to true if it <i>does not</i> find an exact
                *                     match with any member of the set.</p>
                *                 <p>NOT_CONTAINS is supported for lists: When evaluating "<code>a NOT CONTAINS
                *                         b</code>", "<code>a</code>" can be a list; however, "<code>b</code>" cannot
                *                     be a set, a map, or a list.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>BEGINS_WITH</code> : Checks for a prefix. </p>
                *                 <p>
                *                     <code>AttributeValueList</code> can contain only one <code>AttributeValue</code>
                *                     of type String or Binary (not a Number or a set type). The target attribute of
                *                     the comparison must be of type String or Binary (not a Number or a set
                *                     type).</p>
                *                 <p></p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>IN</code> : Checks for matching elements in a list.</p>
                *                 <p>
                *                     <code>AttributeValueList</code> can contain one or more
                *                         <code>AttributeValue</code> elements of type String, Number, or Binary.
                *                     These attributes are compared against an existing attribute of an item. If any
                *                     elements of the input are equal to the item attribute, the expression evaluates
                *                     to true.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>BETWEEN</code> : Greater than or equal to the first value, and less than
                *                     or equal to the second value. </p>
                *                 <p>
                *                     <code>AttributeValueList</code> must contain two <code>AttributeValue</code>
                *                     elements of the same type, either String, Number, or Binary (not a set type). A
                *                     target attribute matches if the target value is greater than, or equal to, the
                *                     first element and less than, or equal to, the second element. If an item
                *                     contains an <code>AttributeValue</code> element of a different type than the one
                *                     provided in the request, the value does not match. For example,
                *                         <code>{"S":"6"}</code> does not compare to <code>{"N":"6"}</code>. Also,
                *                         <code>{"N":"6"}</code> does not compare to <code>{"NS":["6", "2",
                *                         "1"]}</code>
                *                 </p>
                *             </li>
                *          </ul>
                */
            ComparisonOperator?: ComparisonOperator | string;
            /**
                * <p>One or more values to evaluate against the supplied attribute. The number of values in
                *             the list depends on the <code>ComparisonOperator</code> being used.</p>
                *         <p>For type Number, value comparisons are numeric.</p>
                *         <p>String value comparisons for greater than, equals, or less than are based on ASCII
                *             character code values. For example, <code>a</code> is greater than <code>A</code>, and
                *                 <code>a</code> is greater than <code>B</code>. For a list of code values, see <a href="http://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters">http://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters</a>.</p>
                *         <p>For Binary, DynamoDB treats each byte of the binary data as unsigned when it
                *             compares binary values.</p>
                *         <p>For information on specifying data types in JSON, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DataFormat.html">JSON Data Format</a>
                *             in the <i>Amazon DynamoDB Developer Guide</i>.</p>
                */
            AttributeValueList?: AttributeValue[];
    }
    export namespace ExpectedAttributeValue {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ExpectedAttributeValue) => any;
    }
    export interface TransactGetItemsInput {
            /**
                * <p>An ordered array of up to 25 <code>TransactGetItem</code> objects, each of which
                *             contains a <code>Get</code> structure.</p>
                */
            TransactItems: TransactGetItem[] | undefined;
            /**
                * <p>A value of <code>TOTAL</code> causes consumed capacity information to be returned, and
                *             a value of <code>NONE</code> prevents that information from being returned. No other
                *             value is valid.</p>
                */
            ReturnConsumedCapacity?: ReturnConsumedCapacity | string;
    }
    export namespace TransactGetItemsInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TransactGetItemsInput) => any;
    }
    export interface TransactWriteItemsOutput {
            /**
                * <p>The capacity units consumed by the entire <code>TransactWriteItems</code> operation.
                *             The values of the list are ordered according to the ordering of the
                *                 <code>TransactItems</code> request parameter. </p>
                */
            ConsumedCapacity?: ConsumedCapacity[];
            /**
                * <p>A list of tables that were processed by <code>TransactWriteItems</code> and, for each
                *             table, information about any item collections that were affected by individual
                *                 <code>UpdateItem</code>, <code>PutItem</code>, or <code>DeleteItem</code>
                *             operations. </p>
                */
            ItemCollectionMetrics?: Record<string, ItemCollectionMetrics[]>;
    }
    export namespace TransactWriteItemsOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TransactWriteItemsOutput) => any;
    }
    /**
        * <p>Represents a request to perform a check that an item exists or to check the condition
        *             of specific attributes of the item.</p>
        */
    export interface ConditionCheck {
            /**
                * <p>The primary key of the item to be checked. Each element consists of an attribute name
                *             and a value for that attribute.</p>
                */
            Key: Record<string, AttributeValue> | undefined;
            /**
                * <p>Name of the table for the check item request.</p>
                */
            TableName: string | undefined;
            /**
                * <p>A condition that must be satisfied in order for a conditional update to
                *             succeed.</p>
                */
            ConditionExpression: string | undefined;
            /**
                * <p>One or more substitution tokens for attribute names in an expression.</p>
                */
            ExpressionAttributeNames?: Record<string, string>;
            /**
                * <p>One or more values that can be substituted in an expression.</p>
                */
            ExpressionAttributeValues?: Record<string, AttributeValue>;
            /**
                * <p>Use <code>ReturnValuesOnConditionCheckFailure</code> to get the item attributes if the
                *                 <code>ConditionCheck</code> condition fails. For
                *                 <code>ReturnValuesOnConditionCheckFailure</code>, the valid values are: NONE and
                *             ALL_OLD.</p>
                */
            ReturnValuesOnConditionCheckFailure?: ReturnValuesOnConditionCheckFailure | string;
    }
    export namespace ConditionCheck {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ConditionCheck) => any;
    }
    /**
        * <p>Represents a request to perform a <code>DeleteItem</code> operation.</p>
        */
    export interface Delete {
            /**
                * <p>The primary key of the item to be deleted. Each element consists of an attribute name
                *             and a value for that attribute.</p>
                */
            Key: Record<string, AttributeValue> | undefined;
            /**
                * <p>Name of the table in which the item to be deleted resides.</p>
                */
            TableName: string | undefined;
            /**
                * <p>A condition that must be satisfied in order for a conditional delete to
                *             succeed.</p>
                */
            ConditionExpression?: string;
            /**
                * <p>One or more substitution tokens for attribute names in an expression.</p>
                */
            ExpressionAttributeNames?: Record<string, string>;
            /**
                * <p>One or more values that can be substituted in an expression.</p>
                */
            ExpressionAttributeValues?: Record<string, AttributeValue>;
            /**
                * <p>Use <code>ReturnValuesOnConditionCheckFailure</code> to get the item attributes if the
                *                 <code>Delete</code> condition fails. For
                *                 <code>ReturnValuesOnConditionCheckFailure</code>, the valid values are: NONE and
                *             ALL_OLD.</p>
                */
            ReturnValuesOnConditionCheckFailure?: ReturnValuesOnConditionCheckFailure | string;
    }
    export namespace Delete {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Delete) => any;
    }
    /**
        * <p>Represents a request to perform a <code>PutItem</code> operation.</p>
        */
    export interface Put {
            /**
                * <p>A map of attribute name to attribute values, representing the primary key of the item
                *             to be written by <code>PutItem</code>. All of the table's primary key attributes must be
                *             specified, and their data types must match those of the table's key schema. If any
                *             attributes are present in the item that are part of an index key schema for the table,
                *             their types must match the index key schema. </p>
                */
            Item: Record<string, AttributeValue> | undefined;
            /**
                * <p>Name of the table in which to write the item.</p>
                */
            TableName: string | undefined;
            /**
                * <p>A condition that must be satisfied in order for a conditional update to
                *             succeed.</p>
                */
            ConditionExpression?: string;
            /**
                * <p>One or more substitution tokens for attribute names in an expression.</p>
                */
            ExpressionAttributeNames?: Record<string, string>;
            /**
                * <p>One or more values that can be substituted in an expression.</p>
                */
            ExpressionAttributeValues?: Record<string, AttributeValue>;
            /**
                * <p>Use <code>ReturnValuesOnConditionCheckFailure</code> to get the item attributes if the
                *                 <code>Put</code> condition fails. For
                *                 <code>ReturnValuesOnConditionCheckFailure</code>, the valid values are: NONE and
                *             ALL_OLD.</p>
                */
            ReturnValuesOnConditionCheckFailure?: ReturnValuesOnConditionCheckFailure | string;
    }
    export namespace Put {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Put) => any;
    }
    /**
        * <p>Represents a request to perform an <code>UpdateItem</code> operation.</p>
        */
    export interface Update {
            /**
                * <p>The primary key of the item to be updated. Each element consists of an attribute name
                *             and a value for that attribute.</p>
                */
            Key: Record<string, AttributeValue> | undefined;
            /**
                * <p>An expression that defines one or more attributes to be updated, the action to be
                *             performed on them, and new value(s) for them.</p>
                */
            UpdateExpression: string | undefined;
            /**
                * <p>Name of the table for the <code>UpdateItem</code> request.</p>
                */
            TableName: string | undefined;
            /**
                * <p>A condition that must be satisfied in order for a conditional update to
                *             succeed.</p>
                */
            ConditionExpression?: string;
            /**
                * <p>One or more substitution tokens for attribute names in an expression.</p>
                */
            ExpressionAttributeNames?: Record<string, string>;
            /**
                * <p>One or more values that can be substituted in an expression.</p>
                */
            ExpressionAttributeValues?: Record<string, AttributeValue>;
            /**
                * <p>Use <code>ReturnValuesOnConditionCheckFailure</code> to get the item attributes if the
                *                 <code>Update</code> condition fails. For
                *                 <code>ReturnValuesOnConditionCheckFailure</code>, the valid values are: NONE,
                *             ALL_OLD, UPDATED_OLD, ALL_NEW, UPDATED_NEW.</p>
                */
            ReturnValuesOnConditionCheckFailure?: ReturnValuesOnConditionCheckFailure | string;
    }
    export namespace Update {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Update) => any;
    }
    /**
        * <p>Represents the output of a <code>DeleteItem</code> operation.</p>
        */
    export interface DeleteItemOutput {
            /**
                * <p>A map of attribute names to <code>AttributeValue</code> objects, representing the item
                *             as it appeared before the <code>DeleteItem</code> operation. This map appears in the
                *             response only if <code>ReturnValues</code> was specified as <code>ALL_OLD</code> in the
                *             request.</p>
                */
            Attributes?: Record<string, AttributeValue>;
            /**
                * <p>The capacity units consumed by the <code>DeleteItem</code> operation. The data
                *             returned includes the total provisioned throughput consumed, along with statistics for
                *             the table and any indexes involved in the operation. <code>ConsumedCapacity</code> is
                *             only returned if the <code>ReturnConsumedCapacity</code> parameter was specified. For
                *             more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughputIntro.html">Provisioned Mode</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>.</p>
                */
            ConsumedCapacity?: ConsumedCapacity;
            /**
                * <p>Information about item collections, if any, that were affected by the
                *                 <code>DeleteItem</code> operation. <code>ItemCollectionMetrics</code> is only
                *             returned if the <code>ReturnItemCollectionMetrics</code> parameter was specified. If the
                *             table does not have any local secondary indexes, this information is not returned in the
                *             response.</p>
                *         <p>Each <code>ItemCollectionMetrics</code> element consists of:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>ItemCollectionKey</code> - The partition key value of the item collection.
                *                     This is the same as the partition key value of the item itself.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>SizeEstimateRangeGB</code> - An estimate of item collection size, in
                *                     gigabytes. This value is a two-element array containing a lower bound and an
                *                     upper bound for the estimate. The estimate includes the size of all the items in
                *                     the table, plus the size of all attributes projected into all of the local
                *                     secondary indexes on that table. Use this estimate to measure whether a local
                *                     secondary index is approaching its size limit.</p>
                *                 <p>The estimate is subject to change over time; therefore, do not rely on the
                *                     precision or accuracy of the estimate.</p>
                *             </li>
                *          </ul>
                */
            ItemCollectionMetrics?: ItemCollectionMetrics;
    }
    export namespace DeleteItemOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteItemOutput) => any;
    }
    export interface ExecuteStatementOutput {
            /**
                * <p>If a read operation was used, this property will contain the result of the read
                *             operation; a map of attribute names and their values. For the write operations this
                *             value will be empty.</p>
                */
            Items?: Record<string, AttributeValue>[];
            /**
                * <p>If the response of a read request exceeds the response payload limit DynamoDB will set
                *             this value in the response. If set, you can use that this value in the subsequent
                *             request to get the remaining results.</p>
                */
            NextToken?: string;
            /**
                * <p>The capacity units consumed by an operation. The data returned includes the total
                *             provisioned throughput consumed, along with statistics for the table and any indexes
                *             involved in the operation. <code>ConsumedCapacity</code> is only returned if the request
                *             asked for it. For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughputIntro.html">Provisioned Throughput</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>.</p>
                */
            ConsumedCapacity?: ConsumedCapacity;
            /**
                * <p>The primary key of the item where the operation stopped, inclusive of the previous
                *             result set. Use this value to start a new operation, excluding this value in the new
                *             request. If <code>LastEvaluatedKey</code> is empty, then the "last page" of results has
                *             been processed and there is no more data to be retrieved. If
                *                 <code>LastEvaluatedKey</code> is not empty, it does not necessarily mean that there
                *             is more data in the result set. The only way to know when you have reached the end of
                *             the result set is when <code>LastEvaluatedKey</code> is empty. </p>
                */
            LastEvaluatedKey?: Record<string, AttributeValue>;
    }
    export namespace ExecuteStatementOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ExecuteStatementOutput) => any;
    }
    /**
        * <p>Represents the output of a <code>PutItem</code> operation.</p>
        */
    export interface PutItemOutput {
            /**
                * <p>The attribute values as they appeared before the <code>PutItem</code> operation, but
                *             only if <code>ReturnValues</code> is specified as <code>ALL_OLD</code> in the request.
                *             Each element consists of an attribute name and an attribute value.</p>
                */
            Attributes?: Record<string, AttributeValue>;
            /**
                * <p>The capacity units consumed by the <code>PutItem</code> operation. The data returned
                *             includes the total provisioned throughput consumed, along with statistics for the table
                *             and any indexes involved in the operation. <code>ConsumedCapacity</code> is only
                *             returned if the <code>ReturnConsumedCapacity</code> parameter was specified. For more
                *             information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughputIntro.html">Read/Write Capacity Mode</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>.</p>
                */
            ConsumedCapacity?: ConsumedCapacity;
            /**
                * <p>Information about item collections, if any, that were affected by the
                *                 <code>PutItem</code> operation. <code>ItemCollectionMetrics</code> is only returned
                *             if the <code>ReturnItemCollectionMetrics</code> parameter was specified. If the table
                *             does not have any local secondary indexes, this information is not returned in the
                *             response.</p>
                *         <p>Each <code>ItemCollectionMetrics</code> element consists of:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>ItemCollectionKey</code> - The partition key value of the item collection.
                *                     This is the same as the partition key value of the item itself.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>SizeEstimateRangeGB</code> - An estimate of item collection size, in
                *                     gigabytes. This value is a two-element array containing a lower bound and an
                *                     upper bound for the estimate. The estimate includes the size of all the items in
                *                     the table, plus the size of all attributes projected into all of the local
                *                     secondary indexes on that table. Use this estimate to measure whether a local
                *                     secondary index is approaching its size limit.</p>
                *                 <p>The estimate is subject to change over time; therefore, do not rely on the
                *                     precision or accuracy of the estimate.</p>
                *             </li>
                *          </ul>
                */
            ItemCollectionMetrics?: ItemCollectionMetrics;
    }
    export namespace PutItemOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutItemOutput) => any;
    }
    /**
        * <p>Represents the output of a <code>Query</code> operation.</p>
        */
    export interface QueryOutput {
            /**
                * <p>An array of item attributes that match the query criteria. Each element in this array
                *             consists of an attribute name and the value for that attribute.</p>
                */
            Items?: Record<string, AttributeValue>[];
            /**
                * <p>The number of items in the response.</p>
                *         <p>If you used a <code>QueryFilter</code> in the request, then <code>Count</code> is the
                *             number of items returned after the filter was applied, and <code>ScannedCount</code> is
                *             the number of matching items before the filter was applied.</p>
                *         <p>If you did not use a filter in the request, then <code>Count</code> and
                *                 <code>ScannedCount</code> are the same.</p>
                */
            Count?: number;
            /**
                * <p>The number of items evaluated, before any <code>QueryFilter</code> is applied. A high
                *                 <code>ScannedCount</code> value with few, or no, <code>Count</code> results
                *             indicates an inefficient <code>Query</code> operation. For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/QueryAndScan.html#Count">Count and
                *                 ScannedCount</a> in the <i>Amazon DynamoDB Developer
                *             Guide</i>.</p>
                *         <p>If you did not use a filter in the request, then <code>ScannedCount</code> is the same
                *             as <code>Count</code>.</p>
                */
            ScannedCount?: number;
            /**
                * <p>The primary key of the item where the operation stopped, inclusive of the previous
                *             result set. Use this value to start a new operation, excluding this value in the new
                *             request.</p>
                *         <p>If <code>LastEvaluatedKey</code> is empty, then the "last page" of results has been
                *             processed and there is no more data to be retrieved.</p>
                *         <p>If <code>LastEvaluatedKey</code> is not empty, it does not necessarily mean that there
                *             is more data in the result set. The only way to know when you have reached the end of
                *             the result set is when <code>LastEvaluatedKey</code> is empty.</p>
                */
            LastEvaluatedKey?: Record<string, AttributeValue>;
            /**
                * <p>The capacity units consumed by the <code>Query</code> operation. The data returned
                *             includes the total provisioned throughput consumed, along with statistics for the table
                *             and any indexes involved in the operation. <code>ConsumedCapacity</code> is only
                *             returned if the <code>ReturnConsumedCapacity</code> parameter was specified. For more
                *             information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughputIntro.html">Provisioned Throughput</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>.</p>
                */
            ConsumedCapacity?: ConsumedCapacity;
    }
    export namespace QueryOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: QueryOutput) => any;
    }
    /**
        * <p>Represents the output of a <code>Scan</code> operation.</p>
        */
    export interface ScanOutput {
            /**
                * <p>An array of item attributes that match the scan criteria. Each element in this array
                *             consists of an attribute name and the value for that attribute.</p>
                */
            Items?: Record<string, AttributeValue>[];
            /**
                * <p>The number of items in the response.</p>
                *         <p>If you set <code>ScanFilter</code> in the request, then <code>Count</code> is the
                *             number of items returned after the filter was applied, and <code>ScannedCount</code> is
                *             the number of matching items before the filter was applied.</p>
                *         <p>If you did not use a filter in the request, then <code>Count</code> is the same as
                *                 <code>ScannedCount</code>.</p>
                */
            Count?: number;
            /**
                * <p>The number of items evaluated, before any <code>ScanFilter</code> is applied. A high
                *                 <code>ScannedCount</code> value with few, or no, <code>Count</code> results
                *             indicates an inefficient <code>Scan</code> operation. For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/QueryAndScan.html#Count">Count and
                *                 ScannedCount</a> in the <i>Amazon DynamoDB Developer
                *             Guide</i>.</p>
                *         <p>If you did not use a filter in the request, then <code>ScannedCount</code> is the same
                *             as <code>Count</code>.</p>
                */
            ScannedCount?: number;
            /**
                * <p>The primary key of the item where the operation stopped, inclusive of the previous
                *             result set. Use this value to start a new operation, excluding this value in the new
                *             request.</p>
                *         <p>If <code>LastEvaluatedKey</code> is empty, then the "last page" of results has been
                *             processed and there is no more data to be retrieved.</p>
                *         <p>If <code>LastEvaluatedKey</code> is not empty, it does not necessarily mean that there
                *             is more data in the result set. The only way to know when you have reached the end of
                *             the result set is when <code>LastEvaluatedKey</code> is empty.</p>
                */
            LastEvaluatedKey?: Record<string, AttributeValue>;
            /**
                * <p>The capacity units consumed by the <code>Scan</code> operation. The data returned
                *             includes the total provisioned throughput consumed, along with statistics for the table
                *             and any indexes involved in the operation. <code>ConsumedCapacity</code> is only
                *             returned if the <code>ReturnConsumedCapacity</code> parameter was specified. For more
                *             information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughputIntro.html">Provisioned Throughput</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>.</p>
                */
            ConsumedCapacity?: ConsumedCapacity;
    }
    export namespace ScanOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ScanOutput) => any;
    }
    /**
        * <p>Represents the output of an <code>UpdateItem</code> operation.</p>
        */
    export interface UpdateItemOutput {
            /**
                * <p>A map of attribute values as they appear before or after the <code>UpdateItem</code>
                *             operation, as determined by the <code>ReturnValues</code> parameter.</p>
                *         <p>The <code>Attributes</code> map is only present if <code>ReturnValues</code> was
                *             specified as something other than <code>NONE</code> in the request. Each element
                *             represents one attribute.</p>
                */
            Attributes?: Record<string, AttributeValue>;
            /**
                * <p>The capacity units consumed by the <code>UpdateItem</code> operation. The data
                *             returned includes the total provisioned throughput consumed, along with statistics for
                *             the table and any indexes involved in the operation. <code>ConsumedCapacity</code> is
                *             only returned if the <code>ReturnConsumedCapacity</code> parameter was specified. For
                *             more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughputIntro.html">Provisioned Throughput</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>.</p>
                */
            ConsumedCapacity?: ConsumedCapacity;
            /**
                * <p>Information about item collections, if any, that were affected by the
                *                 <code>UpdateItem</code> operation. <code>ItemCollectionMetrics</code> is only
                *             returned if the <code>ReturnItemCollectionMetrics</code> parameter was specified. If the
                *             table does not have any local secondary indexes, this information is not returned in the
                *             response.</p>
                *         <p>Each <code>ItemCollectionMetrics</code> element consists of:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>ItemCollectionKey</code> - The partition key value of the item collection.
                *                     This is the same as the partition key value of the item itself.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>SizeEstimateRangeGB</code> - An estimate of item collection size, in
                *                     gigabytes. This value is a two-element array containing a lower bound and an
                *                     upper bound for the estimate. The estimate includes the size of all the items in
                *                     the table, plus the size of all attributes projected into all of the local
                *                     secondary indexes on that table. Use this estimate to measure whether a local
                *                     secondary index is approaching its size limit.</p>
                *                 <p>The estimate is subject to change over time; therefore, do not rely on the
                *                     precision or accuracy of the estimate.</p>
                *             </li>
                *          </ul>
                */
            ItemCollectionMetrics?: ItemCollectionMetrics;
    }
    export namespace UpdateItemOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateItemOutput) => any;
    }
    /**
        * <p>Represents an operation to perform - either <code>DeleteItem</code> or
        *                 <code>PutItem</code>. You can only request one of these operations, not both, in a
        *             single <code>WriteRequest</code>. If you do need to perform both of these operations,
        *             you need to provide two separate <code>WriteRequest</code> objects.</p>
        */
    export interface WriteRequest {
            /**
                * <p>A request to perform a <code>PutItem</code> operation.</p>
                */
            PutRequest?: PutRequest;
            /**
                * <p>A request to perform a <code>DeleteItem</code> operation.</p>
                */
            DeleteRequest?: DeleteRequest;
    }
    export namespace WriteRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: WriteRequest) => any;
    }
    /**
        * <p>Represents the output of a <code>BatchGetItem</code> operation.</p>
        */
    export interface BatchGetItemOutput {
            /**
                * <p>A map of table name to a list of items. Each object in <code>Responses</code> consists
                *             of a table name, along with a map of attribute data consisting of the data type and
                *             attribute value.</p>
                */
            Responses?: Record<string, Record<string, AttributeValue>[]>;
            /**
                * <p>A map of tables and their respective keys that were not processed with the current
                *             response. The <code>UnprocessedKeys</code> value is in the same form as
                *                 <code>RequestItems</code>, so the value can be provided directly to a subsequent
                *                 <code>BatchGetItem</code> operation. For more information, see
                *                 <code>RequestItems</code> in the Request Parameters section.</p>
                *         <p>Each element consists of:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>Keys</code> - An array of primary key attribute values that define
                *                     specific items in the table.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>ProjectionExpression</code> - One or more attributes to be retrieved from
                *                     the table or index. By default, all attributes are returned. If a requested
                *                     attribute is not found, it does not appear in the result.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>ConsistentRead</code> - The consistency of a read operation. If set to
                *                         <code>true</code>, then a strongly consistent read is used; otherwise, an
                *                     eventually consistent read is used.</p>
                *             </li>
                *          </ul>
                *         <p>If there are no unprocessed keys remaining, the response contains an empty
                *                 <code>UnprocessedKeys</code> map.</p>
                */
            UnprocessedKeys?: Record<string, KeysAndAttributes>;
            /**
                * <p>The read capacity units consumed by the entire <code>BatchGetItem</code>
                *             operation.</p>
                *         <p>Each element consists of:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>TableName</code> - The table that consumed the provisioned
                *                     throughput.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>CapacityUnits</code> - The total number of capacity units consumed.</p>
                *             </li>
                *          </ul>
                */
            ConsumedCapacity?: ConsumedCapacity[];
    }
    export namespace BatchGetItemOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchGetItemOutput) => any;
    }
    /**
        * <p>Represents the input of a <code>Scan</code> operation.</p>
        */
    export interface ScanInput {
            /**
                * <p>The name of the table containing the requested items; or, if you provide
                *                 <code>IndexName</code>, the name of the table to which that index belongs.</p>
                */
            TableName: string | undefined;
            /**
                * <p>The name of a secondary index to scan. This index can be any local secondary index or
                *             global secondary index. Note that if you use the <code>IndexName</code> parameter, you
                *             must also provide <code>TableName</code>.</p>
                */
            IndexName?: string;
            /**
                * <p>This is a legacy parameter. Use <code>ProjectionExpression</code> instead. For more
                *             information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.AttributesToGet.html">AttributesToGet</a> in the <i>Amazon DynamoDB Developer
                *             Guide</i>.</p>
                */
            AttributesToGet?: string[];
            /**
                * <p>The maximum number of items to evaluate (not necessarily the number of matching
                *             items). If DynamoDB processes the number of items up to the limit while processing the
                *             results, it stops the operation and returns the matching values up to that point, and a
                *             key in <code>LastEvaluatedKey</code> to apply in a subsequent operation, so that you can
                *             pick up where you left off. Also, if the processed dataset size exceeds 1 MB before
                *             DynamoDB reaches this limit, it stops the operation and returns the matching values up
                *             to the limit, and a key in <code>LastEvaluatedKey</code> to apply in a subsequent
                *             operation to continue the operation. For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/QueryAndScan.html">Working with Queries</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>.</p>
                */
            Limit?: number;
            /**
                * <p>The attributes to be returned in the result. You can retrieve all item attributes,
                *             specific item attributes, the count of matching items, or in the case of an index, some
                *             or all of the attributes projected into the index.</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>ALL_ATTRIBUTES</code> - Returns all of the item attributes from the
                *                     specified table or index. If you query a local secondary index, then for each
                *                     matching item in the index, DynamoDB fetches the entire item from the parent
                *                     table. If the index is configured to project all item attributes, then all of
                *                     the data can be obtained from the local secondary index, and no fetching is
                *                     required.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>ALL_PROJECTED_ATTRIBUTES</code> - Allowed only when querying an index.
                *                     Retrieves all attributes that have been projected into the index. If the index
                *                     is configured to project all attributes, this return value is equivalent to
                *                     specifying <code>ALL_ATTRIBUTES</code>.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>COUNT</code> - Returns the number of matching items, rather than the
                *                     matching items themselves.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>SPECIFIC_ATTRIBUTES</code> - Returns only the attributes listed in
                *                         <code>ProjectionExpression</code>. This return value is equivalent to
                *                     specifying <code>ProjectionExpression</code> without specifying any value for
                *                         <code>Select</code>.</p>
                *                 <p>If you query or scan a local secondary index and request only attributes that
                *                     are projected into that index, the operation reads only the index and not the
                *                     table. If any of the requested attributes are not projected into the local
                *                     secondary index, DynamoDB fetches each of these attributes from the parent
                *                     table. This extra fetching incurs additional throughput cost and latency.</p>
                *                 <p>If you query or scan a global secondary index, you can only request attributes
                *                     that are projected into the index. Global secondary index queries cannot fetch
                *                     attributes from the parent table.</p>
                *             </li>
                *          </ul>
                *         <p>If neither <code>Select</code> nor <code>ProjectionExpression</code> are specified,
                *             DynamoDB defaults to <code>ALL_ATTRIBUTES</code> when accessing a table, and
                *                 <code>ALL_PROJECTED_ATTRIBUTES</code> when accessing an index. You cannot use both
                *                 <code>Select</code> and <code>ProjectionExpression</code> together in a single
                *             request, unless the value for <code>Select</code> is <code>SPECIFIC_ATTRIBUTES</code>.
                *             (This usage is equivalent to specifying <code>ProjectionExpression</code> without any
                *             value for <code>Select</code>.)</p>
                *         <note>
                *             <p>If you use the <code>ProjectionExpression</code> parameter, then the value for
                *                     <code>Select</code> can only be <code>SPECIFIC_ATTRIBUTES</code>. Any other
                *                 value for <code>Select</code> will return an error.</p>
                *         </note>
                */
            Select?: Select | string;
            /**
                * <p>This is a legacy parameter. Use <code>FilterExpression</code> instead. For more
                *             information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.ScanFilter.html">ScanFilter</a> in the <i>Amazon DynamoDB Developer
                *             Guide</i>.</p>
                */
            ScanFilter?: Record<string, Condition>;
            /**
                * <p>This is a legacy parameter. Use <code>FilterExpression</code> instead. For more
                *             information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.ConditionalOperator.html">ConditionalOperator</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>.</p>
                */
            ConditionalOperator?: ConditionalOperator | string;
            /**
                * <p>The primary key of the first item that this operation will evaluate. Use the value
                *             that was returned for <code>LastEvaluatedKey</code> in the previous operation.</p>
                *         <p>The data type for <code>ExclusiveStartKey</code> must be String, Number or Binary. No
                *             set data types are allowed.</p>
                *         <p>In a parallel scan, a <code>Scan</code> request that includes
                *                 <code>ExclusiveStartKey</code> must specify the same segment whose previous
                *                 <code>Scan</code> returned the corresponding value of
                *             <code>LastEvaluatedKey</code>.</p>
                */
            ExclusiveStartKey?: Record<string, AttributeValue>;
            /**
                * <p>Determines the level of detail about either provisioned or on-demand throughput
                *             consumption that is returned in the response:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>INDEXES</code> - The response includes the aggregate
                *                         <code>ConsumedCapacity</code> for the operation, together with
                *                         <code>ConsumedCapacity</code> for each table and secondary index that was
                *                     accessed.</p>
                *                 <p>Note that some operations, such as <code>GetItem</code> and
                *                         <code>BatchGetItem</code>, do not access any indexes at all. In these cases,
                *                     specifying <code>INDEXES</code> will only return <code>ConsumedCapacity</code>
                *                     information for table(s).</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>TOTAL</code> - The response includes only the aggregate
                *                         <code>ConsumedCapacity</code> for the operation.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>NONE</code> - No <code>ConsumedCapacity</code> details are included in the
                *                     response.</p>
                *             </li>
                *          </ul>
                */
            ReturnConsumedCapacity?: ReturnConsumedCapacity | string;
            /**
                * <p>For a parallel <code>Scan</code> request, <code>TotalSegments</code> represents the
                *             total number of segments into which the <code>Scan</code> operation will be divided. The
                *             value of <code>TotalSegments</code> corresponds to the number of application workers
                *             that will perform the parallel scan. For example, if you want to use four application
                *             threads to scan a table or an index, specify a <code>TotalSegments</code> value of
                *             4.</p>
                *         <p>The value for <code>TotalSegments</code> must be greater than or equal to 1, and less
                *             than or equal to 1000000. If you specify a <code>TotalSegments</code> value of 1, the
                *                 <code>Scan</code> operation will be sequential rather than parallel.</p>
                *         <p>If you specify <code>TotalSegments</code>, you must also specify
                *             <code>Segment</code>.</p>
                */
            TotalSegments?: number;
            /**
                * <p>For a parallel <code>Scan</code> request, <code>Segment</code> identifies an
                *             individual segment to be scanned by an application worker.</p>
                *         <p>Segment IDs are zero-based, so the first segment is always 0. For example, if you want
                *             to use four application threads to scan a table or an index, then the first thread
                *             specifies a <code>Segment</code> value of 0, the second thread specifies 1, and so
                *             on.</p>
                *         <p>The value of <code>LastEvaluatedKey</code> returned from a parallel <code>Scan</code>
                *             request must be used as <code>ExclusiveStartKey</code> with the same segment ID in a
                *             subsequent <code>Scan</code> operation.</p>
                *         <p>The value for <code>Segment</code> must be greater than or equal to 0, and less than
                *             the value provided for <code>TotalSegments</code>.</p>
                *         <p>If you provide <code>Segment</code>, you must also provide
                *             <code>TotalSegments</code>.</p>
                */
            Segment?: number;
            /**
                * <p>A string that identifies one or more attributes to retrieve from the specified table
                *             or index. These attributes can include scalars, sets, or elements of a JSON document.
                *             The attributes in the expression must be separated by commas.</p>
                *         <p>If no attribute names are specified, then all attributes will be returned. If any of
                *             the requested attributes are not found, they will not appear in the result.</p>
                *         <p>For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html">Specifying Item Attributes</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>.</p>
                */
            ProjectionExpression?: string;
            /**
                * <p>A string that contains conditions that DynamoDB applies after the <code>Scan</code>
                *             operation, but before the data is returned to you. Items that do not satisfy the
                *                 <code>FilterExpression</code> criteria are not returned.</p>
                *         <note>
                *             <p>A <code>FilterExpression</code> is applied after the items have already been read;
                *                 the process of filtering does not consume any additional read capacity units.</p>
                *         </note>
                *         <p>For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/QueryAndScan.html#Query.FilterExpression">Filter Expressions</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>.</p>
                */
            FilterExpression?: string;
            /**
                * <p>One or more substitution tokens for attribute names in an expression. The following
                *             are some use cases for using <code>ExpressionAttributeNames</code>:</p>
                *         <ul>
                *             <li>
                *                 <p>To access an attribute whose name conflicts with a DynamoDB reserved
                *                     word.</p>
                *             </li>
                *             <li>
                *                 <p>To create a placeholder for repeating occurrences of an attribute name in an
                *                     expression.</p>
                *             </li>
                *             <li>
                *                 <p>To prevent special characters in an attribute name from being misinterpreted
                *                     in an expression.</p>
                *             </li>
                *          </ul>
                *         <p>Use the <b>#</b> character in an expression to dereference
                *             an attribute name. For example, consider the following attribute name:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>Percentile</code>
                *                 </p>
                *             </li>
                *          </ul>
                *         <p>The name of this attribute conflicts with a reserved word, so it cannot be used
                *             directly in an expression. (For the complete list of reserved words, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html">Reserved Words</a> in the <i>Amazon DynamoDB Developer
                *             Guide</i>). To work around this, you could specify the following for
                *                 <code>ExpressionAttributeNames</code>:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>{"#P":"Percentile"}</code>
                *                 </p>
                *             </li>
                *          </ul>
                *         <p>You could then use this substitution in an expression, as in this example:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>#P = :val</code>
                *                 </p>
                *             </li>
                *          </ul>
                *         <note>
                *             <p>Tokens that begin with the <b>:</b> character are
                *                     <i>expression attribute values</i>, which are placeholders for the
                *                 actual value at runtime.</p>
                *         </note>
                *         <p>For more information on expression attribute names, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html">Specifying Item Attributes</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>.</p>
                */
            ExpressionAttributeNames?: Record<string, string>;
            /**
                * <p>One or more values that can be substituted in an expression.</p>
                *         <p>Use the <b>:</b> (colon) character in an expression to
                *             dereference an attribute value. For example, suppose that you wanted to check whether
                *             the value of the <code>ProductStatus</code> attribute was one of the following: </p>
                *         <p>
                *             <code>Available | Backordered | Discontinued</code>
                *         </p>
                *         <p>You would first need to specify <code>ExpressionAttributeValues</code> as
                *             follows:</p>
                *         <p>
                *             <code>{ ":avail":{"S":"Available"}, ":back":{"S":"Backordered"},
                *                 ":disc":{"S":"Discontinued"} }</code>
                *         </p>
                *         <p>You could then use these values in an expression, such as this:</p>
                *         <p>
                *             <code>ProductStatus IN (:avail, :back, :disc)</code>
                *         </p>
                *         <p>For more information on expression attribute values, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.SpecifyingConditions.html">Condition Expressions</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>.</p>
                */
            ExpressionAttributeValues?: Record<string, AttributeValue>;
            /**
                * <p>A Boolean value that determines the read consistency model during the scan:</p>
                *         <ul>
                *             <li>
                *                 <p>If <code>ConsistentRead</code> is <code>false</code>, then the data returned
                *                     from <code>Scan</code> might not contain the results from other recently
                *                     completed write operations (<code>PutItem</code>, <code>UpdateItem</code>, or
                *                         <code>DeleteItem</code>).</p>
                *             </li>
                *             <li>
                *                 <p>If <code>ConsistentRead</code> is <code>true</code>, then all of the write
                *                     operations that completed before the <code>Scan</code> began are guaranteed to
                *                     be contained in the <code>Scan</code> response.</p>
                *             </li>
                *          </ul>
                *         <p>The default setting for <code>ConsistentRead</code> is <code>false</code>.</p>
                *         <p>The <code>ConsistentRead</code> parameter is not supported on global secondary
                *             indexes. If you scan a global secondary index with <code>ConsistentRead</code> set to
                *             true, you will receive a <code>ValidationException</code>.</p>
                */
            ConsistentRead?: boolean;
    }
    export namespace ScanInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ScanInput) => any;
    }
    /**
        * <p>Represents the input of a <code>BatchWriteItem</code> operation.</p>
        */
    export interface BatchWriteItemInput {
            /**
                * <p>A map of one or more table names and, for each table, a list of operations to be
                *             performed (<code>DeleteRequest</code> or <code>PutRequest</code>). Each element in the
                *             map consists of the following:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>DeleteRequest</code> - Perform a <code>DeleteItem</code> operation on the
                *                     specified item. The item to be deleted is identified by a <code>Key</code>
                *                     subelement:</p>
                *                 <ul>
                *                   <li>
                *                         <p>
                *                             <code>Key</code> - A map of primary key attribute values that uniquely
                *                             identify the item. Each entry in this map consists of an attribute name
                *                             and an attribute value. For each primary key, you must provide
                *                                 <i>all</i> of the key attributes. For example, with a
                *                             simple primary key, you only need to provide a value for the partition
                *                             key. For a composite primary key, you must provide values for
                *                                 <i>both</i> the partition key and the sort key.</p>
                *                     </li>
                *                </ul>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>PutRequest</code> - Perform a <code>PutItem</code> operation on the
                *                     specified item. The item to be put is identified by an <code>Item</code>
                *                     subelement:</p>
                *                 <ul>
                *                   <li>
                *                         <p>
                *                             <code>Item</code> - A map of attributes and their values. Each entry in
                *                             this map consists of an attribute name and an attribute value. Attribute
                *                             values must not be null; string and binary type attributes must have
                *                             lengths greater than zero; and set type attributes must not be empty.
                *                             Requests that contain empty values are rejected with a
                *                                 <code>ValidationException</code> exception.</p>
                *                         <p>If you specify any attributes that are part of an index key, then the
                *                             data types for those attributes must match those of the schema in the
                *                             table's attribute definition.</p>
                *                     </li>
                *                </ul>
                *             </li>
                *          </ul>
                */
            RequestItems: Record<string, WriteRequest[]> | undefined;
            /**
                * <p>Determines the level of detail about either provisioned or on-demand throughput
                *             consumption that is returned in the response:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>INDEXES</code> - The response includes the aggregate
                *                         <code>ConsumedCapacity</code> for the operation, together with
                *                         <code>ConsumedCapacity</code> for each table and secondary index that was
                *                     accessed.</p>
                *                 <p>Note that some operations, such as <code>GetItem</code> and
                *                         <code>BatchGetItem</code>, do not access any indexes at all. In these cases,
                *                     specifying <code>INDEXES</code> will only return <code>ConsumedCapacity</code>
                *                     information for table(s).</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>TOTAL</code> - The response includes only the aggregate
                *                         <code>ConsumedCapacity</code> for the operation.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>NONE</code> - No <code>ConsumedCapacity</code> details are included in the
                *                     response.</p>
                *             </li>
                *          </ul>
                */
            ReturnConsumedCapacity?: ReturnConsumedCapacity | string;
            /**
                * <p>Determines whether item collection metrics are returned. If set to <code>SIZE</code>,
                *             the response includes statistics about item collections, if any, that were modified
                *             during the operation are returned in the response. If set to <code>NONE</code> (the
                *             default), no statistics are returned.</p>
                */
            ReturnItemCollectionMetrics?: ReturnItemCollectionMetrics | string;
    }
    export namespace BatchWriteItemInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchWriteItemInput) => any;
    }
    /**
        * <p>Represents the input of a <code>DeleteItem</code> operation.</p>
        */
    export interface DeleteItemInput {
            /**
                * <p>The name of the table from which to delete the item.</p>
                */
            TableName: string | undefined;
            /**
                * <p>A map of attribute names to <code>AttributeValue</code> objects, representing the
                *             primary key of the item to delete.</p>
                *         <p>For the primary key, you must provide all of the attributes. For example, with a
                *             simple primary key, you only need to provide a value for the partition key. For a
                *             composite primary key, you must provide values for both the partition key and the sort
                *             key.</p>
                */
            Key: Record<string, AttributeValue> | undefined;
            /**
                * <p>This is a legacy parameter. Use <code>ConditionExpression</code> instead. For more
                *             information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.Expected.html">Expected</a> in the <i>Amazon DynamoDB Developer
                *             Guide</i>.</p>
                */
            Expected?: Record<string, ExpectedAttributeValue>;
            /**
                * <p>This is a legacy parameter. Use <code>ConditionExpression</code> instead. For more
                *             information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.ConditionalOperator.html">ConditionalOperator</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>.</p>
                */
            ConditionalOperator?: ConditionalOperator | string;
            /**
                * <p>Use <code>ReturnValues</code> if you want to get the item attributes as they appeared
                *             before they were deleted. For <code>DeleteItem</code>, the valid values are:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>NONE</code> - If <code>ReturnValues</code> is not specified, or if its
                *                     value is <code>NONE</code>, then nothing is returned. (This setting is the
                *                     default for <code>ReturnValues</code>.)</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>ALL_OLD</code> - The content of the old item is returned.</p>
                *             </li>
                *          </ul>
                *         <p>There is no additional cost associated with requesting a return value aside from the small
                *             network and processing overhead of receiving a larger response. No read capacity units are
                *             consumed.</p>
                *         <note>
                *             <p>The <code>ReturnValues</code> parameter is used by several DynamoDB operations;
                *                 however, <code>DeleteItem</code> does not recognize any values other than
                *                     <code>NONE</code> or <code>ALL_OLD</code>.</p>
                *         </note>
                */
            ReturnValues?: ReturnValue | string;
            /**
                * <p>Determines the level of detail about either provisioned or on-demand throughput
                *             consumption that is returned in the response:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>INDEXES</code> - The response includes the aggregate
                *                         <code>ConsumedCapacity</code> for the operation, together with
                *                         <code>ConsumedCapacity</code> for each table and secondary index that was
                *                     accessed.</p>
                *                 <p>Note that some operations, such as <code>GetItem</code> and
                *                         <code>BatchGetItem</code>, do not access any indexes at all. In these cases,
                *                     specifying <code>INDEXES</code> will only return <code>ConsumedCapacity</code>
                *                     information for table(s).</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>TOTAL</code> - The response includes only the aggregate
                *                         <code>ConsumedCapacity</code> for the operation.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>NONE</code> - No <code>ConsumedCapacity</code> details are included in the
                *                     response.</p>
                *             </li>
                *          </ul>
                */
            ReturnConsumedCapacity?: ReturnConsumedCapacity | string;
            /**
                * <p>Determines whether item collection metrics are returned. If set to <code>SIZE</code>,
                *             the response includes statistics about item collections, if any, that were modified
                *             during the operation are returned in the response. If set to <code>NONE</code> (the
                *             default), no statistics are returned.</p>
                */
            ReturnItemCollectionMetrics?: ReturnItemCollectionMetrics | string;
            /**
                * <p>A condition that must be satisfied in order for a conditional <code>DeleteItem</code>
                *             to succeed.</p>
                *         <p>An expression can contain any of the following:</p>
                *         <ul>
                *             <li>
                *                 <p>Functions: <code>attribute_exists | attribute_not_exists | attribute_type |
                *                         contains | begins_with | size</code>
                *                 </p>
                *                 <p>These function names are case-sensitive.</p>
                *             </li>
                *             <li>
                *                 <p>Comparison operators: <code>= | <> |
                *             < | > | <= | >= |
                *             BETWEEN | IN </code>
                *                 </p>
                *             </li>
                *             <li>
                *                 <p> Logical operators: <code>AND | OR | NOT</code>
                *                 </p>
                *             </li>
                *          </ul>
                *         <p>For more information about condition expressions, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.SpecifyingConditions.html">Condition Expressions</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>.</p>
                */
            ConditionExpression?: string;
            /**
                * <p>One or more substitution tokens for attribute names in an expression. The following
                *             are some use cases for using <code>ExpressionAttributeNames</code>:</p>
                *         <ul>
                *             <li>
                *                 <p>To access an attribute whose name conflicts with a DynamoDB reserved
                *                     word.</p>
                *             </li>
                *             <li>
                *                 <p>To create a placeholder for repeating occurrences of an attribute name in an
                *                     expression.</p>
                *             </li>
                *             <li>
                *                 <p>To prevent special characters in an attribute name from being misinterpreted
                *                     in an expression.</p>
                *             </li>
                *          </ul>
                *         <p>Use the <b>#</b> character in an expression to dereference
                *             an attribute name. For example, consider the following attribute name:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>Percentile</code>
                *                 </p>
                *             </li>
                *          </ul>
                *         <p>The name of this attribute conflicts with a reserved word, so it cannot be used
                *             directly in an expression. (For the complete list of reserved words, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html">Reserved Words</a> in the <i>Amazon DynamoDB Developer
                *             Guide</i>). To work around this, you could specify the following for
                *                 <code>ExpressionAttributeNames</code>:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>{"#P":"Percentile"}</code>
                *                 </p>
                *             </li>
                *          </ul>
                *         <p>You could then use this substitution in an expression, as in this example:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>#P = :val</code>
                *                 </p>
                *             </li>
                *          </ul>
                *         <note>
                *             <p>Tokens that begin with the <b>:</b> character are
                *                     <i>expression attribute values</i>, which are placeholders for the
                *                 actual value at runtime.</p>
                *         </note>
                *         <p>For more information on expression attribute names, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html">Specifying Item Attributes</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>.</p>
                */
            ExpressionAttributeNames?: Record<string, string>;
            /**
                * <p>One or more values that can be substituted in an expression.</p>
                *         <p>Use the <b>:</b> (colon) character in an expression to
                *             dereference an attribute value. For example, suppose that you wanted to check whether
                *             the value of the <i>ProductStatus</i> attribute was one of the following: </p>
                *         <p>
                *             <code>Available | Backordered | Discontinued</code>
                *         </p>
                *         <p>You would first need to specify <code>ExpressionAttributeValues</code> as
                *             follows:</p>
                *         <p>
                *             <code>{ ":avail":{"S":"Available"}, ":back":{"S":"Backordered"},
                *                 ":disc":{"S":"Discontinued"} }</code>
                *         </p>
                *         <p>You could then use these values in an expression, such as this:</p>
                *         <p>
                *             <code>ProductStatus IN (:avail, :back, :disc)</code>
                *         </p>
                *         <p>For more information on expression attribute values, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.SpecifyingConditions.html">Condition Expressions</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>.</p>
                */
            ExpressionAttributeValues?: Record<string, AttributeValue>;
    }
    export namespace DeleteItemInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DeleteItemInput) => any;
    }
    /**
        * <p>Represents the input of a <code>PutItem</code> operation.</p>
        */
    export interface PutItemInput {
            /**
                * <p>The name of the table to contain the item.</p>
                */
            TableName: string | undefined;
            /**
                * <p>A map of attribute name/value pairs, one for each attribute. Only the primary key
                *             attributes are required; you can optionally provide other attribute name-value pairs for
                *             the item.</p>
                *         <p>You must provide all of the attributes for the primary key. For example, with a simple
                *             primary key, you only need to provide a value for the partition key. For a composite
                *             primary key, you must provide both values for both the partition key and the sort
                *             key.</p>
                *         <p>If you specify any attributes that are part of an index key, then the data types for
                *             those attributes must match those of the schema in the table's attribute
                *             definition.</p>
                *         <p>Empty String and Binary attribute values are allowed. Attribute values of type String
                *             and Binary must have a length greater than zero if the attribute is used as a key
                *             attribute for a table or index.</p>
                *
                *         <p>For more information about primary keys, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html#HowItWorks.CoreComponents.PrimaryKey">Primary Key</a> in the <i>Amazon DynamoDB Developer
                *             Guide</i>.</p>
                *         <p>Each element in the <code>Item</code> map is an <code>AttributeValue</code>
                *             object.</p>
                */
            Item: Record<string, AttributeValue> | undefined;
            /**
                * <p>This is a legacy parameter. Use <code>ConditionExpression</code> instead. For more
                *             information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.Expected.html">Expected</a> in the <i>Amazon DynamoDB Developer
                *             Guide</i>.</p>
                */
            Expected?: Record<string, ExpectedAttributeValue>;
            /**
                * <p>Use <code>ReturnValues</code> if you want to get the item attributes as they appeared
                *             before they were updated with the <code>PutItem</code> request. For
                *             <code>PutItem</code>, the valid values are:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>NONE</code> - If <code>ReturnValues</code> is not specified, or if its
                *                     value is <code>NONE</code>, then nothing is returned. (This setting is the
                *                     default for <code>ReturnValues</code>.)</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>ALL_OLD</code> - If <code>PutItem</code> overwrote an attribute name-value
                *                     pair, then the content of the old item is returned.</p>
                *             </li>
                *          </ul>
                *         <p>The values returned are strongly consistent.</p>
                *         <p>There is no additional cost associated with requesting a return value aside from the small
                *             network and processing overhead of receiving a larger response. No read capacity units are
                *             consumed.</p>
                *         <note>
                *             <p>The <code>ReturnValues</code> parameter is used by several DynamoDB operations;
                *                 however, <code>PutItem</code> does not recognize any values other than
                *                     <code>NONE</code> or <code>ALL_OLD</code>.</p>
                *         </note>
                */
            ReturnValues?: ReturnValue | string;
            /**
                * <p>Determines the level of detail about either provisioned or on-demand throughput
                *             consumption that is returned in the response:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>INDEXES</code> - The response includes the aggregate
                *                         <code>ConsumedCapacity</code> for the operation, together with
                *                         <code>ConsumedCapacity</code> for each table and secondary index that was
                *                     accessed.</p>
                *                 <p>Note that some operations, such as <code>GetItem</code> and
                *                         <code>BatchGetItem</code>, do not access any indexes at all. In these cases,
                *                     specifying <code>INDEXES</code> will only return <code>ConsumedCapacity</code>
                *                     information for table(s).</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>TOTAL</code> - The response includes only the aggregate
                *                         <code>ConsumedCapacity</code> for the operation.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>NONE</code> - No <code>ConsumedCapacity</code> details are included in the
                *                     response.</p>
                *             </li>
                *          </ul>
                */
            ReturnConsumedCapacity?: ReturnConsumedCapacity | string;
            /**
                * <p>Determines whether item collection metrics are returned. If set to <code>SIZE</code>,
                *             the response includes statistics about item collections, if any, that were modified
                *             during the operation are returned in the response. If set to <code>NONE</code> (the
                *             default), no statistics are returned.</p>
                */
            ReturnItemCollectionMetrics?: ReturnItemCollectionMetrics | string;
            /**
                * <p>This is a legacy parameter. Use <code>ConditionExpression</code> instead. For more
                *             information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.ConditionalOperator.html">ConditionalOperator</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>.</p>
                */
            ConditionalOperator?: ConditionalOperator | string;
            /**
                * <p>A condition that must be satisfied in order for a conditional <code>PutItem</code>
                *             operation to succeed.</p>
                *         <p>An expression can contain any of the following:</p>
                *         <ul>
                *             <li>
                *                 <p>Functions: <code>attribute_exists | attribute_not_exists | attribute_type |
                *                         contains | begins_with | size</code>
                *                 </p>
                *                 <p>These function names are case-sensitive.</p>
                *             </li>
                *             <li>
                *                 <p>Comparison operators: <code>= | <> |
                *             < | > | <= | >= |
                *             BETWEEN | IN </code>
                *                 </p>
                *             </li>
                *             <li>
                *                 <p> Logical operators: <code>AND | OR | NOT</code>
                *                 </p>
                *             </li>
                *          </ul>
                *         <p>For more information on condition expressions, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.SpecifyingConditions.html">Condition Expressions</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>.</p>
                */
            ConditionExpression?: string;
            /**
                * <p>One or more substitution tokens for attribute names in an expression. The following
                *             are some use cases for using <code>ExpressionAttributeNames</code>:</p>
                *         <ul>
                *             <li>
                *                 <p>To access an attribute whose name conflicts with a DynamoDB reserved
                *                     word.</p>
                *             </li>
                *             <li>
                *                 <p>To create a placeholder for repeating occurrences of an attribute name in an
                *                     expression.</p>
                *             </li>
                *             <li>
                *                 <p>To prevent special characters in an attribute name from being misinterpreted
                *                     in an expression.</p>
                *             </li>
                *          </ul>
                *         <p>Use the <b>#</b> character in an expression to dereference
                *             an attribute name. For example, consider the following attribute name:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>Percentile</code>
                *                 </p>
                *             </li>
                *          </ul>
                *         <p>The name of this attribute conflicts with a reserved word, so it cannot be used
                *             directly in an expression. (For the complete list of reserved words, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html">Reserved Words</a> in the <i>Amazon DynamoDB Developer
                *             Guide</i>). To work around this, you could specify the following for
                *                 <code>ExpressionAttributeNames</code>:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>{"#P":"Percentile"}</code>
                *                 </p>
                *             </li>
                *          </ul>
                *         <p>You could then use this substitution in an expression, as in this example:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>#P = :val</code>
                *                 </p>
                *             </li>
                *          </ul>
                *         <note>
                *             <p>Tokens that begin with the <b>:</b> character are
                *                     <i>expression attribute values</i>, which are placeholders for the
                *                 actual value at runtime.</p>
                *         </note>
                *         <p>For more information on expression attribute names, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html">Specifying Item Attributes</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>.</p>
                */
            ExpressionAttributeNames?: Record<string, string>;
            /**
                * <p>One or more values that can be substituted in an expression.</p>
                *         <p>Use the <b>:</b> (colon) character in an expression to
                *             dereference an attribute value. For example, suppose that you wanted to check whether
                *             the value of the <i>ProductStatus</i> attribute was one of the following: </p>
                *         <p>
                *             <code>Available | Backordered | Discontinued</code>
                *         </p>
                *         <p>You would first need to specify <code>ExpressionAttributeValues</code> as
                *             follows:</p>
                *         <p>
                *             <code>{ ":avail":{"S":"Available"}, ":back":{"S":"Backordered"},
                *                 ":disc":{"S":"Discontinued"} }</code>
                *         </p>
                *         <p>You could then use these values in an expression, such as this:</p>
                *         <p>
                *             <code>ProductStatus IN (:avail, :back, :disc)</code>
                *         </p>
                *         <p>For more information on expression attribute values, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.SpecifyingConditions.html">Condition Expressions</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>.</p>
                */
            ExpressionAttributeValues?: Record<string, AttributeValue>;
    }
    export namespace PutItemInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: PutItemInput) => any;
    }
    /**
        * <p>Represents the input of a <code>Query</code> operation.</p>
        */
    export interface QueryInput {
            /**
                * <p>The name of the table containing the requested items.</p>
                */
            TableName: string | undefined;
            /**
                * <p>The name of an index to query. This index can be any local secondary index or global
                *             secondary index on the table. Note that if you use the <code>IndexName</code> parameter,
                *             you must also provide <code>TableName.</code>
                *         </p>
                */
            IndexName?: string;
            /**
                * <p>The attributes to be returned in the result. You can retrieve all item attributes,
                *             specific item attributes, the count of matching items, or in the case of an index, some
                *             or all of the attributes projected into the index.</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>ALL_ATTRIBUTES</code> - Returns all of the item attributes from the
                *                     specified table or index. If you query a local secondary index, then for each
                *                     matching item in the index, DynamoDB fetches the entire item from the parent
                *                     table. If the index is configured to project all item attributes, then all of
                *                     the data can be obtained from the local secondary index, and no fetching is
                *                     required.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>ALL_PROJECTED_ATTRIBUTES</code> - Allowed only when querying an index.
                *                     Retrieves all attributes that have been projected into the index. If the index
                *                     is configured to project all attributes, this return value is equivalent to
                *                     specifying <code>ALL_ATTRIBUTES</code>.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>COUNT</code> - Returns the number of matching items, rather than the
                *                     matching items themselves.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>SPECIFIC_ATTRIBUTES</code> - Returns only the attributes listed in
                *                         <code>ProjectionExpression</code>. This return value is equivalent to
                *                     specifying <code>ProjectionExpression</code> without specifying any value for
                *                         <code>Select</code>.</p>
                *                 <p>If you query or scan a local secondary index and request only attributes that
                *                     are projected into that index, the operation will read only the index and not
                *                     the table. If any of the requested attributes are not projected into the local
                *                     secondary index, DynamoDB fetches each of these attributes from the parent
                *                     table. This extra fetching incurs additional throughput cost and latency.</p>
                *                 <p>If you query or scan a global secondary index, you can only request attributes
                *                     that are projected into the index. Global secondary index queries cannot fetch
                *                     attributes from the parent table.</p>
                *             </li>
                *          </ul>
                *         <p>If neither <code>Select</code> nor <code>ProjectionExpression</code> are specified,
                *             DynamoDB defaults to <code>ALL_ATTRIBUTES</code> when accessing a table, and
                *                 <code>ALL_PROJECTED_ATTRIBUTES</code> when accessing an index. You cannot use both
                *                 <code>Select</code> and <code>ProjectionExpression</code> together in a single
                *             request, unless the value for <code>Select</code> is <code>SPECIFIC_ATTRIBUTES</code>.
                *             (This usage is equivalent to specifying <code>ProjectionExpression</code> without any
                *             value for <code>Select</code>.)</p>
                *         <note>
                *             <p>If you use the <code>ProjectionExpression</code> parameter, then the value for
                *                     <code>Select</code> can only be <code>SPECIFIC_ATTRIBUTES</code>. Any other
                *                 value for <code>Select</code> will return an error.</p>
                *         </note>
                */
            Select?: Select | string;
            /**
                * <p>This is a legacy parameter. Use <code>ProjectionExpression</code> instead. For more
                *             information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.AttributesToGet.html">AttributesToGet</a> in the <i>Amazon DynamoDB Developer
                *             Guide</i>.</p>
                */
            AttributesToGet?: string[];
            /**
                * <p>The maximum number of items to evaluate (not necessarily the number of matching
                *             items). If DynamoDB processes the number of items up to the limit while processing the
                *             results, it stops the operation and returns the matching values up to that point, and a
                *             key in <code>LastEvaluatedKey</code> to apply in a subsequent operation, so that you can
                *             pick up where you left off. Also, if the processed dataset size exceeds 1 MB before
                *             DynamoDB reaches this limit, it stops the operation and returns the matching values up
                *             to the limit, and a key in <code>LastEvaluatedKey</code> to apply in a subsequent
                *             operation to continue the operation. For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/QueryAndScan.html">Query and Scan</a> in the <i>Amazon DynamoDB Developer
                *             Guide</i>.</p>
                */
            Limit?: number;
            /**
                * <p>Determines the read consistency model: If set to <code>true</code>, then the operation
                *             uses strongly consistent reads; otherwise, the operation uses eventually consistent
                *             reads.</p>
                *         <p>Strongly consistent reads are not supported on global secondary indexes. If you query
                *             a global secondary index with <code>ConsistentRead</code> set to <code>true</code>, you
                *             will receive a <code>ValidationException</code>.</p>
                */
            ConsistentRead?: boolean;
            /**
                * <p>This is a legacy parameter. Use <code>KeyConditionExpression</code> instead. For more
                *             information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.KeyConditions.html">KeyConditions</a> in the <i>Amazon DynamoDB Developer
                *             Guide</i>.</p>
                */
            KeyConditions?: Record<string, Condition>;
            /**
                * <p>This is a legacy parameter. Use <code>FilterExpression</code> instead. For more
                *             information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.QueryFilter.html">QueryFilter</a> in the <i>Amazon DynamoDB Developer
                *             Guide</i>.</p>
                */
            QueryFilter?: Record<string, Condition>;
            /**
                * <p>This is a legacy parameter. Use <code>FilterExpression</code> instead. For more
                *             information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.ConditionalOperator.html">ConditionalOperator</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>.</p>
                */
            ConditionalOperator?: ConditionalOperator | string;
            /**
                * <p>Specifies the order for index traversal: If <code>true</code> (default), the traversal
                *             is performed in ascending order; if <code>false</code>, the traversal is performed in
                *             descending order. </p>
                *         <p>Items with the same partition key value are stored in sorted order by sort key. If the
                *             sort key data type is Number, the results are stored in numeric order. For type String,
                *             the results are stored in order of UTF-8 bytes. For type Binary, DynamoDB treats each
                *             byte of the binary data as unsigned.</p>
                *         <p>If <code>ScanIndexForward</code> is <code>true</code>, DynamoDB returns the results in
                *             the order in which they are stored (by sort key value). This is the default behavior. If
                *                 <code>ScanIndexForward</code> is <code>false</code>, DynamoDB reads the results in
                *             reverse order by sort key value, and then returns the results to the client.</p>
                */
            ScanIndexForward?: boolean;
            /**
                * <p>The primary key of the first item that this operation will evaluate. Use the value
                *             that was returned for <code>LastEvaluatedKey</code> in the previous operation.</p>
                *         <p>The data type for <code>ExclusiveStartKey</code> must be String, Number, or Binary. No
                *             set data types are allowed.</p>
                */
            ExclusiveStartKey?: Record<string, AttributeValue>;
            /**
                * <p>Determines the level of detail about either provisioned or on-demand throughput
                *             consumption that is returned in the response:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>INDEXES</code> - The response includes the aggregate
                *                         <code>ConsumedCapacity</code> for the operation, together with
                *                         <code>ConsumedCapacity</code> for each table and secondary index that was
                *                     accessed.</p>
                *                 <p>Note that some operations, such as <code>GetItem</code> and
                *                         <code>BatchGetItem</code>, do not access any indexes at all. In these cases,
                *                     specifying <code>INDEXES</code> will only return <code>ConsumedCapacity</code>
                *                     information for table(s).</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>TOTAL</code> - The response includes only the aggregate
                *                         <code>ConsumedCapacity</code> for the operation.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>NONE</code> - No <code>ConsumedCapacity</code> details are included in the
                *                     response.</p>
                *             </li>
                *          </ul>
                */
            ReturnConsumedCapacity?: ReturnConsumedCapacity | string;
            /**
                * <p>A string that identifies one or more attributes to retrieve from the table. These
                *             attributes can include scalars, sets, or elements of a JSON document. The attributes in
                *             the expression must be separated by commas.</p>
                *         <p>If no attribute names are specified, then all attributes will be returned. If any of
                *             the requested attributes are not found, they will not appear in the result.</p>
                *         <p>For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html">Accessing Item Attributes</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>.</p>
                */
            ProjectionExpression?: string;
            /**
                * <p>A string that contains conditions that DynamoDB applies after the <code>Query</code>
                *             operation, but before the data is returned to you. Items that do not satisfy the
                *                 <code>FilterExpression</code> criteria are not returned.</p>
                *         <p>A <code>FilterExpression</code> does not allow key attributes. You cannot define a
                *             filter expression based on a partition key or a sort key.</p>
                *         <note>
                *             <p>A <code>FilterExpression</code> is applied after the items have already been read;
                *                 the process of filtering does not consume any additional read capacity units.</p>
                *         </note>
                *         <p>For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/QueryAndScan.html#Query.FilterExpression">Filter Expressions</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>.</p>
                */
            FilterExpression?: string;
            /**
                * <p>The condition that specifies the key values for items to be retrieved by the
                *                 <code>Query</code> action.</p>
                *
                *         <p>The condition must perform an equality test on a single partition key value.</p>
                *         <p>The condition can optionally perform one of several comparison tests on a single sort
                *             key value. This allows <code>Query</code> to retrieve one item with a given partition
                *             key value and sort key value, or several items that have the same partition key value
                *             but different sort key values.</p>
                *
                *         <p>The partition key equality test is required, and must be specified in the following
                *             format:</p>
                *
                *         <p>
                *             <code>partitionKeyName</code>
                *             <i>=</i>
                *             <code>:partitionkeyval</code>
                *         </p>
                *
                *         <p>If you also want to provide a condition for the sort key, it must be combined using
                *                 <code>AND</code> with the condition for the sort key. Following is an example, using
                *             the <b>=</b> comparison operator for the sort key:</p>
                *
                *         <p>
                *             <code>partitionKeyName</code>
                *             <code>=</code>
                *             <code>:partitionkeyval</code>
                *             <code>AND</code>
                *             <code>sortKeyName</code>
                *             <code>=</code>
                *             <code>:sortkeyval</code>
                *         </p>
                *         <p>Valid comparisons for the sort key condition are as follows:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>sortKeyName</code>
                *                     <code>=</code>
                *                     <code>:sortkeyval</code> - true if the sort key value is equal to
                *                         <code>:sortkeyval</code>.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>sortKeyName</code>
                *                     <code><</code>
                *                     <code>:sortkeyval</code> - true if the sort key value is less than
                *                         <code>:sortkeyval</code>.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>sortKeyName</code>
                *                     <code><=</code>
                *                     <code>:sortkeyval</code> - true if the sort key value is less than or equal to
                *                         <code>:sortkeyval</code>.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>sortKeyName</code>
                *                     <code>></code>
                *                     <code>:sortkeyval</code> - true if the sort key value is greater than
                *                         <code>:sortkeyval</code>.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>sortKeyName</code>
                *                     <code>>= </code>
                *                     <code>:sortkeyval</code> - true if the sort key value is greater than or equal
                *                     to <code>:sortkeyval</code>.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>sortKeyName</code>
                *                     <code>BETWEEN</code>
                *                     <code>:sortkeyval1</code>
                *                     <code>AND</code>
                *                     <code>:sortkeyval2</code> - true if the sort key value is greater than or equal
                *                     to <code>:sortkeyval1</code>, and less than or equal to
                *                         <code>:sortkeyval2</code>.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>begins_with (</code>
                *                     <code>sortKeyName</code>, <code>:sortkeyval</code>
                *                     <code>)</code> - true if the sort key value begins with a particular operand.
                *                     (You cannot use this function with a sort key that is of type Number.) Note that
                *                     the function name <code>begins_with</code> is case-sensitive.</p>
                *
                *             </li>
                *          </ul>
                *
                *         <p>Use the <code>ExpressionAttributeValues</code> parameter to replace tokens such as
                *                 <code>:partitionval</code> and <code>:sortval</code> with actual values at
                *             runtime.</p>
                *
                *         <p>You can optionally use the <code>ExpressionAttributeNames</code> parameter to replace
                *             the names of the partition key and sort key with placeholder tokens. This option might
                *             be necessary if an attribute name conflicts with a DynamoDB reserved word. For example,
                *             the following <code>KeyConditionExpression</code> parameter causes an error because
                *                 <i>Size</i> is a reserved word:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>Size = :myval</code>
                *                 </p>
                *             </li>
                *          </ul>
                *         <p>To work around this, define a placeholder (such a <code>#S</code>) to represent the
                *             attribute name <i>Size</i>. <code>KeyConditionExpression</code> then is as
                *             follows:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>#S = :myval</code>
                *                 </p>
                *             </li>
                *          </ul>
                *         <p>For a list of reserved words, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html">Reserved Words</a>
                *             in the <i>Amazon DynamoDB Developer Guide</i>.</p>
                *
                *         <p>For more information on <code>ExpressionAttributeNames</code> and
                *                 <code>ExpressionAttributeValues</code>, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ExpressionPlaceholders.html">Using
                *                 Placeholders for Attribute Names and Values</a> in the <i>Amazon DynamoDB
                *                 Developer Guide</i>.</p>
                */
            KeyConditionExpression?: string;
            /**
                * <p>One or more substitution tokens for attribute names in an expression. The following
                *             are some use cases for using <code>ExpressionAttributeNames</code>:</p>
                *         <ul>
                *             <li>
                *                 <p>To access an attribute whose name conflicts with a DynamoDB reserved
                *                     word.</p>
                *             </li>
                *             <li>
                *                 <p>To create a placeholder for repeating occurrences of an attribute name in an
                *                     expression.</p>
                *             </li>
                *             <li>
                *                 <p>To prevent special characters in an attribute name from being misinterpreted
                *                     in an expression.</p>
                *             </li>
                *          </ul>
                *         <p>Use the <b>#</b> character in an expression to dereference
                *             an attribute name. For example, consider the following attribute name:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>Percentile</code>
                *                 </p>
                *             </li>
                *          </ul>
                *         <p>The name of this attribute conflicts with a reserved word, so it cannot be used
                *             directly in an expression. (For the complete list of reserved words, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html">Reserved Words</a> in the <i>Amazon DynamoDB Developer
                *             Guide</i>). To work around this, you could specify the following for
                *                 <code>ExpressionAttributeNames</code>:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>{"#P":"Percentile"}</code>
                *                 </p>
                *             </li>
                *          </ul>
                *         <p>You could then use this substitution in an expression, as in this example:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>#P = :val</code>
                *                 </p>
                *             </li>
                *          </ul>
                *         <note>
                *             <p>Tokens that begin with the <b>:</b> character are
                *                     <i>expression attribute values</i>, which are placeholders for the
                *                 actual value at runtime.</p>
                *         </note>
                *         <p>For more information on expression attribute names, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html">Specifying Item Attributes</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>.</p>
                */
            ExpressionAttributeNames?: Record<string, string>;
            /**
                * <p>One or more values that can be substituted in an expression.</p>
                *         <p>Use the <b>:</b> (colon) character in an expression to
                *             dereference an attribute value. For example, suppose that you wanted to check whether
                *             the value of the <i>ProductStatus</i> attribute was one of the following: </p>
                *         <p>
                *             <code>Available | Backordered | Discontinued</code>
                *         </p>
                *         <p>You would first need to specify <code>ExpressionAttributeValues</code> as
                *             follows:</p>
                *         <p>
                *             <code>{ ":avail":{"S":"Available"}, ":back":{"S":"Backordered"},
                *                 ":disc":{"S":"Discontinued"} }</code>
                *         </p>
                *         <p>You could then use these values in an expression, such as this:</p>
                *         <p>
                *             <code>ProductStatus IN (:avail, :back, :disc)</code>
                *         </p>
                *         <p>For more information on expression attribute values, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.SpecifyingConditions.html">Specifying Conditions</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>.</p>
                */
            ExpressionAttributeValues?: Record<string, AttributeValue>;
    }
    export namespace QueryInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: QueryInput) => any;
    }
    /**
        * <p>Represents the output of a <code>BatchWriteItem</code> operation.</p>
        */
    export interface BatchWriteItemOutput {
            /**
                * <p>A map of tables and requests against those tables that were not processed. The
                *                 <code>UnprocessedItems</code> value is in the same form as
                *             <code>RequestItems</code>, so you can provide this value directly to a subsequent
                *                 <code>BatchGetItem</code> operation. For more information, see
                *                 <code>RequestItems</code> in the Request Parameters section.</p>
                *         <p>Each <code>UnprocessedItems</code> entry consists of a table name and, for that table,
                *             a list of operations to perform (<code>DeleteRequest</code> or
                *             <code>PutRequest</code>).</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>DeleteRequest</code> - Perform a <code>DeleteItem</code> operation on the
                *                     specified item. The item to be deleted is identified by a <code>Key</code>
                *                     subelement:</p>
                *                 <ul>
                *                   <li>
                *                         <p>
                *                             <code>Key</code> - A map of primary key attribute values that uniquely
                *                             identify the item. Each entry in this map consists of an attribute name
                *                             and an attribute value.</p>
                *                     </li>
                *                </ul>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>PutRequest</code> - Perform a <code>PutItem</code> operation on the
                *                     specified item. The item to be put is identified by an <code>Item</code>
                *                     subelement:</p>
                *                 <ul>
                *                   <li>
                *                         <p>
                *                             <code>Item</code> - A map of attributes and their values. Each entry in
                *                             this map consists of an attribute name and an attribute value. Attribute
                *                             values must not be null; string and binary type attributes must have
                *                             lengths greater than zero; and set type attributes must not be empty.
                *                             Requests that contain empty values will be rejected with a
                *                                 <code>ValidationException</code> exception.</p>
                *                         <p>If you specify any attributes that are part of an index key, then the
                *                             data types for those attributes must match those of the schema in the
                *                             table's attribute definition.</p>
                *                     </li>
                *                </ul>
                *             </li>
                *          </ul>
                *         <p>If there are no unprocessed items remaining, the response contains an empty
                *                 <code>UnprocessedItems</code> map.</p>
                */
            UnprocessedItems?: Record<string, WriteRequest[]>;
            /**
                * <p>A list of tables that were processed by <code>BatchWriteItem</code> and, for each
                *             table, information about any item collections that were affected by individual
                *                 <code>DeleteItem</code> or <code>PutItem</code> operations.</p>
                *         <p>Each entry consists of the following subelements:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>ItemCollectionKey</code> - The partition key value of the item collection.
                *                     This is the same as the partition key value of the item.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>SizeEstimateRangeGB</code> - An estimate of item collection size,
                *                     expressed in GB. This is a two-element array containing a lower bound and an
                *                     upper bound for the estimate. The estimate includes the size of all the items in
                *                     the table, plus the size of all attributes projected into all of the local
                *                     secondary indexes on the table. Use this estimate to measure whether a local
                *                     secondary index is approaching its size limit.</p>
                *                 <p>The estimate is subject to change over time; therefore, do not rely on the
                *                     precision or accuracy of the estimate.</p>
                *             </li>
                *          </ul>
                */
            ItemCollectionMetrics?: Record<string, ItemCollectionMetrics[]>;
            /**
                * <p>The capacity units consumed by the entire <code>BatchWriteItem</code>
                *             operation.</p>
                *         <p>Each element consists of:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>TableName</code> - The table that consumed the provisioned
                *                     throughput.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>CapacityUnits</code> - The total number of capacity units consumed.</p>
                *             </li>
                *          </ul>
                */
            ConsumedCapacity?: ConsumedCapacity[];
    }
    export namespace BatchWriteItemOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BatchWriteItemOutput) => any;
    }
    /**
        * <p>Represents the input of an <code>UpdateItem</code> operation.</p>
        */
    export interface UpdateItemInput {
            /**
                * <p>The name of the table containing the item to update.</p>
                */
            TableName: string | undefined;
            /**
                * <p>The primary key of the item to be updated. Each element consists of an attribute name
                *             and a value for that attribute.</p>
                *         <p>For the primary key, you must provide all of the attributes. For example, with a
                *             simple primary key, you only need to provide a value for the partition key. For a
                *             composite primary key, you must provide values for both the partition key and the sort
                *             key.</p>
                */
            Key: Record<string, AttributeValue> | undefined;
            /**
                * <p>This is a legacy parameter. Use <code>UpdateExpression</code> instead. For more
                *             information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.AttributeUpdates.html">AttributeUpdates</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>.</p>
                */
            AttributeUpdates?: Record<string, AttributeValueUpdate>;
            /**
                * <p>This is a legacy parameter. Use <code>ConditionExpression</code> instead. For more
                *             information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.Expected.html">Expected</a> in the <i>Amazon DynamoDB Developer
                *             Guide</i>.</p>
                */
            Expected?: Record<string, ExpectedAttributeValue>;
            /**
                * <p>This is a legacy parameter. Use <code>ConditionExpression</code> instead. For more
                *             information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.ConditionalOperator.html">ConditionalOperator</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>.</p>
                */
            ConditionalOperator?: ConditionalOperator | string;
            /**
                * <p>Use <code>ReturnValues</code> if you want to get the item attributes as they appear
                *             before or after they are updated. For <code>UpdateItem</code>, the valid values
                *             are:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>NONE</code> - If <code>ReturnValues</code> is not specified, or if its
                *                     value is <code>NONE</code>, then nothing is returned. (This setting is the
                *                     default for <code>ReturnValues</code>.)</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>ALL_OLD</code> - Returns all of the attributes of the item, as they
                *                     appeared before the UpdateItem operation.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>UPDATED_OLD</code> - Returns only the updated attributes, as they appeared
                *                     before the UpdateItem operation.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>ALL_NEW</code> - Returns all of the attributes of the item, as they appear
                *                     after the UpdateItem operation.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>UPDATED_NEW</code> - Returns only the updated attributes, as they appear
                *                     after the UpdateItem operation.</p>
                *             </li>
                *          </ul>
                *         <p>There is no additional cost associated with requesting a return value aside from the
                *             small network and processing overhead of receiving a larger response. No read capacity
                *             units are consumed.</p>
                *         <p>The values returned are strongly consistent.</p>
                */
            ReturnValues?: ReturnValue | string;
            /**
                * <p>Determines the level of detail about either provisioned or on-demand throughput
                *             consumption that is returned in the response:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>INDEXES</code> - The response includes the aggregate
                *                         <code>ConsumedCapacity</code> for the operation, together with
                *                         <code>ConsumedCapacity</code> for each table and secondary index that was
                *                     accessed.</p>
                *                 <p>Note that some operations, such as <code>GetItem</code> and
                *                         <code>BatchGetItem</code>, do not access any indexes at all. In these cases,
                *                     specifying <code>INDEXES</code> will only return <code>ConsumedCapacity</code>
                *                     information for table(s).</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>TOTAL</code> - The response includes only the aggregate
                *                         <code>ConsumedCapacity</code> for the operation.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>NONE</code> - No <code>ConsumedCapacity</code> details are included in the
                *                     response.</p>
                *             </li>
                *          </ul>
                */
            ReturnConsumedCapacity?: ReturnConsumedCapacity | string;
            /**
                * <p>Determines whether item collection metrics are returned. If set to <code>SIZE</code>,
                *             the response includes statistics about item collections, if any, that were modified
                *             during the operation are returned in the response. If set to <code>NONE</code> (the
                *             default), no statistics are returned.</p>
                */
            ReturnItemCollectionMetrics?: ReturnItemCollectionMetrics | string;
            /**
                * <p>An expression that defines one or more attributes to be updated, the action to be
                *             performed on them, and new values for them.</p>
                *         <p>The following action values are available for <code>UpdateExpression</code>.</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>SET</code> - Adds one or more attributes and values to an item. If any of
                *                     these attributes already exist, they are replaced by the new values. You can
                *                     also use <code>SET</code> to add or subtract from an attribute that is of type
                *                     Number. For example: <code>SET myNum = myNum + :val</code>
                *                 </p>
                *                 <p>
                *                     <code>SET</code> supports the following functions:</p>
                *                 <ul>
                *                   <li>
                *                         <p>
                *                             <code>if_not_exists (path, operand)</code> - if the item does not
                *                             contain an attribute at the specified path, then
                *                                 <code>if_not_exists</code> evaluates to operand; otherwise, it
                *                             evaluates to path. You can use this function to avoid overwriting an
                *                             attribute that may already be present in the item.</p>
                *                     </li>
                *                   <li>
                *                         <p>
                *                             <code>list_append (operand, operand)</code> - evaluates to a list with a
                *                             new element added to it. You can append the new element to the start or
                *                             the end of the list by reversing the order of the operands.</p>
                *                     </li>
                *                </ul>
                *                 <p>These function names are case-sensitive.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>REMOVE</code> - Removes one or more attributes from an item.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>ADD</code> - Adds the specified value to the item, if the attribute does
                *                     not already exist. If the attribute does exist, then the behavior of
                *                         <code>ADD</code> depends on the data type of the attribute:</p>
                *                 <ul>
                *                   <li>
                *                         <p>If the existing attribute is a number, and if <code>Value</code> is
                *                             also a number, then <code>Value</code> is mathematically added to the
                *                             existing attribute. If <code>Value</code> is a negative number, then it
                *                             is subtracted from the existing attribute.</p>
                *                         <note>
                *                             <p>If you use <code>ADD</code> to increment or decrement a number
                *                                 value for an item that doesn't exist before the update, DynamoDB
                *                                 uses <code>0</code> as the initial value.</p>
                *                             <p>Similarly, if you use <code>ADD</code> for an existing item to
                *                                 increment or decrement an attribute value that doesn't exist before
                *                                 the update, DynamoDB uses <code>0</code> as the initial value. For
                *                                 example, suppose that the item you want to update doesn't have an
                *                                 attribute named <code>itemcount</code>, but you decide to
                *                                     <code>ADD</code> the number <code>3</code> to this attribute
                *                                 anyway. DynamoDB will create the <code>itemcount</code> attribute,
                *                                 set its initial value to <code>0</code>, and finally add
                *                                     <code>3</code> to it. The result will be a new
                *                                     <code>itemcount</code> attribute in the item, with a value of
                *                                     <code>3</code>.</p>
                *                         </note>
                *                     </li>
                *                   <li>
                *                         <p>If the existing data type is a set and if <code>Value</code> is also a
                *                             set, then <code>Value</code> is added to the existing set. For example,
                *                             if the attribute value is the set <code>[1,2]</code>, and the
                *                                 <code>ADD</code> action specified <code>[3]</code>, then the final
                *                             attribute value is <code>[1,2,3]</code>. An error occurs if an
                *                                 <code>ADD</code> action is specified for a set attribute and the
                *                             attribute type specified does not match the existing set type. </p>
                *                         <p>Both sets must have the same primitive data type. For example, if the
                *                             existing data type is a set of strings, the <code>Value</code> must also
                *                             be a set of strings.</p>
                *                     </li>
                *                </ul>
                *                 <important>
                *                     <p>The <code>ADD</code> action only supports Number and set data types. In
                *                         addition, <code>ADD</code> can only be used on top-level attributes, not
                *                         nested attributes.</p>
                *                 </important>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>DELETE</code> - Deletes an element from a set.</p>
                *                 <p>If a set of values is specified, then those values are subtracted from the old
                *                     set. For example, if the attribute value was the set <code>[a,b,c]</code> and
                *                     the <code>DELETE</code> action specifies <code>[a,c]</code>, then the final
                *                     attribute value is <code>[b]</code>. Specifying an empty set is an error.</p>
                *                 <important>
                *                     <p>The <code>DELETE</code> action only supports set data types. In addition,
                *                             <code>DELETE</code> can only be used on top-level attributes, not nested
                *                         attributes.</p>
                *                 </important>
                *
                *             </li>
                *          </ul>
                *         <p>You can have many actions in a single expression, such as the following: <code>SET
                *                 a=:value1, b=:value2 DELETE :value3, :value4, :value5</code>
                *         </p>
                *         <p>For more information on update expressions, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.Modifying.html">Modifying
                *                 Items and Attributes</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>.</p>
                */
            UpdateExpression?: string;
            /**
                * <p>A condition that must be satisfied in order for a conditional update to
                *             succeed.</p>
                *         <p>An expression can contain any of the following:</p>
                *         <ul>
                *             <li>
                *                 <p>Functions: <code>attribute_exists | attribute_not_exists | attribute_type |
                *                         contains | begins_with | size</code>
                *                 </p>
                *                 <p>These function names are case-sensitive.</p>
                *             </li>
                *             <li>
                *                 <p>Comparison operators: <code>= | <> |
                *             < | > | <= | >= |
                *             BETWEEN | IN </code>
                *                 </p>
                *             </li>
                *             <li>
                *                 <p> Logical operators: <code>AND | OR | NOT</code>
                *                 </p>
                *             </li>
                *          </ul>
                *         <p>For more information about condition expressions, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.SpecifyingConditions.html">Specifying Conditions</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>.</p>
                */
            ConditionExpression?: string;
            /**
                * <p>One or more substitution tokens for attribute names in an expression. The following
                *             are some use cases for using <code>ExpressionAttributeNames</code>:</p>
                *         <ul>
                *             <li>
                *                 <p>To access an attribute whose name conflicts with a DynamoDB reserved
                *                     word.</p>
                *             </li>
                *             <li>
                *                 <p>To create a placeholder for repeating occurrences of an attribute name in an
                *                     expression.</p>
                *             </li>
                *             <li>
                *                 <p>To prevent special characters in an attribute name from being misinterpreted
                *                     in an expression.</p>
                *             </li>
                *          </ul>
                *         <p>Use the <b>#</b> character in an expression to dereference
                *             an attribute name. For example, consider the following attribute name:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>Percentile</code>
                *                 </p>
                *             </li>
                *          </ul>
                *         <p>The name of this attribute conflicts with a reserved word, so it cannot be used
                *             directly in an expression. (For the complete list of reserved words, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html">Reserved Words</a> in the <i>Amazon DynamoDB Developer
                *             Guide</i>.) To work around this, you could specify the following for
                *                 <code>ExpressionAttributeNames</code>:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>{"#P":"Percentile"}</code>
                *                 </p>
                *             </li>
                *          </ul>
                *         <p>You could then use this substitution in an expression, as in this example:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>#P = :val</code>
                *                 </p>
                *             </li>
                *          </ul>
                *         <note>
                *             <p>Tokens that begin with the <b>:</b> character are
                *                     <i>expression attribute values</i>, which are placeholders for the
                *                 actual value at runtime.</p>
                *         </note>
                *         <p>For more information about expression attribute names, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html">Specifying Item Attributes</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>.</p>
                */
            ExpressionAttributeNames?: Record<string, string>;
            /**
                * <p>One or more values that can be substituted in an expression.</p>
                *         <p>Use the <b>:</b> (colon) character in an expression to
                *             dereference an attribute value. For example, suppose that you wanted to check whether
                *             the value of the <code>ProductStatus</code> attribute was one of the following: </p>
                *         <p>
                *             <code>Available | Backordered | Discontinued</code>
                *         </p>
                *         <p>You would first need to specify <code>ExpressionAttributeValues</code> as
                *             follows:</p>
                *         <p>
                *             <code>{ ":avail":{"S":"Available"}, ":back":{"S":"Backordered"},
                *                 ":disc":{"S":"Discontinued"} }</code>
                *         </p>
                *         <p>You could then use these values in an expression, such as this:</p>
                *         <p>
                *             <code>ProductStatus IN (:avail, :back, :disc)</code>
                *         </p>
                *         <p>For more information on expression attribute values, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.SpecifyingConditions.html">Condition Expressions</a> in the <i>Amazon DynamoDB Developer
                *                 Guide</i>.</p>
                */
            ExpressionAttributeValues?: Record<string, AttributeValue>;
    }
    export namespace UpdateItemInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: UpdateItemInput) => any;
    }
    /**
        * <p>A list of requests that can perform update, put, delete, or check operations on
        *             multiple items in one or more tables atomically.</p>
        */
    export interface TransactWriteItem {
            /**
                * <p>A request to perform a check item operation.</p>
                */
            ConditionCheck?: ConditionCheck;
            /**
                * <p>A request to perform a <code>PutItem</code> operation.</p>
                */
            Put?: Put;
            /**
                * <p>A request to perform a <code>DeleteItem</code> operation.</p>
                */
            Delete?: Delete;
            /**
                * <p>A request to perform an <code>UpdateItem</code> operation.</p>
                */
            Update?: Update;
    }
    export namespace TransactWriteItem {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TransactWriteItem) => any;
    }
    export interface TransactWriteItemsInput {
            /**
                * <p>An ordered array of up to 25 <code>TransactWriteItem</code> objects, each of which
                *             contains a <code>ConditionCheck</code>, <code>Put</code>, <code>Update</code>, or
                *                 <code>Delete</code> object. These can operate on items in different tables, but the
                *             tables must reside in the same Amazon Web Services account and Region, and no two of them
                *             can operate on the same item. </p>
                */
            TransactItems: TransactWriteItem[] | undefined;
            /**
                * <p>Determines the level of detail about either provisioned or on-demand throughput
                *             consumption that is returned in the response:</p>
                *         <ul>
                *             <li>
                *                 <p>
                *                     <code>INDEXES</code> - The response includes the aggregate
                *                         <code>ConsumedCapacity</code> for the operation, together with
                *                         <code>ConsumedCapacity</code> for each table and secondary index that was
                *                     accessed.</p>
                *                 <p>Note that some operations, such as <code>GetItem</code> and
                *                         <code>BatchGetItem</code>, do not access any indexes at all. In these cases,
                *                     specifying <code>INDEXES</code> will only return <code>ConsumedCapacity</code>
                *                     information for table(s).</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>TOTAL</code> - The response includes only the aggregate
                *                         <code>ConsumedCapacity</code> for the operation.</p>
                *             </li>
                *             <li>
                *                 <p>
                *                     <code>NONE</code> - No <code>ConsumedCapacity</code> details are included in the
                *                     response.</p>
                *             </li>
                *          </ul>
                */
            ReturnConsumedCapacity?: ReturnConsumedCapacity | string;
            /**
                * <p>Determines whether item collection metrics are returned. If set to <code>SIZE</code>,
                *             the response includes statistics about item collections (if any), that were modified
                *             during the operation and are returned in the response. If set to <code>NONE</code> (the
                *             default), no statistics are returned. </p>
                */
            ReturnItemCollectionMetrics?: ReturnItemCollectionMetrics | string;
            /**
                * <p>Providing a <code>ClientRequestToken</code> makes the call to
                *                 <code>TransactWriteItems</code> idempotent, meaning that multiple identical calls
                *             have the same effect as one single call.</p>
                *         <p>Although multiple identical calls using the same client request token produce the same
                *             result on the server (no side effects), the responses to the calls might not be the
                *             same. If the <code>ReturnConsumedCapacity></code> parameter is set, then the initial
                *                 <code>TransactWriteItems</code> call returns the amount of write capacity units
                *             consumed in making the changes. Subsequent <code>TransactWriteItems</code> calls with
                *             the same client token return the number of read capacity units consumed in reading the
                *             item.</p>
                *         <p>A client request token is valid for 10 minutes after the first request that uses it is
                *             completed. After 10 minutes, any request with the same client token is treated as a new
                *             request. Do not resubmit the same request with the same client token for more than 10
                *             minutes, or the result might not be idempotent.</p>
                *         <p>If you submit a request with the same client token but a change in other parameters
                *             within the 10-minute idempotency window, DynamoDB returns an
                *                 <code>IdempotentParameterMismatch</code> exception.</p>
                */
            ClientRequestToken?: string;
    }
    export namespace TransactWriteItemsInput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: TransactWriteItemsInput) => any;
    }
}

declare module '@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-dynamodb/dist-types/models/DynamoDBServiceException' {
    import { ServiceException as __ServiceException, ServiceExceptionOptions as __ServiceExceptionOptions } from "@aws-sdk/smithy-client";
    /**
        * Base exception class for all service exceptions from DynamoDB service.
        */
    export class DynamoDBServiceException extends __ServiceException {
            /**
                * @internal
                */
            constructor(options: __ServiceExceptionOptions);
    }
}

