// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   @aws-sdk/types
//   @aws-sdk/smithy-client
//   @aws-sdk/config-resolver
//   @aws-sdk/middleware-host-header
//   @aws-sdk/middleware-retry
//   @aws-sdk/middleware-signing
//   @aws-sdk/middleware-user-agent
//   @aws-sdk/protocol-http

declare module '@aws-sdk/client-textract' {
    import { HttpHandlerOptions as __HttpHandlerOptions } from "@aws-sdk/types";
    import { AnalyzeDocumentCommandInput, AnalyzeDocumentCommandOutput } from "@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/commands/AnalyzeDocumentCommand";
    import { AnalyzeExpenseCommandInput, AnalyzeExpenseCommandOutput } from "@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/commands/AnalyzeExpenseCommand";
    import { AnalyzeIDCommandInput, AnalyzeIDCommandOutput } from "@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/commands/AnalyzeIDCommand";
    import { DetectDocumentTextCommandInput, DetectDocumentTextCommandOutput } from "@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/commands/DetectDocumentTextCommand";
    import { GetDocumentAnalysisCommandInput, GetDocumentAnalysisCommandOutput } from "@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/commands/GetDocumentAnalysisCommand";
    import { GetDocumentTextDetectionCommandInput, GetDocumentTextDetectionCommandOutput } from "@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/commands/GetDocumentTextDetectionCommand";
    import { GetExpenseAnalysisCommandInput, GetExpenseAnalysisCommandOutput } from "@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/commands/GetExpenseAnalysisCommand";
    import { StartDocumentAnalysisCommandInput, StartDocumentAnalysisCommandOutput } from "@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/commands/StartDocumentAnalysisCommand";
    import { StartDocumentTextDetectionCommandInput, StartDocumentTextDetectionCommandOutput } from "@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/commands/StartDocumentTextDetectionCommand";
    import { StartExpenseAnalysisCommandInput, StartExpenseAnalysisCommandOutput } from "@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/commands/StartExpenseAnalysisCommand";
    import { TextractClient } from "@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/TextractClient";
    /**
        * <p>Amazon Textract detects and analyzes text in documents and converts it
        *          into machine-readable text. This is the API reference documentation for
        *          Amazon Textract.</p>
        */
    export class Textract extends TextractClient {
            /**
                * <p>Analyzes an input document for relationships between detected items.  </p>
                *          <p>The types of information returned are as follows: </p>
                *          <ul>
                *             <li>
                *                <p>Form data (key-value pairs). The related information is returned in two <a>Block</a> objects, each of type <code>KEY_VALUE_SET</code>: a KEY
                *                   <code>Block</code> object and a VALUE <code>Block</code> object. For example,
                *                   <i>Name: Ana Silva Carolina</i> contains a key and value.
                *                   <i>Name:</i> is the key. <i>Ana Silva Carolina</i> is
                *                the value.</p>
                *             </li>
                *             <li>
                *                <p>Table and table cell data. A TABLE <code>Block</code> object contains information about a detected table. A CELL
                *                <code>Block</code> object is returned for each cell in a table.</p>
                *             </li>
                *             <li>
                *                <p>Lines and words of text. A LINE <code>Block</code> object contains one or more WORD <code>Block</code> objects.
                *         All lines and words that are detected in the document are returned (including text that doesn't have a
                *                relationship with the value of <code>FeatureTypes</code>). </p>
                *             </li>
                *             <li>
                *                <p>Queries.A QUERIES_RESULT Block object contains the answer to the query, the alias associated and an ID that
                *             connect it to the query asked. This Block also contains a location and attached confidence score.</p>
                *             </li>
                *          </ul>
                *
                *          <p>Selection elements such as check boxes and option buttons (radio buttons) can be detected in form data and in tables.
                *          A SELECTION_ELEMENT <code>Block</code> object contains information about a selection element,
                *          including the selection status.</p>
                *
                *          <p>You can choose which type of analysis to perform by specifying the <code>FeatureTypes</code> list.
                *       </p>
                *          <p>The output is returned in a list of <code>Block</code> objects.</p>
                *          <p>
                *             <code>AnalyzeDocument</code> is a synchronous operation. To analyze documents
                *       asynchronously, use <a>StartDocumentAnalysis</a>.</p>
                *          <p>For more information, see <a href="https://docs.aws.amazon.com/textract/latest/dg/how-it-works-analyzing.html">Document Text Analysis</a>.</p>
                */
            analyzeDocument(args: AnalyzeDocumentCommandInput, options?: __HttpHandlerOptions): Promise<AnalyzeDocumentCommandOutput>;
            analyzeDocument(args: AnalyzeDocumentCommandInput, cb: (err: any, data?: AnalyzeDocumentCommandOutput) => void): void;
            analyzeDocument(args: AnalyzeDocumentCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: AnalyzeDocumentCommandOutput) => void): void;
            /**
                * <p>
                *             <code>AnalyzeExpense</code> synchronously analyzes an input document for financially related relationships between text.</p>
                *          <p>Information is returned as <code>ExpenseDocuments</code> and seperated as follows.</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <code>LineItemGroups</code>- A data set containing <code>LineItems</code> which
                *          store information about the lines of text, such as an item purchased and its price on a receipt.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <code>SummaryFields</code>- Contains all other information a receipt, such as header information
                *          or the vendors name.</p>
                *             </li>
                *          </ul>
                */
            analyzeExpense(args: AnalyzeExpenseCommandInput, options?: __HttpHandlerOptions): Promise<AnalyzeExpenseCommandOutput>;
            analyzeExpense(args: AnalyzeExpenseCommandInput, cb: (err: any, data?: AnalyzeExpenseCommandOutput) => void): void;
            analyzeExpense(args: AnalyzeExpenseCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: AnalyzeExpenseCommandOutput) => void): void;
            /**
                * <p>Analyzes identity documents for relevant information. This information is extracted
                *          and returned as <code>IdentityDocumentFields</code>, which records both the normalized
                *          field and value of the extracted text.Unlike other Amazon Textract operations, <code>AnalyzeID</code>
                *       doesn't return any Geometry data.</p>
                */
            analyzeID(args: AnalyzeIDCommandInput, options?: __HttpHandlerOptions): Promise<AnalyzeIDCommandOutput>;
            analyzeID(args: AnalyzeIDCommandInput, cb: (err: any, data?: AnalyzeIDCommandOutput) => void): void;
            analyzeID(args: AnalyzeIDCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: AnalyzeIDCommandOutput) => void): void;
            /**
                * <p>Detects text in the input document. Amazon Textract can detect lines of text and the
                *          words that make up a line of text. The input document must be an image in JPEG, PNG, PDF, or TIFF
                *          format. <code>DetectDocumentText</code> returns the detected text in an array of <a>Block</a> objects. </p>
                *          <p>Each document page has as an associated <code>Block</code> of type PAGE. Each PAGE <code>Block</code> object
                *          is the parent of LINE <code>Block</code> objects that represent the lines of detected text on a page. A LINE <code>Block</code> object is
                *          a parent for each word that makes up the line. Words are represented by <code>Block</code> objects of type WORD.</p>
                *
                *          <p>
                *             <code>DetectDocumentText</code> is a synchronous operation. To analyze documents
                *          asynchronously, use <a>StartDocumentTextDetection</a>.</p>
                *          <p>For more information, see <a href="https://docs.aws.amazon.com/textract/latest/dg/how-it-works-detecting.html">Document Text Detection</a>.</p>
                */
            detectDocumentText(args: DetectDocumentTextCommandInput, options?: __HttpHandlerOptions): Promise<DetectDocumentTextCommandOutput>;
            detectDocumentText(args: DetectDocumentTextCommandInput, cb: (err: any, data?: DetectDocumentTextCommandOutput) => void): void;
            detectDocumentText(args: DetectDocumentTextCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DetectDocumentTextCommandOutput) => void): void;
            /**
                * <p>Gets the results for an Amazon Textract asynchronous operation that analyzes text in a document.</p>
                *          <p>You start asynchronous text analysis by calling <a>StartDocumentAnalysis</a>, which returns a job identifier
                *             (<code>JobId</code>). When the text analysis operation finishes, Amazon Textract publishes a
                *          completion status to the Amazon Simple Notification Service (Amazon SNS) topic that's registered in the initial call to
                *             <code>StartDocumentAnalysis</code>. To get the results of the text-detection operation,
                *          first check that the status value published to the Amazon SNS topic is <code>SUCCEEDED</code>.
                *          If so, call <code>GetDocumentAnalysis</code>, and pass the job identifier
                *             (<code>JobId</code>) from the initial call to <code>StartDocumentAnalysis</code>.</p>
                *          <p>
                *             <code>GetDocumentAnalysis</code> returns an array of <a>Block</a> objects. The following
                *          types of information are returned: </p>
                *          <ul>
                *             <li>
                *                <p>Form data (key-value pairs). The related information is returned in two <a>Block</a> objects, each of type <code>KEY_VALUE_SET</code>: a KEY
                *             <code>Block</code> object and a VALUE <code>Block</code> object. For example,
                *             <i>Name: Ana Silva Carolina</i> contains a key and value.
                *             <i>Name:</i> is the key. <i>Ana Silva Carolina</i> is
                *             the value.</p>
                *             </li>
                *             <li>
                *                <p>Table and table cell data. A TABLE <code>Block</code> object contains information about a detected table. A CELL
                *             <code>Block</code> object is returned for each cell in a table.</p>
                *             </li>
                *             <li>
                *                <p>Lines and words of text. A LINE <code>Block</code> object contains one or more WORD <code>Block</code> objects.
                *             All lines and words that are detected in the document are returned (including text that doesn't have a
                *             relationship with the value of the <code>StartDocumentAnalysis</code>
                *                   <code>FeatureTypes</code> input parameter). </p>
                *             </li>
                *             <li>
                *                <p>Queries. A QUERIES_RESULT Block object contains the answer to the query, the alias associated and an ID that
                *             connect it to the query asked. This Block also contains a location and attached confidence score</p>
                *             </li>
                *          </ul>
                *
                *          <p>Selection elements such as check boxes and option buttons (radio buttons) can be detected in form data and in tables.
                *          A SELECTION_ELEMENT <code>Block</code> object contains information about a selection element,
                *          including the selection status.</p>
                *
                *
                *          <p>Use the <code>MaxResults</code> parameter to limit the number of blocks that are
                *          returned. If there are more results than specified in <code>MaxResults</code>, the value of
                *             <code>NextToken</code> in the operation response contains a pagination token for getting
                *          the next set of results. To get the next page of results, call
                *             <code>GetDocumentAnalysis</code>, and populate the <code>NextToken</code> request
                *          parameter with the token value that's returned from the previous call to
                *             <code>GetDocumentAnalysis</code>.</p>
                *          <p>For more information, see <a href="https://docs.aws.amazon.com/textract/latest/dg/how-it-works-analyzing.html">Document Text Analysis</a>.</p>
                */
            getDocumentAnalysis(args: GetDocumentAnalysisCommandInput, options?: __HttpHandlerOptions): Promise<GetDocumentAnalysisCommandOutput>;
            getDocumentAnalysis(args: GetDocumentAnalysisCommandInput, cb: (err: any, data?: GetDocumentAnalysisCommandOutput) => void): void;
            getDocumentAnalysis(args: GetDocumentAnalysisCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetDocumentAnalysisCommandOutput) => void): void;
            /**
                * <p>Gets the results for an Amazon Textract asynchronous operation that detects text in a document.
                *      Amazon Textract can detect lines of text and the words that make up a line of text.</p>
                *          <p>You start asynchronous text detection by calling <a>StartDocumentTextDetection</a>, which returns a job identifier
                *             (<code>JobId</code>). When the text detection operation finishes, Amazon Textract publishes a
                *          completion status to the Amazon Simple Notification Service (Amazon SNS) topic that's registered in the initial call to
                *             <code>StartDocumentTextDetection</code>. To get the results of the text-detection
                *          operation, first check that the status value published to the Amazon SNS topic is
                *             <code>SUCCEEDED</code>. If so, call <code>GetDocumentTextDetection</code>, and pass the
                *          job identifier (<code>JobId</code>) from the initial call to
                *             <code>StartDocumentTextDetection</code>.</p>
                *          <p>
                *             <code>GetDocumentTextDetection</code> returns an array of <a>Block</a>
                *          objects. </p>
                *          <p>Each document page has as an associated <code>Block</code> of type PAGE. Each PAGE <code>Block</code> object
                *         is the parent of LINE <code>Block</code> objects that represent the lines of detected text on a page. A LINE <code>Block</code> object is
                *         a parent for each word that makes up the line. Words are represented by <code>Block</code> objects of type WORD.</p>
                *
                *          <p>Use the MaxResults parameter to limit the number of blocks that are returned. If there
                *          are more results than specified in <code>MaxResults</code>, the value of
                *             <code>NextToken</code> in the operation response contains a pagination token for getting
                *          the next set of results. To get the next page of results, call
                *             <code>GetDocumentTextDetection</code>, and populate the <code>NextToken</code> request
                *          parameter with the token value that's returned from the previous call to
                *             <code>GetDocumentTextDetection</code>.</p>
                *          <p>For more information, see <a href="https://docs.aws.amazon.com/textract/latest/dg/how-it-works-detecting.html">Document Text Detection</a>.</p>
                */
            getDocumentTextDetection(args: GetDocumentTextDetectionCommandInput, options?: __HttpHandlerOptions): Promise<GetDocumentTextDetectionCommandOutput>;
            getDocumentTextDetection(args: GetDocumentTextDetectionCommandInput, cb: (err: any, data?: GetDocumentTextDetectionCommandOutput) => void): void;
            getDocumentTextDetection(args: GetDocumentTextDetectionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetDocumentTextDetectionCommandOutput) => void): void;
            /**
                * <p>Gets the results for an Amazon Textract asynchronous operation that analyzes invoices and
                *    receipts. Amazon Textract finds contact information, items purchased, and vendor name, from input
                *    invoices and receipts.</p>
                *          <p>You start asynchronous invoice/receipt analysis by calling <a>StartExpenseAnalysis</a>, which returns a job identifier (<code>JobId</code>). Upon
                *    completion of the invoice/receipt analysis, Amazon Textract publishes the completion status to the
                *    Amazon Simple Notification Service (Amazon SNS) topic. This topic must be registered in the initial call to
                *     <code>StartExpenseAnalysis</code>. To get the results of the invoice/receipt analysis operation,
                *    first ensure that the status value published to the Amazon SNS topic is <code>SUCCEEDED</code>. If so,
                *    call <code>GetExpenseAnalysis</code>, and pass the job identifier (<code>JobId</code>) from the
                *    initial call to <code>StartExpenseAnalysis</code>.</p>
                *          <p>Use the MaxResults parameter to limit the number of blocks that are returned. If there are
                *    more results than specified in <code>MaxResults</code>, the value of <code>NextToken</code> in
                *    the operation response contains a pagination token for getting the next set of results. To get
                *    the next page of results, call <code>GetExpenseAnalysis</code>, and populate the
                *     <code>NextToken</code> request parameter with the token value that's returned from the previous
                *    call to <code>GetExpenseAnalysis</code>.</p>
                *          <p>For more information, see <a href="https://docs.aws.amazon.com/textract/latest/dg/invoices-receipts.html">Analyzing Invoices and Receipts</a>.</p>
                */
            getExpenseAnalysis(args: GetExpenseAnalysisCommandInput, options?: __HttpHandlerOptions): Promise<GetExpenseAnalysisCommandOutput>;
            getExpenseAnalysis(args: GetExpenseAnalysisCommandInput, cb: (err: any, data?: GetExpenseAnalysisCommandOutput) => void): void;
            getExpenseAnalysis(args: GetExpenseAnalysisCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetExpenseAnalysisCommandOutput) => void): void;
            /**
                * <p>Starts the asynchronous analysis of an input document for relationships between detected
                *          items such as key-value pairs, tables, and selection elements.</p>
                *
                *          <p>
                *             <code>StartDocumentAnalysis</code> can analyze text in documents that are in JPEG, PNG, TIFF, and PDF format. The
                *          documents are stored in an Amazon S3 bucket. Use <a>DocumentLocation</a> to specify the bucket name and file name
                *          of the document.
                *          </p>
                *          <p>
                *             <code>StartDocumentAnalysis</code> returns a job identifier
                *             (<code>JobId</code>) that you use to get the results of the operation. When text
                *          analysis is finished, Amazon Textract publishes a completion status to the Amazon Simple Notification Service (Amazon SNS)
                *          topic that you specify in <code>NotificationChannel</code>. To get the results of the text
                *          analysis operation, first check that the status value published to the Amazon SNS topic is
                *             <code>SUCCEEDED</code>. If so, call <a>GetDocumentAnalysis</a>, and pass
                *          the job identifier (<code>JobId</code>) from the initial call to
                *             <code>StartDocumentAnalysis</code>.</p>
                *          <p>For more information, see <a href="https://docs.aws.amazon.com/textract/latest/dg/how-it-works-analyzing.html">Document Text Analysis</a>.</p>
                */
            startDocumentAnalysis(args: StartDocumentAnalysisCommandInput, options?: __HttpHandlerOptions): Promise<StartDocumentAnalysisCommandOutput>;
            startDocumentAnalysis(args: StartDocumentAnalysisCommandInput, cb: (err: any, data?: StartDocumentAnalysisCommandOutput) => void): void;
            startDocumentAnalysis(args: StartDocumentAnalysisCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: StartDocumentAnalysisCommandOutput) => void): void;
            /**
                * <p>Starts the asynchronous detection of text in a document. Amazon Textract can detect lines of
                *          text and the words that make up a line of text.</p>
                *          <p>
                *             <code>StartDocumentTextDetection</code> can analyze text in documents that are in JPEG, PNG, TIFF, and PDF format. The
                *         documents are stored in an Amazon S3 bucket. Use <a>DocumentLocation</a> to specify the bucket name and file name
                *         of the document.
                *      </p>
                *          <p>
                *             <code>StartTextDetection</code> returns a job identifier
                *             (<code>JobId</code>) that you use to get the results of the operation. When text
                *          detection is finished, Amazon Textract publishes a completion status to the Amazon Simple Notification Service (Amazon SNS)
                *          topic that you specify in <code>NotificationChannel</code>. To get the results of the text
                *          detection operation, first check that the status value published to the Amazon SNS topic is
                *             <code>SUCCEEDED</code>. If so, call <a>GetDocumentTextDetection</a>, and
                *          pass the job identifier (<code>JobId</code>) from the initial call to
                *             <code>StartDocumentTextDetection</code>.</p>
                *          <p>For more information, see <a href="https://docs.aws.amazon.com/textract/latest/dg/how-it-works-detecting.html">Document Text Detection</a>.</p>
                */
            startDocumentTextDetection(args: StartDocumentTextDetectionCommandInput, options?: __HttpHandlerOptions): Promise<StartDocumentTextDetectionCommandOutput>;
            startDocumentTextDetection(args: StartDocumentTextDetectionCommandInput, cb: (err: any, data?: StartDocumentTextDetectionCommandOutput) => void): void;
            startDocumentTextDetection(args: StartDocumentTextDetectionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: StartDocumentTextDetectionCommandOutput) => void): void;
            /**
                * <p>Starts the asynchronous analysis of invoices or receipts for data like contact information,
                *    items purchased, and vendor names.</p>
                *
                *          <p>
                *             <code>StartExpenseAnalysis</code> can analyze text in documents that are in JPEG, PNG, and
                *    PDF format. The documents must be stored in an Amazon S3 bucket. Use the <a>DocumentLocation</a> parameter to specify the name of your S3 bucket and the name of the
                *    document in that bucket. </p>
                *          <p>
                *             <code>StartExpenseAnalysis</code> returns a job identifier (<code>JobId</code>) that you
                *    will provide to <code>GetExpenseAnalysis</code> to retrieve the results of the operation. When
                *    the analysis of the input invoices/receipts is finished, Amazon Textract publishes a completion
                *    status to the Amazon Simple Notification Service (Amazon SNS) topic that you provide to the <code>NotificationChannel</code>.
                *    To obtain the results of the invoice and receipt analysis operation, ensure that the status value
                *    published to the Amazon SNS topic is <code>SUCCEEDED</code>. If so, call <a>GetExpenseAnalysis</a>, and pass the job identifier (<code>JobId</code>) that was
                *    returned by your call to <code>StartExpenseAnalysis</code>.</p>
                *          <p>For more information, see <a href="https://docs.aws.amazon.com/textract/latest/dg/invoice-receipts.html">Analyzing Invoices and Receipts</a>.</p>
                */
            startExpenseAnalysis(args: StartExpenseAnalysisCommandInput, options?: __HttpHandlerOptions): Promise<StartExpenseAnalysisCommandOutput>;
            startExpenseAnalysis(args: StartExpenseAnalysisCommandInput, cb: (err: any, data?: StartExpenseAnalysisCommandOutput) => void): void;
            startExpenseAnalysis(args: StartExpenseAnalysisCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: StartExpenseAnalysisCommandOutput) => void): void;
    }
}

declare module '@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/commands/AnalyzeDocumentCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { AnalyzeDocumentRequest, AnalyzeDocumentResponse } from "@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TextractClientResolvedConfig } from "@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/TextractClient";
    export interface AnalyzeDocumentCommandInput extends AnalyzeDocumentRequest {
    }
    export interface AnalyzeDocumentCommandOutput extends AnalyzeDocumentResponse, __MetadataBearer {
    }
    /**
        * <p>Analyzes an input document for relationships between detected items.  </p>
        *          <p>The types of information returned are as follows: </p>
        *          <ul>
        *             <li>
        *                <p>Form data (key-value pairs). The related information is returned in two <a>Block</a> objects, each of type <code>KEY_VALUE_SET</code>: a KEY
        *                   <code>Block</code> object and a VALUE <code>Block</code> object. For example,
        *                   <i>Name: Ana Silva Carolina</i> contains a key and value.
        *                   <i>Name:</i> is the key. <i>Ana Silva Carolina</i> is
        *                the value.</p>
        *             </li>
        *             <li>
        *                <p>Table and table cell data. A TABLE <code>Block</code> object contains information about a detected table. A CELL
        *                <code>Block</code> object is returned for each cell in a table.</p>
        *             </li>
        *             <li>
        *                <p>Lines and words of text. A LINE <code>Block</code> object contains one or more WORD <code>Block</code> objects.
        *         All lines and words that are detected in the document are returned (including text that doesn't have a
        *                relationship with the value of <code>FeatureTypes</code>). </p>
        *             </li>
        *             <li>
        *                <p>Queries.A QUERIES_RESULT Block object contains the answer to the query, the alias associated and an ID that
        *             connect it to the query asked. This Block also contains a location and attached confidence score.</p>
        *             </li>
        *          </ul>
        *
        *          <p>Selection elements such as check boxes and option buttons (radio buttons) can be detected in form data and in tables.
        *          A SELECTION_ELEMENT <code>Block</code> object contains information about a selection element,
        *          including the selection status.</p>
        *
        *          <p>You can choose which type of analysis to perform by specifying the <code>FeatureTypes</code> list.
        *       </p>
        *          <p>The output is returned in a list of <code>Block</code> objects.</p>
        *          <p>
        *             <code>AnalyzeDocument</code> is a synchronous operation. To analyze documents
        *       asynchronously, use <a>StartDocumentAnalysis</a>.</p>
        *          <p>For more information, see <a href="https://docs.aws.amazon.com/textract/latest/dg/how-it-works-analyzing.html">Document Text Analysis</a>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TextractClient, AnalyzeDocumentCommand } from "@aws-sdk/client-textract"; // ES Modules import
        * // const { TextractClient, AnalyzeDocumentCommand } = require("@aws-sdk/client-textract"); // CommonJS import
        * const client = new TextractClient(config);
        * const command = new AnalyzeDocumentCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link AnalyzeDocumentCommandInput} for command's `input` shape.
        * @see {@link AnalyzeDocumentCommandOutput} for command's `response` shape.
        * @see {@link TextractClientResolvedConfig | config} for TextractClient's `config` shape.
        *
        */
    export class AnalyzeDocumentCommand extends $Command<AnalyzeDocumentCommandInput, AnalyzeDocumentCommandOutput, TextractClientResolvedConfig> {
            readonly input: AnalyzeDocumentCommandInput;
            constructor(input: AnalyzeDocumentCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TextractClientResolvedConfig, options?: __HttpHandlerOptions): Handler<AnalyzeDocumentCommandInput, AnalyzeDocumentCommandOutput>;
    }
}

declare module '@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/commands/AnalyzeExpenseCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { AnalyzeExpenseRequest, AnalyzeExpenseResponse } from "@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TextractClientResolvedConfig } from "@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/TextractClient";
    export interface AnalyzeExpenseCommandInput extends AnalyzeExpenseRequest {
    }
    export interface AnalyzeExpenseCommandOutput extends AnalyzeExpenseResponse, __MetadataBearer {
    }
    /**
        * <p>
        *             <code>AnalyzeExpense</code> synchronously analyzes an input document for financially related relationships between text.</p>
        *          <p>Information is returned as <code>ExpenseDocuments</code> and seperated as follows.</p>
        *          <ul>
        *             <li>
        *                <p>
        *                   <code>LineItemGroups</code>- A data set containing <code>LineItems</code> which
        *          store information about the lines of text, such as an item purchased and its price on a receipt.</p>
        *             </li>
        *             <li>
        *                <p>
        *                   <code>SummaryFields</code>- Contains all other information a receipt, such as header information
        *          or the vendors name.</p>
        *             </li>
        *          </ul>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TextractClient, AnalyzeExpenseCommand } from "@aws-sdk/client-textract"; // ES Modules import
        * // const { TextractClient, AnalyzeExpenseCommand } = require("@aws-sdk/client-textract"); // CommonJS import
        * const client = new TextractClient(config);
        * const command = new AnalyzeExpenseCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link AnalyzeExpenseCommandInput} for command's `input` shape.
        * @see {@link AnalyzeExpenseCommandOutput} for command's `response` shape.
        * @see {@link TextractClientResolvedConfig | config} for TextractClient's `config` shape.
        *
        */
    export class AnalyzeExpenseCommand extends $Command<AnalyzeExpenseCommandInput, AnalyzeExpenseCommandOutput, TextractClientResolvedConfig> {
            readonly input: AnalyzeExpenseCommandInput;
            constructor(input: AnalyzeExpenseCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TextractClientResolvedConfig, options?: __HttpHandlerOptions): Handler<AnalyzeExpenseCommandInput, AnalyzeExpenseCommandOutput>;
    }
}

declare module '@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/commands/AnalyzeIDCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { AnalyzeIDRequest, AnalyzeIDResponse } from "@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TextractClientResolvedConfig } from "@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/TextractClient";
    export interface AnalyzeIDCommandInput extends AnalyzeIDRequest {
    }
    export interface AnalyzeIDCommandOutput extends AnalyzeIDResponse, __MetadataBearer {
    }
    /**
        * <p>Analyzes identity documents for relevant information. This information is extracted
        *          and returned as <code>IdentityDocumentFields</code>, which records both the normalized
        *          field and value of the extracted text.Unlike other Amazon Textract operations, <code>AnalyzeID</code>
        *       doesn't return any Geometry data.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TextractClient, AnalyzeIDCommand } from "@aws-sdk/client-textract"; // ES Modules import
        * // const { TextractClient, AnalyzeIDCommand } = require("@aws-sdk/client-textract"); // CommonJS import
        * const client = new TextractClient(config);
        * const command = new AnalyzeIDCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link AnalyzeIDCommandInput} for command's `input` shape.
        * @see {@link AnalyzeIDCommandOutput} for command's `response` shape.
        * @see {@link TextractClientResolvedConfig | config} for TextractClient's `config` shape.
        *
        */
    export class AnalyzeIDCommand extends $Command<AnalyzeIDCommandInput, AnalyzeIDCommandOutput, TextractClientResolvedConfig> {
            readonly input: AnalyzeIDCommandInput;
            constructor(input: AnalyzeIDCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TextractClientResolvedConfig, options?: __HttpHandlerOptions): Handler<AnalyzeIDCommandInput, AnalyzeIDCommandOutput>;
    }
}

declare module '@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/commands/DetectDocumentTextCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { DetectDocumentTextRequest, DetectDocumentTextResponse } from "@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TextractClientResolvedConfig } from "@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/TextractClient";
    export interface DetectDocumentTextCommandInput extends DetectDocumentTextRequest {
    }
    export interface DetectDocumentTextCommandOutput extends DetectDocumentTextResponse, __MetadataBearer {
    }
    /**
        * <p>Detects text in the input document. Amazon Textract can detect lines of text and the
        *          words that make up a line of text. The input document must be an image in JPEG, PNG, PDF, or TIFF
        *          format. <code>DetectDocumentText</code> returns the detected text in an array of <a>Block</a> objects. </p>
        *          <p>Each document page has as an associated <code>Block</code> of type PAGE. Each PAGE <code>Block</code> object
        *          is the parent of LINE <code>Block</code> objects that represent the lines of detected text on a page. A LINE <code>Block</code> object is
        *          a parent for each word that makes up the line. Words are represented by <code>Block</code> objects of type WORD.</p>
        *
        *          <p>
        *             <code>DetectDocumentText</code> is a synchronous operation. To analyze documents
        *          asynchronously, use <a>StartDocumentTextDetection</a>.</p>
        *          <p>For more information, see <a href="https://docs.aws.amazon.com/textract/latest/dg/how-it-works-detecting.html">Document Text Detection</a>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TextractClient, DetectDocumentTextCommand } from "@aws-sdk/client-textract"; // ES Modules import
        * // const { TextractClient, DetectDocumentTextCommand } = require("@aws-sdk/client-textract"); // CommonJS import
        * const client = new TextractClient(config);
        * const command = new DetectDocumentTextCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link DetectDocumentTextCommandInput} for command's `input` shape.
        * @see {@link DetectDocumentTextCommandOutput} for command's `response` shape.
        * @see {@link TextractClientResolvedConfig | config} for TextractClient's `config` shape.
        *
        */
    export class DetectDocumentTextCommand extends $Command<DetectDocumentTextCommandInput, DetectDocumentTextCommandOutput, TextractClientResolvedConfig> {
            readonly input: DetectDocumentTextCommandInput;
            constructor(input: DetectDocumentTextCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TextractClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DetectDocumentTextCommandInput, DetectDocumentTextCommandOutput>;
    }
}

declare module '@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/commands/GetDocumentAnalysisCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { GetDocumentAnalysisRequest, GetDocumentAnalysisResponse } from "@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TextractClientResolvedConfig } from "@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/TextractClient";
    export interface GetDocumentAnalysisCommandInput extends GetDocumentAnalysisRequest {
    }
    export interface GetDocumentAnalysisCommandOutput extends GetDocumentAnalysisResponse, __MetadataBearer {
    }
    /**
        * <p>Gets the results for an Amazon Textract asynchronous operation that analyzes text in a document.</p>
        *          <p>You start asynchronous text analysis by calling <a>StartDocumentAnalysis</a>, which returns a job identifier
        *             (<code>JobId</code>). When the text analysis operation finishes, Amazon Textract publishes a
        *          completion status to the Amazon Simple Notification Service (Amazon SNS) topic that's registered in the initial call to
        *             <code>StartDocumentAnalysis</code>. To get the results of the text-detection operation,
        *          first check that the status value published to the Amazon SNS topic is <code>SUCCEEDED</code>.
        *          If so, call <code>GetDocumentAnalysis</code>, and pass the job identifier
        *             (<code>JobId</code>) from the initial call to <code>StartDocumentAnalysis</code>.</p>
        *          <p>
        *             <code>GetDocumentAnalysis</code> returns an array of <a>Block</a> objects. The following
        *          types of information are returned: </p>
        *          <ul>
        *             <li>
        *                <p>Form data (key-value pairs). The related information is returned in two <a>Block</a> objects, each of type <code>KEY_VALUE_SET</code>: a KEY
        *             <code>Block</code> object and a VALUE <code>Block</code> object. For example,
        *             <i>Name: Ana Silva Carolina</i> contains a key and value.
        *             <i>Name:</i> is the key. <i>Ana Silva Carolina</i> is
        *             the value.</p>
        *             </li>
        *             <li>
        *                <p>Table and table cell data. A TABLE <code>Block</code> object contains information about a detected table. A CELL
        *             <code>Block</code> object is returned for each cell in a table.</p>
        *             </li>
        *             <li>
        *                <p>Lines and words of text. A LINE <code>Block</code> object contains one or more WORD <code>Block</code> objects.
        *             All lines and words that are detected in the document are returned (including text that doesn't have a
        *             relationship with the value of the <code>StartDocumentAnalysis</code>
        *                   <code>FeatureTypes</code> input parameter). </p>
        *             </li>
        *             <li>
        *                <p>Queries. A QUERIES_RESULT Block object contains the answer to the query, the alias associated and an ID that
        *             connect it to the query asked. This Block also contains a location and attached confidence score</p>
        *             </li>
        *          </ul>
        *
        *          <p>Selection elements such as check boxes and option buttons (radio buttons) can be detected in form data and in tables.
        *          A SELECTION_ELEMENT <code>Block</code> object contains information about a selection element,
        *          including the selection status.</p>
        *
        *
        *          <p>Use the <code>MaxResults</code> parameter to limit the number of blocks that are
        *          returned. If there are more results than specified in <code>MaxResults</code>, the value of
        *             <code>NextToken</code> in the operation response contains a pagination token for getting
        *          the next set of results. To get the next page of results, call
        *             <code>GetDocumentAnalysis</code>, and populate the <code>NextToken</code> request
        *          parameter with the token value that's returned from the previous call to
        *             <code>GetDocumentAnalysis</code>.</p>
        *          <p>For more information, see <a href="https://docs.aws.amazon.com/textract/latest/dg/how-it-works-analyzing.html">Document Text Analysis</a>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TextractClient, GetDocumentAnalysisCommand } from "@aws-sdk/client-textract"; // ES Modules import
        * // const { TextractClient, GetDocumentAnalysisCommand } = require("@aws-sdk/client-textract"); // CommonJS import
        * const client = new TextractClient(config);
        * const command = new GetDocumentAnalysisCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetDocumentAnalysisCommandInput} for command's `input` shape.
        * @see {@link GetDocumentAnalysisCommandOutput} for command's `response` shape.
        * @see {@link TextractClientResolvedConfig | config} for TextractClient's `config` shape.
        *
        */
    export class GetDocumentAnalysisCommand extends $Command<GetDocumentAnalysisCommandInput, GetDocumentAnalysisCommandOutput, TextractClientResolvedConfig> {
            readonly input: GetDocumentAnalysisCommandInput;
            constructor(input: GetDocumentAnalysisCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TextractClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetDocumentAnalysisCommandInput, GetDocumentAnalysisCommandOutput>;
    }
}

declare module '@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/commands/GetDocumentTextDetectionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { GetDocumentTextDetectionRequest, GetDocumentTextDetectionResponse } from "@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TextractClientResolvedConfig } from "@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/TextractClient";
    export interface GetDocumentTextDetectionCommandInput extends GetDocumentTextDetectionRequest {
    }
    export interface GetDocumentTextDetectionCommandOutput extends GetDocumentTextDetectionResponse, __MetadataBearer {
    }
    /**
        * <p>Gets the results for an Amazon Textract asynchronous operation that detects text in a document.
        *      Amazon Textract can detect lines of text and the words that make up a line of text.</p>
        *          <p>You start asynchronous text detection by calling <a>StartDocumentTextDetection</a>, which returns a job identifier
        *             (<code>JobId</code>). When the text detection operation finishes, Amazon Textract publishes a
        *          completion status to the Amazon Simple Notification Service (Amazon SNS) topic that's registered in the initial call to
        *             <code>StartDocumentTextDetection</code>. To get the results of the text-detection
        *          operation, first check that the status value published to the Amazon SNS topic is
        *             <code>SUCCEEDED</code>. If so, call <code>GetDocumentTextDetection</code>, and pass the
        *          job identifier (<code>JobId</code>) from the initial call to
        *             <code>StartDocumentTextDetection</code>.</p>
        *          <p>
        *             <code>GetDocumentTextDetection</code> returns an array of <a>Block</a>
        *          objects. </p>
        *          <p>Each document page has as an associated <code>Block</code> of type PAGE. Each PAGE <code>Block</code> object
        *         is the parent of LINE <code>Block</code> objects that represent the lines of detected text on a page. A LINE <code>Block</code> object is
        *         a parent for each word that makes up the line. Words are represented by <code>Block</code> objects of type WORD.</p>
        *
        *          <p>Use the MaxResults parameter to limit the number of blocks that are returned. If there
        *          are more results than specified in <code>MaxResults</code>, the value of
        *             <code>NextToken</code> in the operation response contains a pagination token for getting
        *          the next set of results. To get the next page of results, call
        *             <code>GetDocumentTextDetection</code>, and populate the <code>NextToken</code> request
        *          parameter with the token value that's returned from the previous call to
        *             <code>GetDocumentTextDetection</code>.</p>
        *          <p>For more information, see <a href="https://docs.aws.amazon.com/textract/latest/dg/how-it-works-detecting.html">Document Text Detection</a>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TextractClient, GetDocumentTextDetectionCommand } from "@aws-sdk/client-textract"; // ES Modules import
        * // const { TextractClient, GetDocumentTextDetectionCommand } = require("@aws-sdk/client-textract"); // CommonJS import
        * const client = new TextractClient(config);
        * const command = new GetDocumentTextDetectionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetDocumentTextDetectionCommandInput} for command's `input` shape.
        * @see {@link GetDocumentTextDetectionCommandOutput} for command's `response` shape.
        * @see {@link TextractClientResolvedConfig | config} for TextractClient's `config` shape.
        *
        */
    export class GetDocumentTextDetectionCommand extends $Command<GetDocumentTextDetectionCommandInput, GetDocumentTextDetectionCommandOutput, TextractClientResolvedConfig> {
            readonly input: GetDocumentTextDetectionCommandInput;
            constructor(input: GetDocumentTextDetectionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TextractClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetDocumentTextDetectionCommandInput, GetDocumentTextDetectionCommandOutput>;
    }
}

declare module '@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/commands/GetExpenseAnalysisCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { GetExpenseAnalysisRequest, GetExpenseAnalysisResponse } from "@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TextractClientResolvedConfig } from "@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/TextractClient";
    export interface GetExpenseAnalysisCommandInput extends GetExpenseAnalysisRequest {
    }
    export interface GetExpenseAnalysisCommandOutput extends GetExpenseAnalysisResponse, __MetadataBearer {
    }
    /**
        * <p>Gets the results for an Amazon Textract asynchronous operation that analyzes invoices and
        *    receipts. Amazon Textract finds contact information, items purchased, and vendor name, from input
        *    invoices and receipts.</p>
        *          <p>You start asynchronous invoice/receipt analysis by calling <a>StartExpenseAnalysis</a>, which returns a job identifier (<code>JobId</code>). Upon
        *    completion of the invoice/receipt analysis, Amazon Textract publishes the completion status to the
        *    Amazon Simple Notification Service (Amazon SNS) topic. This topic must be registered in the initial call to
        *     <code>StartExpenseAnalysis</code>. To get the results of the invoice/receipt analysis operation,
        *    first ensure that the status value published to the Amazon SNS topic is <code>SUCCEEDED</code>. If so,
        *    call <code>GetExpenseAnalysis</code>, and pass the job identifier (<code>JobId</code>) from the
        *    initial call to <code>StartExpenseAnalysis</code>.</p>
        *          <p>Use the MaxResults parameter to limit the number of blocks that are returned. If there are
        *    more results than specified in <code>MaxResults</code>, the value of <code>NextToken</code> in
        *    the operation response contains a pagination token for getting the next set of results. To get
        *    the next page of results, call <code>GetExpenseAnalysis</code>, and populate the
        *     <code>NextToken</code> request parameter with the token value that's returned from the previous
        *    call to <code>GetExpenseAnalysis</code>.</p>
        *          <p>For more information, see <a href="https://docs.aws.amazon.com/textract/latest/dg/invoices-receipts.html">Analyzing Invoices and Receipts</a>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TextractClient, GetExpenseAnalysisCommand } from "@aws-sdk/client-textract"; // ES Modules import
        * // const { TextractClient, GetExpenseAnalysisCommand } = require("@aws-sdk/client-textract"); // CommonJS import
        * const client = new TextractClient(config);
        * const command = new GetExpenseAnalysisCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link GetExpenseAnalysisCommandInput} for command's `input` shape.
        * @see {@link GetExpenseAnalysisCommandOutput} for command's `response` shape.
        * @see {@link TextractClientResolvedConfig | config} for TextractClient's `config` shape.
        *
        */
    export class GetExpenseAnalysisCommand extends $Command<GetExpenseAnalysisCommandInput, GetExpenseAnalysisCommandOutput, TextractClientResolvedConfig> {
            readonly input: GetExpenseAnalysisCommandInput;
            constructor(input: GetExpenseAnalysisCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TextractClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetExpenseAnalysisCommandInput, GetExpenseAnalysisCommandOutput>;
    }
}

declare module '@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/commands/StartDocumentAnalysisCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { StartDocumentAnalysisRequest, StartDocumentAnalysisResponse } from "@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TextractClientResolvedConfig } from "@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/TextractClient";
    export interface StartDocumentAnalysisCommandInput extends StartDocumentAnalysisRequest {
    }
    export interface StartDocumentAnalysisCommandOutput extends StartDocumentAnalysisResponse, __MetadataBearer {
    }
    /**
        * <p>Starts the asynchronous analysis of an input document for relationships between detected
        *          items such as key-value pairs, tables, and selection elements.</p>
        *
        *          <p>
        *             <code>StartDocumentAnalysis</code> can analyze text in documents that are in JPEG, PNG, TIFF, and PDF format. The
        *          documents are stored in an Amazon S3 bucket. Use <a>DocumentLocation</a> to specify the bucket name and file name
        *          of the document.
        *          </p>
        *          <p>
        *             <code>StartDocumentAnalysis</code> returns a job identifier
        *             (<code>JobId</code>) that you use to get the results of the operation. When text
        *          analysis is finished, Amazon Textract publishes a completion status to the Amazon Simple Notification Service (Amazon SNS)
        *          topic that you specify in <code>NotificationChannel</code>. To get the results of the text
        *          analysis operation, first check that the status value published to the Amazon SNS topic is
        *             <code>SUCCEEDED</code>. If so, call <a>GetDocumentAnalysis</a>, and pass
        *          the job identifier (<code>JobId</code>) from the initial call to
        *             <code>StartDocumentAnalysis</code>.</p>
        *          <p>For more information, see <a href="https://docs.aws.amazon.com/textract/latest/dg/how-it-works-analyzing.html">Document Text Analysis</a>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TextractClient, StartDocumentAnalysisCommand } from "@aws-sdk/client-textract"; // ES Modules import
        * // const { TextractClient, StartDocumentAnalysisCommand } = require("@aws-sdk/client-textract"); // CommonJS import
        * const client = new TextractClient(config);
        * const command = new StartDocumentAnalysisCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link StartDocumentAnalysisCommandInput} for command's `input` shape.
        * @see {@link StartDocumentAnalysisCommandOutput} for command's `response` shape.
        * @see {@link TextractClientResolvedConfig | config} for TextractClient's `config` shape.
        *
        */
    export class StartDocumentAnalysisCommand extends $Command<StartDocumentAnalysisCommandInput, StartDocumentAnalysisCommandOutput, TextractClientResolvedConfig> {
            readonly input: StartDocumentAnalysisCommandInput;
            constructor(input: StartDocumentAnalysisCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TextractClientResolvedConfig, options?: __HttpHandlerOptions): Handler<StartDocumentAnalysisCommandInput, StartDocumentAnalysisCommandOutput>;
    }
}

declare module '@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/commands/StartDocumentTextDetectionCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { StartDocumentTextDetectionRequest, StartDocumentTextDetectionResponse } from "@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TextractClientResolvedConfig } from "@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/TextractClient";
    export interface StartDocumentTextDetectionCommandInput extends StartDocumentTextDetectionRequest {
    }
    export interface StartDocumentTextDetectionCommandOutput extends StartDocumentTextDetectionResponse, __MetadataBearer {
    }
    /**
        * <p>Starts the asynchronous detection of text in a document. Amazon Textract can detect lines of
        *          text and the words that make up a line of text.</p>
        *          <p>
        *             <code>StartDocumentTextDetection</code> can analyze text in documents that are in JPEG, PNG, TIFF, and PDF format. The
        *         documents are stored in an Amazon S3 bucket. Use <a>DocumentLocation</a> to specify the bucket name and file name
        *         of the document.
        *      </p>
        *          <p>
        *             <code>StartTextDetection</code> returns a job identifier
        *             (<code>JobId</code>) that you use to get the results of the operation. When text
        *          detection is finished, Amazon Textract publishes a completion status to the Amazon Simple Notification Service (Amazon SNS)
        *          topic that you specify in <code>NotificationChannel</code>. To get the results of the text
        *          detection operation, first check that the status value published to the Amazon SNS topic is
        *             <code>SUCCEEDED</code>. If so, call <a>GetDocumentTextDetection</a>, and
        *          pass the job identifier (<code>JobId</code>) from the initial call to
        *             <code>StartDocumentTextDetection</code>.</p>
        *          <p>For more information, see <a href="https://docs.aws.amazon.com/textract/latest/dg/how-it-works-detecting.html">Document Text Detection</a>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TextractClient, StartDocumentTextDetectionCommand } from "@aws-sdk/client-textract"; // ES Modules import
        * // const { TextractClient, StartDocumentTextDetectionCommand } = require("@aws-sdk/client-textract"); // CommonJS import
        * const client = new TextractClient(config);
        * const command = new StartDocumentTextDetectionCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link StartDocumentTextDetectionCommandInput} for command's `input` shape.
        * @see {@link StartDocumentTextDetectionCommandOutput} for command's `response` shape.
        * @see {@link TextractClientResolvedConfig | config} for TextractClient's `config` shape.
        *
        */
    export class StartDocumentTextDetectionCommand extends $Command<StartDocumentTextDetectionCommandInput, StartDocumentTextDetectionCommandOutput, TextractClientResolvedConfig> {
            readonly input: StartDocumentTextDetectionCommandInput;
            constructor(input: StartDocumentTextDetectionCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TextractClientResolvedConfig, options?: __HttpHandlerOptions): Handler<StartDocumentTextDetectionCommandInput, StartDocumentTextDetectionCommandOutput>;
    }
}

declare module '@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/commands/StartExpenseAnalysisCommand' {
    import { Command as $Command } from "@aws-sdk/smithy-client";
    import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MetadataBearer as __MetadataBearer, MiddlewareStack } from "@aws-sdk/types";
    import { StartExpenseAnalysisRequest, StartExpenseAnalysisResponse } from "@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/models/models_0";
    import { ServiceInputTypes, ServiceOutputTypes, TextractClientResolvedConfig } from "@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/TextractClient";
    export interface StartExpenseAnalysisCommandInput extends StartExpenseAnalysisRequest {
    }
    export interface StartExpenseAnalysisCommandOutput extends StartExpenseAnalysisResponse, __MetadataBearer {
    }
    /**
        * <p>Starts the asynchronous analysis of invoices or receipts for data like contact information,
        *    items purchased, and vendor names.</p>
        *
        *          <p>
        *             <code>StartExpenseAnalysis</code> can analyze text in documents that are in JPEG, PNG, and
        *    PDF format. The documents must be stored in an Amazon S3 bucket. Use the <a>DocumentLocation</a> parameter to specify the name of your S3 bucket and the name of the
        *    document in that bucket. </p>
        *          <p>
        *             <code>StartExpenseAnalysis</code> returns a job identifier (<code>JobId</code>) that you
        *    will provide to <code>GetExpenseAnalysis</code> to retrieve the results of the operation. When
        *    the analysis of the input invoices/receipts is finished, Amazon Textract publishes a completion
        *    status to the Amazon Simple Notification Service (Amazon SNS) topic that you provide to the <code>NotificationChannel</code>.
        *    To obtain the results of the invoice and receipt analysis operation, ensure that the status value
        *    published to the Amazon SNS topic is <code>SUCCEEDED</code>. If so, call <a>GetExpenseAnalysis</a>, and pass the job identifier (<code>JobId</code>) that was
        *    returned by your call to <code>StartExpenseAnalysis</code>.</p>
        *          <p>For more information, see <a href="https://docs.aws.amazon.com/textract/latest/dg/invoice-receipts.html">Analyzing Invoices and Receipts</a>.</p>
        * @example
        * Use a bare-bones client and the command you need to make an API call.
        * ```javascript
        * import { TextractClient, StartExpenseAnalysisCommand } from "@aws-sdk/client-textract"; // ES Modules import
        * // const { TextractClient, StartExpenseAnalysisCommand } = require("@aws-sdk/client-textract"); // CommonJS import
        * const client = new TextractClient(config);
        * const command = new StartExpenseAnalysisCommand(input);
        * const response = await client.send(command);
        * ```
        *
        * @see {@link StartExpenseAnalysisCommandInput} for command's `input` shape.
        * @see {@link StartExpenseAnalysisCommandOutput} for command's `response` shape.
        * @see {@link TextractClientResolvedConfig | config} for TextractClient's `config` shape.
        *
        */
    export class StartExpenseAnalysisCommand extends $Command<StartExpenseAnalysisCommandInput, StartExpenseAnalysisCommandOutput, TextractClientResolvedConfig> {
            readonly input: StartExpenseAnalysisCommandInput;
            constructor(input: StartExpenseAnalysisCommandInput);
            /**
                * @internal
                */
            resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: TextractClientResolvedConfig, options?: __HttpHandlerOptions): Handler<StartExpenseAnalysisCommandInput, StartExpenseAnalysisCommandOutput>;
    }
}

declare module '@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/TextractClient' {
    import { EndpointsInputConfig, EndpointsResolvedConfig, RegionInputConfig, RegionResolvedConfig } from "@aws-sdk/config-resolver";
    import { HostHeaderInputConfig, HostHeaderResolvedConfig } from "@aws-sdk/middleware-host-header";
    import { RetryInputConfig, RetryResolvedConfig } from "@aws-sdk/middleware-retry";
    import { AwsAuthInputConfig, AwsAuthResolvedConfig } from "@aws-sdk/middleware-signing";
    import { UserAgentInputConfig, UserAgentResolvedConfig } from "@aws-sdk/middleware-user-agent";
    import { HttpHandler as __HttpHandler } from "@aws-sdk/protocol-http";
    import { Client as __Client, DefaultsMode, SmithyConfiguration as __SmithyConfiguration, SmithyResolvedConfiguration as __SmithyResolvedConfiguration } from "@aws-sdk/smithy-client";
    import { BodyLengthCalculator as __BodyLengthCalculator, Credentials as __Credentials, Decoder as __Decoder, Encoder as __Encoder, HashConstructor as __HashConstructor, HttpHandlerOptions as __HttpHandlerOptions, Logger as __Logger, Provider as __Provider, Provider, RegionInfoProvider, StreamCollector as __StreamCollector, UrlParser as __UrlParser, UserAgent as __UserAgent } from "@aws-sdk/types";
    import { AnalyzeDocumentCommandInput, AnalyzeDocumentCommandOutput } from "@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/commands/AnalyzeDocumentCommand";
    import { AnalyzeExpenseCommandInput, AnalyzeExpenseCommandOutput } from "@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/commands/AnalyzeExpenseCommand";
    import { AnalyzeIDCommandInput, AnalyzeIDCommandOutput } from "@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/commands/AnalyzeIDCommand";
    import { DetectDocumentTextCommandInput, DetectDocumentTextCommandOutput } from "@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/commands/DetectDocumentTextCommand";
    import { GetDocumentAnalysisCommandInput, GetDocumentAnalysisCommandOutput } from "@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/commands/GetDocumentAnalysisCommand";
    import { GetDocumentTextDetectionCommandInput, GetDocumentTextDetectionCommandOutput } from "@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/commands/GetDocumentTextDetectionCommand";
    import { GetExpenseAnalysisCommandInput, GetExpenseAnalysisCommandOutput } from "@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/commands/GetExpenseAnalysisCommand";
    import { StartDocumentAnalysisCommandInput, StartDocumentAnalysisCommandOutput } from "@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/commands/StartDocumentAnalysisCommand";
    import { StartDocumentTextDetectionCommandInput, StartDocumentTextDetectionCommandOutput } from "@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/commands/StartDocumentTextDetectionCommand";
    import { StartExpenseAnalysisCommandInput, StartExpenseAnalysisCommandOutput } from "@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/commands/StartExpenseAnalysisCommand";
    export type ServiceInputTypes = AnalyzeDocumentCommandInput | AnalyzeExpenseCommandInput | AnalyzeIDCommandInput | DetectDocumentTextCommandInput | GetDocumentAnalysisCommandInput | GetDocumentTextDetectionCommandInput | GetExpenseAnalysisCommandInput | StartDocumentAnalysisCommandInput | StartDocumentTextDetectionCommandInput | StartExpenseAnalysisCommandInput;
    export type ServiceOutputTypes = AnalyzeDocumentCommandOutput | AnalyzeExpenseCommandOutput | AnalyzeIDCommandOutput | DetectDocumentTextCommandOutput | GetDocumentAnalysisCommandOutput | GetDocumentTextDetectionCommandOutput | GetExpenseAnalysisCommandOutput | StartDocumentAnalysisCommandOutput | StartDocumentTextDetectionCommandOutput | StartExpenseAnalysisCommandOutput;
    export interface ClientDefaults extends Partial<__SmithyResolvedConfiguration<__HttpHandlerOptions>> {
            /**
                * The HTTP handler to use. Fetch in browser and Https in Nodejs.
                */
            requestHandler?: __HttpHandler;
            /**
                * A constructor for a class implementing the {@link __Hash} interface
                * that computes the SHA-256 HMAC or checksum of a string or binary buffer.
                * @internal
                */
            sha256?: __HashConstructor;
            /**
                * The function that will be used to convert strings into HTTP endpoints.
                * @internal
                */
            urlParser?: __UrlParser;
            /**
                * A function that can calculate the length of a request body.
                * @internal
                */
            bodyLengthChecker?: __BodyLengthCalculator;
            /**
                * A function that converts a stream into an array of bytes.
                * @internal
                */
            streamCollector?: __StreamCollector;
            /**
                * The function that will be used to convert a base64-encoded string to a byte array.
                * @internal
                */
            base64Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a base64-encoded string.
                * @internal
                */
            base64Encoder?: __Encoder;
            /**
                * The function that will be used to convert a UTF8-encoded string to a byte array.
                * @internal
                */
            utf8Decoder?: __Decoder;
            /**
                * The function that will be used to convert binary data to a UTF-8 encoded string.
                * @internal
                */
            utf8Encoder?: __Encoder;
            /**
                * The runtime environment.
                * @internal
                */
            runtime?: string;
            /**
                * Disable dyanamically changing the endpoint of the client based on the hostPrefix
                * trait of an operation.
                */
            disableHostPrefix?: boolean;
            /**
                * Value for how many times a request will be made at most in case of retry.
                */
            maxAttempts?: number | __Provider<number>;
            /**
                * Specifies which retry algorithm to use.
                */
            retryMode?: string | __Provider<string>;
            /**
                * Optional logger for logging debug/info/warn/error.
                */
            logger?: __Logger;
            /**
                * Enables IPv6/IPv4 dualstack endpoint.
                */
            useDualstackEndpoint?: boolean | __Provider<boolean>;
            /**
                * Enables FIPS compatible endpoints.
                */
            useFipsEndpoint?: boolean | __Provider<boolean>;
            /**
                * Unique service identifier.
                * @internal
                */
            serviceId?: string;
            /**
                * The AWS region to which this client will send requests
                */
            region?: string | __Provider<string>;
            /**
                * Default credentials provider; Not available in browser runtime.
                * @internal
                */
            credentialDefaultProvider?: (input: any) => __Provider<__Credentials>;
            /**
                * Fetch related hostname, signing name or signing region with given region.
                * @internal
                */
            regionInfoProvider?: RegionInfoProvider;
            /**
                * The provider populating default tracking information to be sent with `user-agent`, `x-amz-user-agent` header
                * @internal
                */
            defaultUserAgentProvider?: Provider<__UserAgent>;
            /**
                * The {@link DefaultsMode} that will be used to determine how certain default configuration options are resolved in the SDK.
                */
            defaultsMode?: DefaultsMode | Provider<DefaultsMode>;
    }
    type TextractClientConfigType = Partial<__SmithyConfiguration<__HttpHandlerOptions>> & ClientDefaults & RegionInputConfig & EndpointsInputConfig & RetryInputConfig & HostHeaderInputConfig & AwsAuthInputConfig & UserAgentInputConfig;
    /**
        * The configuration interface of TextractClient class constructor that set the region, credentials and other options.
        */
    export interface TextractClientConfig extends TextractClientConfigType {
    }
    type TextractClientResolvedConfigType = __SmithyResolvedConfiguration<__HttpHandlerOptions> & Required<ClientDefaults> & RegionResolvedConfig & EndpointsResolvedConfig & RetryResolvedConfig & HostHeaderResolvedConfig & AwsAuthResolvedConfig & UserAgentResolvedConfig;
    /**
        * The resolved configuration interface of TextractClient class. This is resolved and normalized from the {@link TextractClientConfig | constructor configuration interface}.
        */
    export interface TextractClientResolvedConfig extends TextractClientResolvedConfigType {
    }
    /**
        * <p>Amazon Textract detects and analyzes text in documents and converts it
        *          into machine-readable text. This is the API reference documentation for
        *          Amazon Textract.</p>
        */
    export class TextractClient extends __Client<__HttpHandlerOptions, ServiceInputTypes, ServiceOutputTypes, TextractClientResolvedConfig> {
            /**
                * The resolved configuration of TextractClient class. This is resolved and normalized from the {@link TextractClientConfig | constructor configuration interface}.
                */
            readonly config: TextractClientResolvedConfig;
            constructor(configuration: TextractClientConfig);
            /**
                * Destroy underlying resources, like sockets. It's usually not necessary to do this.
                * However in Node.js, it's best to explicitly shut down the client's agent when it is no longer needed.
                * Otherwise, sockets might stay open for quite a long time before the server terminates them.
                */
            destroy(): void;
    }
    export {};
}

declare module '@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/models/models_0' {
    import { ExceptionOptionType as __ExceptionOptionType, LazyJsonString as __LazyJsonString } from "@aws-sdk/smithy-client";
    import { TextractServiceException as __BaseException } from "@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/models/TextractServiceException";
    /**
        * <p>You aren't authorized to perform the action. Use the Amazon Resource Name (ARN)
        *             of an authorized user or IAM role to perform the operation.</p>
        */
    export class AccessDeniedException extends __BaseException {
            readonly name: "AccessDeniedException";
            readonly $fault: "client";
            Message?: string;
            Code?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<AccessDeniedException, __BaseException>);
    }
    /**
        * <p>The S3 bucket name and file name that identifies the document.</p>
        *          <p>The AWS Region for the S3 bucket that contains the document must match the Region that
        *          you use for Amazon Textract operations.</p>
        *
        *          <p>For Amazon Textract to process a file in an S3 bucket, the user must have
        *          permission to access the S3 bucket and file.
        *
        *       </p>
        */
    export interface S3Object {
            /**
                * <p>The name of the S3 bucket. Note that the # character is not valid in the file
                *          name.</p>
                */
            Bucket?: string;
            /**
                * <p>The file name of the input document. Synchronous operations can use image files that are
                *          in JPEG or PNG format. Asynchronous operations also support PDF and TIFF format files.</p>
                */
            Name?: string;
            /**
                * <p>If the bucket has versioning enabled, you can specify the object version. </p>
                */
            Version?: string;
    }
    export namespace S3Object {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: S3Object) => any;
    }
    /**
        * <p>The input document, either as bytes or as an S3 object.</p>
        *          <p>You pass image bytes to an Amazon Textract API operation by using the <code>Bytes</code>
        *          property. For example, you would use the <code>Bytes</code> property to pass a document
        *          loaded from a local file system. Image bytes passed by using the <code>Bytes</code>
        *          property must be base64 encoded. Your code might not need to encode document file bytes if
        *          you're using an AWS SDK to call Amazon Textract API operations. </p>
        *          <p>You pass images stored in an S3 bucket to an Amazon Textract API operation by using the
        *             <code>S3Object</code> property. Documents stored in an S3 bucket don't need to be base64
        *          encoded.</p>
        *          <p>The AWS Region for the S3 bucket that contains the S3 object must match the AWS
        *          Region that you use for Amazon Textract operations.</p>
        *          <p>If you use the AWS CLI to call Amazon Textract operations, passing image bytes using
        *          the Bytes property isn't supported. You must first upload the document to an Amazon S3
        *          bucket, and then call the operation using the S3Object property.</p>
        *
        *          <p>For Amazon Textract to process an S3 object, the user must have permission
        *          to access the S3 object. </p>
        */
    export interface Document {
            /**
                * <p>A blob of base64-encoded document bytes. The maximum size of a document that's provided
                *          in a blob of bytes is 5 MB. The document bytes must be in PNG or JPEG format.</p>
                *          <p>If you're using an AWS SDK to call Amazon Textract, you might not need to base64-encode
                *          image bytes passed using the <code>Bytes</code> field. </p>
                */
            Bytes?: Uint8Array;
            /**
                * <p>Identifies an S3 object as the document source. The maximum size of a document that's
                *          stored in an S3 bucket is 5 MB.</p>
                */
            S3Object?: S3Object;
    }
    export namespace Document {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Document) => any;
    }
    export enum FeatureType {
            FORMS = "FORMS",
            QUERIES = "QUERIES",
            TABLES = "TABLES"
    }
    export enum ContentClassifier {
            FREE_OF_ADULT_CONTENT = "FreeOfAdultContent",
            FREE_OF_PERSONALLY_IDENTIFIABLE_INFORMATION = "FreeOfPersonallyIdentifiableInformation"
    }
    /**
        * <p>Allows you to set attributes of the image. Currently, you can declare an image as free
        *          of personally identifiable information and adult content. </p>
        */
    export interface HumanLoopDataAttributes {
            /**
                * <p>Sets whether the input image is free of personally identifiable information or adult
                *          content.</p>
                */
            ContentClassifiers?: (ContentClassifier | string)[];
    }
    export namespace HumanLoopDataAttributes {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: HumanLoopDataAttributes) => any;
    }
    /**
        * <p>Sets up the human review workflow the document will be sent to if one of the conditions
        *          is met. You can also set certain attributes of the image before review. </p>
        */
    export interface HumanLoopConfig {
            /**
                * <p>The name of the human workflow used for this image. This should be kept unique within a
                *          region.</p>
                */
            HumanLoopName: string | undefined;
            /**
                * <p>The Amazon Resource Name (ARN) of the flow definition.</p>
                */
            FlowDefinitionArn: string | undefined;
            /**
                * <p>Sets attributes of the input data.</p>
                */
            DataAttributes?: HumanLoopDataAttributes;
    }
    export namespace HumanLoopConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: HumanLoopConfig) => any;
    }
    /**
        * <p>Each query contains the question you want to ask in the Text and the alias you want to associate.</p>
        */
    export interface Query {
            /**
                * <p>Question that Amazon Textract will apply to the document. An example would be "What is the customer's SSN?"</p>
                */
            Text: string | undefined;
            /**
                * <p>Alias attached to the query, for ease of location.</p>
                */
            Alias?: string;
            /**
                * <p>List of pages associated with the query. The following is a list of rules for using this parameter.</p>
                *          <ul>
                *             <li>
                *                <p>If a page is not specified, it is set to <code>["1"]</code> by default.</p>
                *             </li>
                *             <li>
                *                <p>The following characters are allowed in the parameter's string:
                *                <code>0 1 2 3 4 5 6 7 8 9 - *</code>. No whitespace is allowed.</p>
                *             </li>
                *             <li>
                *                <p>When using <code>*</code> to indicate all pages, it must be the only element
                *                in the string.</p>
                *             </li>
                *             <li>
                *                <p>You can use page intervals, such as <code>[1-3, 1-1, 4-*]</code>. Where <code>*</code> indicates last page of
                *                document.</p>
                *             </li>
                *             <li>
                *                <p>Specified pages must be greater than 0 and less than or equal to the number of pages in the document.</p>
                *             </li>
                *          </ul>
                */
            Pages?: string[];
    }
    export namespace Query {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Query) => any;
    }
    /**
        * <p></p>
        */
    export interface QueriesConfig {
            /**
                * <p></p>
                */
            Queries: Query[] | undefined;
    }
    export namespace QueriesConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: QueriesConfig) => any;
    }
    export interface AnalyzeDocumentRequest {
            /**
                * <p>The input document as base64-encoded bytes or an Amazon S3 object. If you use the AWS CLI
                *          to call Amazon Textract operations, you can't pass image bytes. The document must be an image
                *          in JPEG, PNG, PDF, or TIFF format.</p>
                *          <p>If you're using an AWS SDK to call Amazon Textract, you might not need to base64-encode
                *          image bytes that are passed using the <code>Bytes</code> field. </p>
                */
            Document: Document | undefined;
            /**
                * <p>A list of the types of analysis to perform. Add TABLES to the list to return information
                *          about the tables that are detected in the input document. Add FORMS to return detected form data.
                *          To perform both types of analysis, add TABLES and FORMS to
                *             <code>FeatureTypes</code>. All lines and words detected in the document are included in
                *          the response (including text that isn't related to the value of <code>FeatureTypes</code>). </p>
                */
            FeatureTypes: (FeatureType | string)[] | undefined;
            /**
                * <p>Sets the configuration for the human in the loop workflow for analyzing documents.</p>
                */
            HumanLoopConfig?: HumanLoopConfig;
            /**
                * <p>Contains Queries and the alias for those Queries, as determined by the input. </p>
                */
            QueriesConfig?: QueriesConfig;
    }
    export namespace AnalyzeDocumentRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AnalyzeDocumentRequest) => any;
    }
    export enum BlockType {
            CELL = "CELL",
            KEY_VALUE_SET = "KEY_VALUE_SET",
            LINE = "LINE",
            MERGED_CELL = "MERGED_CELL",
            PAGE = "PAGE",
            QUERY = "QUERY",
            QUERY_RESULT = "QUERY_RESULT",
            SELECTION_ELEMENT = "SELECTION_ELEMENT",
            TABLE = "TABLE",
            TITLE = "TITLE",
            WORD = "WORD"
    }
    export enum EntityType {
            COLUMN_HEADER = "COLUMN_HEADER",
            KEY = "KEY",
            VALUE = "VALUE"
    }
    /**
        * <p>The bounding box around the detected page, text, key-value pair, table, table cell, or
        *          selection element on a document page. The <code>left</code> (x-coordinate) and
        *             <code>top</code> (y-coordinate) are coordinates that represent the top and left sides of
        *          the bounding box. Note that the upper-left corner of the image is the origin (0,0). </p>
        *          <p>The <code>top</code> and <code>left</code> values returned are ratios of the overall
        *          document page size. For example, if the input image is 700 x 200 pixels, and the top-left
        *          coordinate of the bounding box is 350 x 50 pixels, the API returns a <code>left</code>
        *          value of 0.5 (350/700) and a <code>top</code> value of 0.25 (50/200).</p>
        *          <p>The <code>width</code> and <code>height</code> values represent the dimensions of the
        *          bounding box as a ratio of the overall document page dimension. For example, if the
        *          document page size is 700 x 200 pixels, and the bounding box width is 70 pixels, the width
        *          returned is 0.1. </p>
        */
    export interface BoundingBox {
            /**
                * <p>The width of the bounding box as a ratio of the overall document page
                *          width.</p>
                */
            Width?: number;
            /**
                * <p>The height of the bounding box as a ratio of the overall document page
                *          height.</p>
                */
            Height?: number;
            /**
                * <p>The left coordinate of the bounding box as a ratio of overall document page
                *          width.</p>
                */
            Left?: number;
            /**
                * <p>The top coordinate of the bounding box as a ratio of overall document page
                *          height.</p>
                */
            Top?: number;
    }
    export namespace BoundingBox {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: BoundingBox) => any;
    }
    /**
        * <p>The X and Y coordinates of a point on a document page. The X and Y
        *          values that are returned are ratios of the overall document page size. For example, if the
        *          input document is 700 x 200 and the operation returns X=0.5 and Y=0.25, then the point is
        *          at the (350,50) pixel coordinate on the document page.</p>
        *
        *          <p>An array of <code>Point</code> objects, <code>Polygon</code>, is returned
        *          by <a>DetectDocumentText</a>. <code>Polygon</code> represents a fine-grained
        *          polygon around detected text. For more information, see Geometry in the Amazon Textract
        *          Developer Guide. </p>
        */
    export interface Point {
            /**
                * <p>The value of the X coordinate for a point on a <code>Polygon</code>.</p>
                */
            X?: number;
            /**
                * <p>The value of the Y coordinate for a point on a <code>Polygon</code>.</p>
                */
            Y?: number;
    }
    export namespace Point {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Point) => any;
    }
    /**
        * <p>Information about where the following items are located on a document page: detected
        *          page, text, key-value pairs, tables, table cells, and selection elements.</p>
        */
    export interface Geometry {
            /**
                * <p>An axis-aligned coarse representation of the location of the recognized item on the
                *          document page.</p>
                */
            BoundingBox?: BoundingBox;
            /**
                * <p>Within the bounding box, a fine-grained polygon around the recognized item.</p>
                */
            Polygon?: Point[];
    }
    export namespace Geometry {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Geometry) => any;
    }
    export enum RelationshipType {
            ANSWER = "ANSWER",
            CHILD = "CHILD",
            COMPLEX_FEATURES = "COMPLEX_FEATURES",
            MERGED_CELL = "MERGED_CELL",
            TITLE = "TITLE",
            VALUE = "VALUE"
    }
    /**
        * <p>Information about how blocks are related to each other. A <code>Block</code> object
        *          contains 0 or more <code>Relation</code> objects in a list, <code>Relationships</code>. For
        *          more information, see <a>Block</a>.</p>
        *          <p>The <code>Type</code> element provides the type of the relationship for all blocks in
        *          the <code>IDs</code> array. </p>
        */
    export interface Relationship {
            /**
                * <p>The type of relationship that the blocks in the IDs array have with the current block.
                *          The relationship can be <code>VALUE</code> or <code>CHILD</code>. A relationship of type
                *          VALUE is a list that contains the ID of the VALUE block that's associated with the KEY of a
                *          key-value pair. A relationship of type CHILD is a list of IDs that identify WORD blocks in
                *          the case of lines Cell blocks in the case of Tables, and WORD blocks in the case of
                *          Selection Elements.</p>
                */
            Type?: RelationshipType | string;
            /**
                * <p>An
                *          array of IDs for related blocks. You can get the type of the relationship from the
                *             <code>Type</code> element.</p>
                */
            Ids?: string[];
    }
    export namespace Relationship {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Relationship) => any;
    }
    export enum SelectionStatus {
            NOT_SELECTED = "NOT_SELECTED",
            SELECTED = "SELECTED"
    }
    export enum TextType {
            HANDWRITING = "HANDWRITING",
            PRINTED = "PRINTED"
    }
    /**
        * <p>A <code>Block</code> represents items that are recognized in a document within a group
        *          of pixels close to each other. The information returned in a <code>Block</code> object
        *          depends on the type of operation. In text detection for documents (for example <a>DetectDocumentText</a>), you get information about the detected words and lines
        *          of text. In text analysis (for example <a>AnalyzeDocument</a>), you can also get
        *          information about the fields, tables, and selection elements that are detected in the
        *          document.</p>
        *          <p>An array of <code>Block</code> objects is returned by both synchronous and asynchronous
        *          operations. In synchronous operations, such as <a>DetectDocumentText</a>, the
        *          array of <code>Block</code> objects is the entire set of results. In asynchronous
        *          operations, such as <a>GetDocumentAnalysis</a>, the array is returned over one
        *          or more responses.</p>
        *          <p>For more information, see <a href="https://docs.aws.amazon.com/textract/latest/dg/how-it-works.html">How Amazon Textract Works</a>.</p>
        */
    export interface Block {
            /**
                * <p>The type of text item that's recognized. In operations for text detection, the following
                *          types are returned:</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <i>PAGE</i> - Contains a list of the LINE <code>Block</code> objects
                *                that are detected on a document page.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <i>WORD</i> - A word detected on a document page. A word is one or
                *                more ISO basic Latin script characters that aren't separated by spaces.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <i>LINE</i> - A string of tab-delimited, contiguous words that are
                *                detected on a document page.</p>
                *             </li>
                *          </ul>
                *          <p>In text analysis operations, the following types are returned:</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <i>PAGE</i> - Contains a list of child <code>Block</code> objects
                *                that are detected on a document page.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <i>KEY_VALUE_SET</i> - Stores the KEY and VALUE <code>Block</code>
                *                objects for linked text that's detected on a document page. Use the
                *                   <code>EntityType</code> field to determine if a KEY_VALUE_SET object is a KEY
                *                   <code>Block</code> object or a VALUE <code>Block</code> object. </p>
                *             </li>
                *             <li>
                *                <p>
                *                   <i>WORD</i> - A word that's detected on a document page. A word is
                *                one or more ISO basic Latin script characters that aren't separated by spaces.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <i>LINE</i> - A string of tab-delimited, contiguous words that are
                *                detected on a document page.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <i>TABLE</i> - A table that's detected on a document page. A table
                *                is grid-based information with two or more rows or columns, with a cell span of one
                *                row and one column each. </p>
                *             </li>
                *             <li>
                *                <p>
                *                   <i>CELL</i> - A cell within a detected table. The cell is the parent
                *                of the block that contains the text in the cell.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <i>SELECTION_ELEMENT</i> - A selection element such as an option
                *                button (radio button) or a check box that's detected on a document page. Use the
                *                value of <code>SelectionStatus</code> to determine the status of the selection
                *                element.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <i>QUERY</i> - A question asked during the call of AnalyzeDocument. Contains an
                *                alias and an ID that attachs it to its answer.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <i>QUERY_RESULT</i> - A response to a question asked during the call
                *                of analyze document. Comes with an alias and ID for ease of locating in a
                *                response. Also contains location and confidence score.</p>
                *             </li>
                *          </ul>
                */
            BlockType?: BlockType | string;
            /**
                * <p>The confidence score that Amazon Textract has in the accuracy of the recognized text and
                *          the accuracy of the geometry points around the recognized text.</p>
                */
            Confidence?: number;
            /**
                * <p>The word or line of text that's recognized by Amazon Textract. </p>
                */
            Text?: string;
            /**
                * <p>The kind of text that Amazon Textract has detected. Can check for handwritten text and
                *          printed text.</p>
                */
            TextType?: TextType | string;
            /**
                * <p>The row in which a table cell is located. The first row position is 1.
                *             <code>RowIndex</code> isn't returned by <code>DetectDocumentText</code> and
                *             <code>GetDocumentTextDetection</code>.</p>
                */
            RowIndex?: number;
            /**
                * <p>The column in which a table cell appears. The first column position is 1.
                *             <code>ColumnIndex</code> isn't returned by <code>DetectDocumentText</code> and
                *             <code>GetDocumentTextDetection</code>.</p>
                */
            ColumnIndex?: number;
            /**
                * <p>The number of rows that a table cell spans. Currently this value is always 1, even if
                *          the number of rows spanned is greater than 1. <code>RowSpan</code> isn't returned by
                *             <code>DetectDocumentText</code> and <code>GetDocumentTextDetection</code>.</p>
                */
            RowSpan?: number;
            /**
                * <p>The number of columns that a table cell spans. Currently this value is always 1, even if
                *          the number of columns spanned is greater than 1. <code>ColumnSpan</code> isn't returned by
                *             <code>DetectDocumentText</code> and <code>GetDocumentTextDetection</code>. </p>
                */
            ColumnSpan?: number;
            /**
                * <p>The location of the recognized text on the image. It includes an axis-aligned, coarse
                *          bounding box that surrounds the text, and a finer-grain polygon for more accurate spatial
                *          information. </p>
                */
            Geometry?: Geometry;
            /**
                * <p>The identifier for the recognized text. The identifier is only unique for a single
                *          operation. </p>
                */
            Id?: string;
            /**
                * <p>A list of child blocks of the current block. For example, a LINE object has child blocks
                *          for each WORD block that's part of the line of text. There aren't Relationship objects in
                *          the list for relationships that don't exist, such as when the current block has no child
                *          blocks. The list size can be the following:</p>
                *          <ul>
                *             <li>
                *                <p>0 - The block has no child blocks.</p>
                *             </li>
                *             <li>
                *                <p>1 - The block has child blocks.</p>
                *             </li>
                *          </ul>
                */
            Relationships?: Relationship[];
            /**
                * <p>The type of entity. The following can be returned:</p>
                *          <ul>
                *             <li>
                *                <p>
                *                   <i>KEY</i> - An identifier for a field on the document.</p>
                *             </li>
                *             <li>
                *                <p>
                *                   <i>VALUE</i> - The field text.</p>
                *             </li>
                *          </ul>
                *          <p>
                *             <code>EntityTypes</code> isn't returned by <code>DetectDocumentText</code> and
                *             <code>GetDocumentTextDetection</code>.</p>
                */
            EntityTypes?: (EntityType | string)[];
            /**
                * <p>The selection status of a selection element, such as an option button or check box.
                *       </p>
                */
            SelectionStatus?: SelectionStatus | string;
            /**
                * <p>The page on which a block was detected. <code>Page</code> is returned by asynchronous
                *          operations. Page values greater than 1 are only returned for multipage documents that are
                *          in PDF or TIFF format. A scanned image (JPEG/PNG), even if it contains multiple document pages, is
                *          considered to be a single-page document. The value of <code>Page</code> is always 1.
                *          Synchronous operations don't return <code>Page</code> because every input document is
                *          considered to be a single-page document.</p>
                */
            Page?: number;
            /**
                * <p></p>
                */
            Query?: Query;
    }
    export namespace Block {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Block) => any;
    }
    /**
        * <p>Information about the input document.</p>
        */
    export interface DocumentMetadata {
            /**
                * <p>The number of pages that are detected in the document.</p>
                */
            Pages?: number;
    }
    export namespace DocumentMetadata {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DocumentMetadata) => any;
    }
    /**
        * <p>Shows the results of the human in the loop evaluation. If there is no HumanLoopArn, the
        *          input did not trigger human review.</p>
        */
    export interface HumanLoopActivationOutput {
            /**
                * <p>The Amazon Resource Name (ARN) of the HumanLoop created.</p>
                */
            HumanLoopArn?: string;
            /**
                * <p>Shows if and why human review was needed.</p>
                */
            HumanLoopActivationReasons?: string[];
            /**
                * <p>Shows the result of condition evaluations, including those conditions which activated a
                *          human review.</p>
                */
            HumanLoopActivationConditionsEvaluationResults?: __LazyJsonString | string;
    }
    export namespace HumanLoopActivationOutput {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: HumanLoopActivationOutput) => any;
    }
    export interface AnalyzeDocumentResponse {
            /**
                * <p>Metadata about the analyzed document. An example is the number of pages.</p>
                */
            DocumentMetadata?: DocumentMetadata;
            /**
                * <p>The items that are detected and analyzed by <code>AnalyzeDocument</code>.</p>
                */
            Blocks?: Block[];
            /**
                * <p>Shows the results of the human in the loop evaluation.</p>
                */
            HumanLoopActivationOutput?: HumanLoopActivationOutput;
            /**
                * <p>The version of the model used to analyze the document.</p>
                */
            AnalyzeDocumentModelVersion?: string;
    }
    export namespace AnalyzeDocumentResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AnalyzeDocumentResponse) => any;
    }
    /**
        * <p>Amazon Textract isn't able to read the document. For more information on the document
        *          limits in Amazon Textract, see <a>limits</a>.</p>
        */
    export class BadDocumentException extends __BaseException {
            readonly name: "BadDocumentException";
            readonly $fault: "client";
            Message?: string;
            Code?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<BadDocumentException, __BaseException>);
    }
    /**
        * <p>The document can't be processed because it's too large. The maximum document size for
        *          synchronous operations 10 MB. The maximum document size for asynchronous operations is 500
        *          MB for PDF files.</p>
        */
    export class DocumentTooLargeException extends __BaseException {
            readonly name: "DocumentTooLargeException";
            readonly $fault: "client";
            Message?: string;
            Code?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<DocumentTooLargeException, __BaseException>);
    }
    /**
        * <p>Indicates you have exceeded the maximum number of active human in the loop workflows available</p>
        */
    export class HumanLoopQuotaExceededException extends __BaseException {
            readonly name: "HumanLoopQuotaExceededException";
            readonly $fault: "client";
            /**
                * <p>The resource type.</p>
                */
            ResourceType?: string;
            /**
                * <p>The quota code.</p>
                */
            QuotaCode?: string;
            /**
                * <p>The service code.</p>
                */
            ServiceCode?: string;
            Message?: string;
            Code?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<HumanLoopQuotaExceededException, __BaseException>);
    }
    /**
        * <p>Amazon Textract experienced a service issue. Try your call again.</p>
        */
    export class InternalServerError extends __BaseException {
            readonly name: "InternalServerError";
            readonly $fault: "server";
            Message?: string;
            Code?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InternalServerError, __BaseException>);
    }
    /**
        * <p>An input parameter violated a constraint. For example, in synchronous operations,
        *        an <code>InvalidParameterException</code> exception occurs
        *       when neither of the <code>S3Object</code> or <code>Bytes</code> values are supplied in the <code>Document</code>
        *       request parameter.
        *        Validate your parameter before calling the API operation again.</p>
        */
    export class InvalidParameterException extends __BaseException {
            readonly name: "InvalidParameterException";
            readonly $fault: "client";
            Message?: string;
            Code?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidParameterException, __BaseException>);
    }
    /**
        * <p>Amazon Textract is unable to access the S3 object that's specified in the request.
        *          for more information, <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/s3-access-control.html">Configure Access to Amazon S3</a>
        *          For troubleshooting information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/troubleshooting.html">Troubleshooting Amazon S3</a>
        *          </p>
        */
    export class InvalidS3ObjectException extends __BaseException {
            readonly name: "InvalidS3ObjectException";
            readonly $fault: "client";
            Message?: string;
            Code?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidS3ObjectException, __BaseException>);
    }
    /**
        * <p>The number of requests exceeded your throughput limit. If you want to increase this limit,
        *          contact Amazon Textract.</p>
        */
    export class ProvisionedThroughputExceededException extends __BaseException {
            readonly name: "ProvisionedThroughputExceededException";
            readonly $fault: "client";
            Message?: string;
            Code?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ProvisionedThroughputExceededException, __BaseException>);
    }
    /**
        * <p>Amazon Textract is temporarily unable to process the request. Try your call again.</p>
        */
    export class ThrottlingException extends __BaseException {
            readonly name: "ThrottlingException";
            readonly $fault: "server";
            Message?: string;
            Code?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<ThrottlingException, __BaseException>);
    }
    /**
        * <p>The format of the input document isn't supported. Documents for operations can be in
        *          PNG, JPEG, PDF, or TIFF format.</p>
        */
    export class UnsupportedDocumentException extends __BaseException {
            readonly name: "UnsupportedDocumentException";
            readonly $fault: "client";
            Message?: string;
            Code?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<UnsupportedDocumentException, __BaseException>);
    }
    export interface AnalyzeExpenseRequest {
            /**
                * <p>The input document, either as bytes or as an S3 object.</p>
                *          <p>You pass image bytes to an Amazon Textract API operation by using the <code>Bytes</code>
                *          property. For example, you would use the <code>Bytes</code> property to pass a document
                *          loaded from a local file system. Image bytes passed by using the <code>Bytes</code>
                *          property must be base64 encoded. Your code might not need to encode document file bytes if
                *          you're using an AWS SDK to call Amazon Textract API operations. </p>
                *          <p>You pass images stored in an S3 bucket to an Amazon Textract API operation by using the
                *             <code>S3Object</code> property. Documents stored in an S3 bucket don't need to be base64
                *          encoded.</p>
                *          <p>The AWS Region for the S3 bucket that contains the S3 object must match the AWS
                *          Region that you use for Amazon Textract operations.</p>
                *          <p>If you use the AWS CLI to call Amazon Textract operations, passing image bytes using
                *          the Bytes property isn't supported. You must first upload the document to an Amazon S3
                *          bucket, and then call the operation using the S3Object property.</p>
                *
                *          <p>For Amazon Textract to process an S3 object, the user must have permission
                *          to access the S3 object. </p>
                */
            Document: Document | undefined;
    }
    export namespace AnalyzeExpenseRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AnalyzeExpenseRequest) => any;
    }
    /**
        * <p>An object used to store information about the Value or Label detected by Amazon Textract.</p>
        */
    export interface ExpenseDetection {
            /**
                * <p>The word or line of text recognized by Amazon Textract</p>
                */
            Text?: string;
            /**
                * <p>Information about where the following items are located on a document page: detected
                *          page, text, key-value pairs, tables, table cells, and selection elements.</p>
                */
            Geometry?: Geometry;
            /**
                * <p>The confidence in detection, as a percentage</p>
                */
            Confidence?: number;
    }
    export namespace ExpenseDetection {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ExpenseDetection) => any;
    }
    /**
        * <p>An object used to store information about the Type detected by Amazon Textract.</p>
        */
    export interface ExpenseType {
            /**
                * <p>The word or line of text detected by Amazon Textract.</p>
                */
            Text?: string;
            /**
                * <p>The confidence of accuracy, as a percentage.</p>
                */
            Confidence?: number;
    }
    export namespace ExpenseType {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ExpenseType) => any;
    }
    /**
        * <p>Breakdown of detected information, seperated into
        *          the catagories Type, LabelDetection, and ValueDetection</p>
        */
    export interface ExpenseField {
            /**
                * <p>The implied label of a detected element. Present alongside LabelDetection for explicit elements.</p>
                */
            Type?: ExpenseType;
            /**
                * <p>The explicitly stated label of a detected element.</p>
                */
            LabelDetection?: ExpenseDetection;
            /**
                * <p>The value of a detected element. Present in explicit and implicit elements.</p>
                */
            ValueDetection?: ExpenseDetection;
            /**
                * <p>The page number the value was detected on.</p>
                */
            PageNumber?: number;
    }
    export namespace ExpenseField {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ExpenseField) => any;
    }
    /**
        * <p>A structure that holds information about the different lines found in a document's tables.</p>
        */
    export interface LineItemFields {
            /**
                * <p>ExpenseFields used to show information from detected lines on a table.</p>
                */
            LineItemExpenseFields?: ExpenseField[];
    }
    export namespace LineItemFields {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: LineItemFields) => any;
    }
    /**
        * <p>A grouping of tables which contain LineItems, with each table identified by the table's <code>LineItemGroupIndex</code>.</p>
        */
    export interface LineItemGroup {
            /**
                * <p>The number used to identify a specific table in a document. The first table encountered will have a LineItemGroupIndex of 1, the second 2, etc.</p>
                */
            LineItemGroupIndex?: number;
            /**
                * <p>The breakdown of information on a particular line of a table. </p>
                */
            LineItems?: LineItemFields[];
    }
    export namespace LineItemGroup {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: LineItemGroup) => any;
    }
    /**
        * <p>The structure holding all the information returned by AnalyzeExpense</p>
        */
    export interface ExpenseDocument {
            /**
                * <p>Denotes which invoice or receipt in the document the information is coming from.
                *       First document will be 1, the second 2, and so on.</p>
                */
            ExpenseIndex?: number;
            /**
                * <p>Any information found outside of a table by Amazon Textract.</p>
                */
            SummaryFields?: ExpenseField[];
            /**
                * <p>Information detected on each table of a document, seperated into <code>LineItems</code>.</p>
                */
            LineItemGroups?: LineItemGroup[];
    }
    export namespace ExpenseDocument {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: ExpenseDocument) => any;
    }
    export interface AnalyzeExpenseResponse {
            /**
                * <p>Information about the input document.</p>
                */
            DocumentMetadata?: DocumentMetadata;
            /**
                * <p>The expenses detected by Amazon Textract.</p>
                */
            ExpenseDocuments?: ExpenseDocument[];
    }
    export namespace AnalyzeExpenseResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AnalyzeExpenseResponse) => any;
    }
    export interface AnalyzeIDRequest {
            /**
                * <p>The document being passed to AnalyzeID.</p>
                */
            DocumentPages: Document[] | undefined;
    }
    export namespace AnalyzeIDRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AnalyzeIDRequest) => any;
    }
    export enum ValueType {
            DATE = "DATE"
    }
    /**
        * <p>Contains information relating to dates in a document, including the type
        *          of value, and the value.</p>
        */
    export interface NormalizedValue {
            /**
                * <p>The value of the date, written as Year-Month-DayTHour:Minute:Second.</p>
                */
            Value?: string;
            /**
                * <p>The normalized type of the value detected. In this case, DATE.</p>
                */
            ValueType?: ValueType | string;
    }
    export namespace NormalizedValue {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: NormalizedValue) => any;
    }
    /**
        * <p>Used to contain the information detected by an AnalyzeID operation.</p>
        */
    export interface AnalyzeIDDetections {
            /**
                * <p>Text of either the normalized field or value associated with it.</p>
                */
            Text: string | undefined;
            /**
                * <p>Only returned for dates, returns the type of value detected and the date
                *          written in a more machine readable way.</p>
                */
            NormalizedValue?: NormalizedValue;
            /**
                * <p>The confidence score of the detected text.</p>
                */
            Confidence?: number;
    }
    export namespace AnalyzeIDDetections {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AnalyzeIDDetections) => any;
    }
    /**
        * <p>Structure containing both the normalized type of the extracted information
        *          and the text associated with it. These are extracted as Type and Value respectively.</p>
        */
    export interface IdentityDocumentField {
            /**
                * <p>Used to contain the information detected by an AnalyzeID operation.</p>
                */
            Type?: AnalyzeIDDetections;
            /**
                * <p>Used to contain the information detected by an AnalyzeID operation.</p>
                */
            ValueDetection?: AnalyzeIDDetections;
    }
    export namespace IdentityDocumentField {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: IdentityDocumentField) => any;
    }
    /**
        * <p>The structure that lists each document processed in an AnalyzeID operation.</p>
        */
    export interface IdentityDocument {
            /**
                * <p>Denotes the placement of a document in the IdentityDocument list. The first document
                *          is marked 1, the second 2 and so on.</p>
                */
            DocumentIndex?: number;
            /**
                * <p>The structure used to record information extracted from identity documents.
                *          Contains both normalized field and value of the extracted text.</p>
                */
            IdentityDocumentFields?: IdentityDocumentField[];
    }
    export namespace IdentityDocument {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: IdentityDocument) => any;
    }
    export interface AnalyzeIDResponse {
            /**
                * <p>The list of documents processed by AnalyzeID. Includes a number denoting their
                *          place in the list and the response structure for the document.</p>
                */
            IdentityDocuments?: IdentityDocument[];
            /**
                * <p>Information about the input document.</p>
                */
            DocumentMetadata?: DocumentMetadata;
            /**
                * <p>The version of the AnalyzeIdentity API being used to process documents.</p>
                */
            AnalyzeIDModelVersion?: string;
    }
    export namespace AnalyzeIDResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: AnalyzeIDResponse) => any;
    }
    export interface DetectDocumentTextRequest {
            /**
                * <p>The input document as base64-encoded bytes or an Amazon S3 object. If you use the AWS CLI
                *          to call Amazon Textract operations, you can't pass image bytes. The document must be an image
                *       in JPEG or PNG format.</p>
                *          <p>If you're using an AWS SDK to call Amazon Textract, you might not need to base64-encode
                *          image bytes that are passed using the <code>Bytes</code> field. </p>
                */
            Document: Document | undefined;
    }
    export namespace DetectDocumentTextRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DetectDocumentTextRequest) => any;
    }
    export interface DetectDocumentTextResponse {
            /**
                * <p>Metadata about the document. It contains the number of pages that are detected in the
                *          document.</p>
                */
            DocumentMetadata?: DocumentMetadata;
            /**
                * <p>An array of <code>Block</code> objects that contain the text that's detected in the
                *          document.</p>
                */
            Blocks?: Block[];
            /**
                * <p></p>
                */
            DetectDocumentTextModelVersion?: string;
    }
    export namespace DetectDocumentTextResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DetectDocumentTextResponse) => any;
    }
    /**
        * <p>The Amazon S3 bucket that contains the document to be processed. It's used by asynchronous
        *          operations such as <a>StartDocumentTextDetection</a>.</p>
        *          <p>The input document can be an image file in JPEG or PNG format. It can also be a file in
        *          PDF format.</p>
        */
    export interface DocumentLocation {
            /**
                * <p>The Amazon S3 bucket that contains the input document.</p>
                */
            S3Object?: S3Object;
    }
    export namespace DocumentLocation {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: DocumentLocation) => any;
    }
    export interface GetDocumentAnalysisRequest {
            /**
                * <p>A unique identifier for the text-detection job. The <code>JobId</code> is returned from
                *          <code>StartDocumentAnalysis</code>. A <code>JobId</code> value is only valid for 7 days.</p>
                */
            JobId: string | undefined;
            /**
                * <p>The maximum number of results to return per paginated call. The largest value that you
                *          can specify is 1,000. If you specify a value greater than 1,000, a maximum of 1,000 results
                *          is returned. The default value is 1,000.</p>
                */
            MaxResults?: number;
            /**
                * <p>If the previous response was incomplete (because there are more blocks to retrieve), Amazon Textract returns a pagination
                *          token in the response. You can use this pagination token to retrieve the next set of blocks.</p>
                */
            NextToken?: string;
    }
    export namespace GetDocumentAnalysisRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetDocumentAnalysisRequest) => any;
    }
    export enum JobStatus {
            FAILED = "FAILED",
            IN_PROGRESS = "IN_PROGRESS",
            PARTIAL_SUCCESS = "PARTIAL_SUCCESS",
            SUCCEEDED = "SUCCEEDED"
    }
    /**
        * <p>A warning about an issue that occurred during asynchronous text analysis (<a>StartDocumentAnalysis</a>) or asynchronous document text detection (<a>StartDocumentTextDetection</a>). </p>
        */
    export interface Warning {
            /**
                * <p>The error code for the warning.</p>
                */
            ErrorCode?: string;
            /**
                * <p>A list of the pages that the warning applies to.</p>
                */
            Pages?: number[];
    }
    export namespace Warning {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: Warning) => any;
    }
    export interface GetDocumentAnalysisResponse {
            /**
                * <p>Information about a document that Amazon Textract processed. <code>DocumentMetadata</code> is
                *          returned in every page of paginated responses from an Amazon Textract video operation.</p>
                */
            DocumentMetadata?: DocumentMetadata;
            /**
                * <p>The current status of the text detection job.</p>
                */
            JobStatus?: JobStatus | string;
            /**
                * <p>If the response is truncated, Amazon Textract returns this token. You can use this token in
                *          the subsequent request to retrieve the next set of text detection results.</p>
                */
            NextToken?: string;
            /**
                * <p>The results of the text-analysis operation.</p>
                */
            Blocks?: Block[];
            /**
                * <p>A list of warnings that occurred during the document-analysis operation.</p>
                */
            Warnings?: Warning[];
            /**
                * <p>Returns if the detection job could not be completed. Contains explanation for what error occured.</p>
                */
            StatusMessage?: string;
            /**
                * <p></p>
                */
            AnalyzeDocumentModelVersion?: string;
    }
    export namespace GetDocumentAnalysisResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetDocumentAnalysisResponse) => any;
    }
    /**
        * <p>An invalid job identifier was passed to <a>GetDocumentAnalysis</a> or to
        *       <a>GetDocumentAnalysis</a>.</p>
        */
    export class InvalidJobIdException extends __BaseException {
            readonly name: "InvalidJobIdException";
            readonly $fault: "client";
            Message?: string;
            Code?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidJobIdException, __BaseException>);
    }
    /**
        * <p> Indicates you do not have decrypt permissions with the KMS key entered, or the KMS key
        *         was entered incorrectly. </p>
        */
    export class InvalidKMSKeyException extends __BaseException {
            readonly name: "InvalidKMSKeyException";
            readonly $fault: "client";
            Message?: string;
            Code?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<InvalidKMSKeyException, __BaseException>);
    }
    export interface GetDocumentTextDetectionRequest {
            /**
                * <p>A unique identifier for the text detection job. The <code>JobId</code> is returned from
                *          <code>StartDocumentTextDetection</code>. A <code>JobId</code> value is only valid for 7 days.</p>
                */
            JobId: string | undefined;
            /**
                * <p>The maximum number of results to return per paginated call. The largest value you can
                *          specify is 1,000. If you specify a value greater than 1,000, a maximum of 1,000 results is
                *          returned. The default value is 1,000.</p>
                */
            MaxResults?: number;
            /**
                * <p>If the previous response was incomplete (because there are more blocks to retrieve), Amazon Textract returns a pagination
                *          token in the response. You can use this pagination token to retrieve the next set of blocks.</p>
                */
            NextToken?: string;
    }
    export namespace GetDocumentTextDetectionRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetDocumentTextDetectionRequest) => any;
    }
    export interface GetDocumentTextDetectionResponse {
            /**
                * <p>Information about a document that Amazon Textract processed. <code>DocumentMetadata</code> is
                *          returned in every page of paginated responses from an Amazon Textract video operation.</p>
                */
            DocumentMetadata?: DocumentMetadata;
            /**
                * <p>The current status of the text detection job.</p>
                */
            JobStatus?: JobStatus | string;
            /**
                * <p>If the response is truncated, Amazon Textract returns this token. You can use this token in
                *          the subsequent request to retrieve the next set of text-detection results.</p>
                */
            NextToken?: string;
            /**
                * <p>The results of the text-detection operation.</p>
                */
            Blocks?: Block[];
            /**
                * <p>A list of warnings that occurred during the text-detection operation for the
                *          document.</p>
                */
            Warnings?: Warning[];
            /**
                * <p>Returns if the detection job could not be completed. Contains explanation for what error occured. </p>
                */
            StatusMessage?: string;
            /**
                * <p></p>
                */
            DetectDocumentTextModelVersion?: string;
    }
    export namespace GetDocumentTextDetectionResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetDocumentTextDetectionResponse) => any;
    }
    export interface GetExpenseAnalysisRequest {
            /**
                * <p>A unique identifier for the text detection job. The <code>JobId</code> is returned from
                *     <code>StartExpenseAnalysis</code>. A <code>JobId</code> value is only valid for 7 days.</p>
                */
            JobId: string | undefined;
            /**
                * <p>The maximum number of results to return per paginated call. The largest value you can
                *    specify is 20. If you specify a value greater than 20, a maximum of 20 results is
                *    returned. The default value is 20.</p>
                */
            MaxResults?: number;
            /**
                * <p>If the previous response was incomplete (because there are more blocks to retrieve), Amazon Textract returns a pagination
                *    token in the response. You can use this pagination token to retrieve the next set of blocks.</p>
                */
            NextToken?: string;
    }
    export namespace GetExpenseAnalysisRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetExpenseAnalysisRequest) => any;
    }
    export interface GetExpenseAnalysisResponse {
            /**
                * <p>Information about a document that Amazon Textract processed. <code>DocumentMetadata</code> is
                *    returned in every page of paginated responses from an Amazon Textract operation.</p>
                */
            DocumentMetadata?: DocumentMetadata;
            /**
                * <p>The current status of the text detection job.</p>
                */
            JobStatus?: JobStatus | string;
            /**
                * <p>If the response is truncated, Amazon Textract returns this token. You can use this token in
                *    the subsequent request to retrieve the next set of text-detection results.</p>
                */
            NextToken?: string;
            /**
                * <p>The expenses detected by Amazon Textract.</p>
                */
            ExpenseDocuments?: ExpenseDocument[];
            /**
                * <p>A list of warnings that occurred during the text-detection operation for the
                *    document.</p>
                */
            Warnings?: Warning[];
            /**
                * <p>Returns if the detection job could not be completed. Contains explanation for what error occured. </p>
                */
            StatusMessage?: string;
            /**
                * <p>The current model version of AnalyzeExpense.</p>
                */
            AnalyzeExpenseModelVersion?: string;
    }
    export namespace GetExpenseAnalysisResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: GetExpenseAnalysisResponse) => any;
    }
    /**
        * <p>A <code>ClientRequestToken</code> input parameter was reused with an operation, but at
        *          least one of the other input parameters is different from the previous call to the
        *          operation. </p>
        */
    export class IdempotentParameterMismatchException extends __BaseException {
            readonly name: "IdempotentParameterMismatchException";
            readonly $fault: "client";
            Message?: string;
            Code?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<IdempotentParameterMismatchException, __BaseException>);
    }
    /**
        * <p>An Amazon Textract service limit was exceeded. For example, if you start too many
        *          asynchronous jobs concurrently, calls to start operations
        *             (<code>StartDocumentTextDetection</code>, for example) raise a LimitExceededException
        *          exception (HTTP status code: 400) until the number of concurrently running jobs is below
        *          the Amazon Textract service limit. </p>
        */
    export class LimitExceededException extends __BaseException {
            readonly name: "LimitExceededException";
            readonly $fault: "client";
            Message?: string;
            Code?: string;
            /**
                * @internal
                */
            constructor(opts: __ExceptionOptionType<LimitExceededException, __BaseException>);
    }
    /**
        * <p>The Amazon Simple Notification Service (Amazon SNS) topic to which Amazon Textract publishes the completion status of
        *          an asynchronous document operation, such as <a>StartDocumentTextDetection</a>. </p>
        */
    export interface NotificationChannel {
            /**
                * <p>The Amazon SNS topic that Amazon Textract posts the completion status to.</p>
                */
            SNSTopicArn: string | undefined;
            /**
                * <p>The Amazon Resource Name (ARN) of an IAM role that gives Amazon Textract publishing permissions to the Amazon SNS topic. </p>
                */
            RoleArn: string | undefined;
    }
    export namespace NotificationChannel {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: NotificationChannel) => any;
    }
    /**
        * <p>Sets whether or not your output will go to a user created bucket. Used to set the name
        *          of the bucket, and the prefix on the output file.</p>
        *          <p>
        *             <code>OutputConfig</code> is an optional parameter which lets you adjust where your output will be placed.
        *          By default, Amazon Textract will store the results internally and can only be accessed by the Get
        *          API operations. With OutputConfig enabled, you can set the name of the bucket the output will be
        *          sent to and the file prefix of the results where you can download your results. Additionally, you
        *          can set the <code>KMSKeyID</code> parameter to a customer master key (CMK) to encrypt your output. Without this
        *          parameter set Amazon Textract will encrypt server-side using the AWS managed CMK for Amazon S3.</p>
        *          <p>Decryption of Customer Content is necessary for processing of the documents by Amazon Textract. If your account
        *          is opted out under an AI services opt out policy then all unencrypted Customer Content is immediately and permanently deleted after
        *          the Customer Content has been processed by the service. No copy of of the output is retained by Amazon Textract. For information about how to opt out, see <a href="https://docs.aws.amazon.com/organizations/latest/userguide/orgs_manage_policies_ai-opt-out.html"> Managing AI services opt-out policy. </a>
        *          </p>
        *          <p>For more information on data privacy,
        *          see the <a href="https://aws.amazon.com/compliance/data-privacy-faq/">Data Privacy
        *             FAQ</a>.</p>
        */
    export interface OutputConfig {
            /**
                * <p>The name of the bucket your output will go to.</p>
                */
            S3Bucket: string | undefined;
            /**
                * <p>The prefix of the object key that the output will be saved to. When not enabled, the
                *          prefix will be textract_output".</p>
                */
            S3Prefix?: string;
    }
    export namespace OutputConfig {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: OutputConfig) => any;
    }
    export interface StartDocumentAnalysisRequest {
            /**
                * <p>The location of the document to be processed.</p>
                */
            DocumentLocation: DocumentLocation | undefined;
            /**
                * <p>A list of the types of analysis to perform. Add TABLES to the list to return information
                *          about the tables that are detected in the input document. Add FORMS to return detected
                *          form data. To perform both types of analysis, add TABLES
                *          and FORMS to <code>FeatureTypes</code>. All lines and words detected in the document are
                *          included in the response (including text that isn't related to the value of
                *             <code>FeatureTypes</code>). </p>
                */
            FeatureTypes: (FeatureType | string)[] | undefined;
            /**
                * <p>The idempotent token that you use to identify the start request. If you use the same
                *          token with multiple <code>StartDocumentAnalysis</code> requests, the same
                *             <code>JobId</code> is returned. Use <code>ClientRequestToken</code> to prevent the same
                *          job from being accidentally started more than once. For more information, see
                *          <a href="https://docs.aws.amazon.com/textract/latest/dg/api-async.html">Calling Amazon Textract Asynchronous Operations</a>.</p>
                */
            ClientRequestToken?: string;
            /**
                * <p>An identifier that you specify that's included in the completion notification published
                *          to the Amazon SNS topic. For example, you can use <code>JobTag</code> to identify the type of
                *          document that the completion notification corresponds to (such as a tax form or a
                *          receipt).</p>
                */
            JobTag?: string;
            /**
                * <p>The Amazon SNS topic ARN that you want Amazon Textract to publish the completion status of the
                *          operation to. </p>
                */
            NotificationChannel?: NotificationChannel;
            /**
                * <p>Sets if the output will go to a customer defined bucket. By default, Amazon Textract will save
                *          the results internally to be accessed by the GetDocumentAnalysis operation.</p>
                */
            OutputConfig?: OutputConfig;
            /**
                * <p>The KMS key used to encrypt the inference results. This can be
                *          in either Key ID or Key Alias format. When a KMS key is provided, the
                *          KMS key will be used for server-side encryption of the objects in the
                *          customer bucket. When this parameter is not enabled, the result will
                *          be encrypted server side,using SSE-S3.</p>
                */
            KMSKeyId?: string;
            /**
                * <p></p>
                */
            QueriesConfig?: QueriesConfig;
    }
    export namespace StartDocumentAnalysisRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StartDocumentAnalysisRequest) => any;
    }
    export interface StartDocumentAnalysisResponse {
            /**
                * <p>The identifier for the document text detection job. Use <code>JobId</code> to identify
                *          the job in a subsequent call to <code>GetDocumentAnalysis</code>. A <code>JobId</code> value
                *          is only valid for 7 days.</p>
                */
            JobId?: string;
    }
    export namespace StartDocumentAnalysisResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StartDocumentAnalysisResponse) => any;
    }
    export interface StartDocumentTextDetectionRequest {
            /**
                * <p>The location of the document to be processed.</p>
                */
            DocumentLocation: DocumentLocation | undefined;
            /**
                * <p>The idempotent token that's used to identify the start request. If you use the same
                *          token with multiple <code>StartDocumentTextDetection</code> requests, the same
                *             <code>JobId</code> is returned. Use <code>ClientRequestToken</code> to prevent the same
                *          job from being accidentally started more than once. For more information, see
                *          <a href="https://docs.aws.amazon.com/textract/latest/dg/api-async.html">Calling Amazon Textract Asynchronous Operations</a>.</p>
                */
            ClientRequestToken?: string;
            /**
                * <p>An identifier that you specify that's included in the completion notification published
                *          to the Amazon SNS topic. For example, you can use <code>JobTag</code> to identify the type of
                *          document that the completion notification corresponds to (such as a tax form or a
                *          receipt).</p>
                */
            JobTag?: string;
            /**
                * <p>The Amazon SNS topic ARN that you want Amazon Textract to publish the completion status of the
                *          operation to. </p>
                */
            NotificationChannel?: NotificationChannel;
            /**
                * <p>Sets if the output will go to a customer defined bucket. By default Amazon Textract will
                *          save the results internally to be accessed with the GetDocumentTextDetection operation.</p>
                */
            OutputConfig?: OutputConfig;
            /**
                * <p>The KMS key used to encrypt the inference results. This can be
                *          in either Key ID or Key Alias format. When a KMS key is provided, the
                *          KMS key will be used for server-side encryption of the objects in the
                *          customer bucket. When this parameter is not enabled, the result will
                *          be encrypted server side,using SSE-S3.</p>
                */
            KMSKeyId?: string;
    }
    export namespace StartDocumentTextDetectionRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StartDocumentTextDetectionRequest) => any;
    }
    export interface StartDocumentTextDetectionResponse {
            /**
                * <p>The identifier of the text detection job for the document. Use <code>JobId</code> to
                *          identify the job in a subsequent call to <code>GetDocumentTextDetection</code>.
                *          A <code>JobId</code> value is only valid for 7 days.</p>
                */
            JobId?: string;
    }
    export namespace StartDocumentTextDetectionResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StartDocumentTextDetectionResponse) => any;
    }
    export interface StartExpenseAnalysisRequest {
            /**
                * <p>The location of the document to be processed.</p>
                */
            DocumentLocation: DocumentLocation | undefined;
            /**
                * <p>The idempotent token that's used to identify the start request. If you use the same token with multiple <code>StartDocumentTextDetection</code> requests, the same <code>JobId</code> is returned.
                *    Use <code>ClientRequestToken</code> to prevent the same job from being accidentally started more than once.
                *    For more information, see <a href="https://docs.aws.amazon.com/textract/latest/dg/api-async.html">Calling Amazon Textract Asynchronous Operations</a>
                *          </p>
                */
            ClientRequestToken?: string;
            /**
                * <p>An identifier you specify that's included in the completion notification published
                *    to the Amazon SNS topic. For example, you can use <code>JobTag</code> to identify the type of
                *    document that the completion notification corresponds to (such as a tax form or a
                *    receipt).</p>
                */
            JobTag?: string;
            /**
                * <p>The Amazon SNS topic ARN that you want Amazon Textract to publish the completion status of the
                *    operation to. </p>
                */
            NotificationChannel?: NotificationChannel;
            /**
                * <p>Sets if the output will go to a customer defined bucket. By default, Amazon Textract will
                *    save the results internally to be accessed by the <code>GetExpenseAnalysis</code>
                *    operation.</p>
                */
            OutputConfig?: OutputConfig;
            /**
                * <p>The KMS key used to encrypt the inference results. This can be
                *    in either Key ID or Key Alias format. When a KMS key is provided, the
                *    KMS key will be used for server-side encryption of the objects in the
                *    customer bucket. When this parameter is not enabled, the result will
                *    be encrypted server side,using SSE-S3.</p>
                */
            KMSKeyId?: string;
    }
    export namespace StartExpenseAnalysisRequest {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StartExpenseAnalysisRequest) => any;
    }
    export interface StartExpenseAnalysisResponse {
            /**
                * <p>A unique identifier for the text detection job. The <code>JobId</code> is returned from
                *     <code>StartExpenseAnalysis</code>. A <code>JobId</code> value is only valid for 7 days.</p>
                */
            JobId?: string;
    }
    export namespace StartExpenseAnalysisResponse {
            /**
                * @internal
                */
            const filterSensitiveLog: (obj: StartExpenseAnalysisResponse) => any;
    }
}

declare module '@aws-sdk/client-textract/node_modules/@aws-sdk/client-textract/dist-types/models/TextractServiceException' {
    import { ServiceException as __ServiceException, ServiceExceptionOptions as __ServiceExceptionOptions } from "@aws-sdk/smithy-client";
    /**
        * Base exception class for all service exceptions from Textract service.
        */
    export class TextractServiceException extends __ServiceException {
            /**
                * @internal
                */
            constructor(options: __ServiceExceptionOptions);
    }
}

